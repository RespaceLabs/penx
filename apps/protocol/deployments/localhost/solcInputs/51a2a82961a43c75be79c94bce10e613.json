{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToUintMap storage map, uint256 key, string memory errorMessage) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/facets/AccountFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../utils/AddressUtils.sol\";\nimport \"../process/AssetsProcess.sol\";\nimport \"../process/AccountProcess.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract AccountFacet is IAccount {\n    using SafeERC20 for IERC20;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n    using Config for Config.Props;\n\n    function deposit(address token, uint256 amount) external payable override {\n        if (amount == 0) {\n            revert Errors.AmountZeroNotAllowed();\n        }\n        bool isNativeToken = token == address(0);\n        if (isNativeToken && msg.value != amount) {\n            revert Errors.AmountNotMatch(msg.value, amount);\n        }\n        address account = msg.sender;\n        AssetsProcess.deposit(\n            AssetsProcess.DepositParams(\n                account,\n                isNativeToken ? Config.load().getWrapperToken() : token,\n                amount,\n                AssetsProcess.DepositFrom.MANUAL,\n                isNativeToken\n            )\n        );\n    }\n\n    function createWithdrawRequest(address token, uint256 amount) external override {\n        AddressUtils.validEmpty(token);\n        if (amount == 0) {\n            revert Errors.AmountZeroNotAllowed();\n        }\n        AssetsProcess.createWithdrawRequest(token, amount);\n    }\n\n    function executeWithdraw(uint256 requestId, OracleProcess.OracleParam[] calldata oracles) external override {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        Withdraw.Request memory request = Withdraw.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.WithdrawRequestNotExists();\n        }\n        OracleProcess.setOraclePrice(oracles);\n        AssetsProcess.executeWithdraw(requestId, request);\n        OracleProcess.clearOraclePrice();\n    }\n\n    function cancelWithdraw(uint256 requestId, bytes32 reasonCode) external override {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        Withdraw.Request memory request = Withdraw.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.WithdrawRequestNotExists();\n        }\n        AssetsProcess.cancelWithdraw(requestId, request, reasonCode);\n    }\n\n    function batchUpdateAccountToken(AssetsProcess.UpdateAccountTokenParams calldata params) external override {\n        AddressUtils.validEmpty(params.account);\n        AssetsProcess.updateAccountToken(params);\n    }\n\n    function getAccountInfo(address account) external view override returns (AccountInfo memory) {\n        Account.Props storage accountInfo = Account.load(account);\n        address[] memory tokens = accountInfo.getTokens();\n        Account.TokenBalance[] memory tokenBalances = new Account.TokenBalance[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            tokenBalances[i] = accountInfo.getTokenBalance(tokens[i]);\n        }\n        bytes32[] memory positions = accountInfo.getAllPosition();\n        return AccountInfo(account, tokenBalances, tokens, positions, 0, 0, 0, accountInfo.orderHoldInUsd, 0, 0, 0);\n    }\n\n    function getAccountInfoWithOracles(\n        address account,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external view returns (AccountInfo memory) {\n        Account.Props storage accountInfo = Account.load(account);\n        address[] memory tokens = accountInfo.getTokens();\n        Account.TokenBalance[] memory tokenBalances = new Account.TokenBalance[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            tokenBalances[i] = accountInfo.getTokenBalance(tokens[i]);\n        }\n        bytes32[] memory positions = accountInfo.getAllPosition();\n        (int256 accountMMR, int256 crossNetValue, uint256 totalMM) = accountInfo.getCrossMMR(oracles);\n        return\n            AccountInfo(\n                account,\n                tokenBalances,\n                tokens,\n                positions,\n                accountInfo.getPortfolioNetValue(oracles),\n                accountInfo.getTotalUsedValue(oracles),\n                accountInfo.getCrossAvailableValue(oracles),\n                accountInfo.orderHoldInUsd,\n                accountMMR,\n                crossNetValue,\n                totalMM\n            );\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/facets/AutoReduceFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IAutoReduce.sol\";\nimport \"../process/AutoReduceProcess.sol\";\nimport \"../process/GasProcess.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract AutoReduceFacet is IAutoReduce {\n    function autoRedeem(\n        address stakeToken,\n        address[] calldata account,\n        address collateral,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        uint256 startGas = gasleft();\n        OracleProcess.setOraclePrice(oracles);\n        AutoReduceProcess.autoRedeem(stakeToken, account, collateral);\n        OracleProcess.clearOraclePrice();\n        GasProcess.addLossExecutionFee(startGas);\n        \n    }\n\n    function autoReduce(\n        bytes32[] calldata positionKeys,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external override {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        uint256 startGas = gasleft();\n        OracleProcess.setOraclePrice(oracles);\n        AutoReduceProcess.autoReducePositions(positionKeys);\n        OracleProcess.clearOraclePrice();\n        GasProcess.addLossExecutionFee(startGas);\n    }\n}\n"
    },
    "contracts/facets/ConfigFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/ConfigProcess.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract ConfigFacet {\n\n    function getConfig() external view returns (IConfig.CommonConfigParams memory config) {\n        return ConfigProcess.getConfig();\n    }\n\n    function getPoolConfig(address stakeToken) public view returns (IConfig.LpPoolConfigParams memory config) {\n        return ConfigProcess.getPoolConfig(stakeToken);\n    }\n\n    function getUsdPoolConfig() public view returns (IConfig.UsdPoolConfigParams memory config) {\n        return ConfigProcess.getUsdPoolConfig();\n    }\n\n    function getSymbolConfig(bytes32 code) public view returns (IConfig.SymbolConfigParams memory config) {\n        return ConfigProcess.getSymbolConfig(code);\n    }\n\n    function setConfig(IConfig.CommonConfigParams calldata params) external {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_CONFIG);\n        ConfigProcess.setConfig(params);\n    }\n\n    function setPoolConfig(IConfig.LpPoolConfigParams calldata params) external {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_CONFIG);\n        ConfigProcess.setPoolConfig(params);\n    }\n\n    function setUsdPoolConfig(IConfig.UsdPoolConfigParams calldata params) external {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_CONFIG);\n        ConfigProcess.setUsdPoolConfig(params);\n    }\n\n    function setSymbolConfig(IConfig.SymbolConfigParams calldata params) external {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_CONFIG);\n        ConfigProcess.setSymbolConfig(params);\n    }\n}\n"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../storage/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions.\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { LibDiamond } from  \"../storage/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        // create an array set to the maximum size possible\n        facets_ = new Facet[](selectorCount);\n        // create an array for counting the number of selectors for each facet\n        uint16[] memory numFacetSelectors = new uint16[](selectorCount);\n        // total number of facets\n        uint256 numFacets;\n        // loop through function selectors\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\n            bytes4 selector = ds.selectors[selectorIndex];\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            bool continueLoop = false;\n            // find the functionSelectors array for selector and add selector to it\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                if (facets_[facetIndex].facetAddress == facetAddress_) {\n                    facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;                                   \n                    numFacetSelectors[facetIndex]++;\n                    continueLoop = true;\n                    break;\n                }\n            }\n            // if functionSelectors array exists for selector then continue loop\n            if (continueLoop) {\n                continueLoop = false;\n                continue;\n            }\n            // create a new functionSelectors array for selector\n            facets_[numFacets].facetAddress = facetAddress_;\n            facets_[numFacets].functionSelectors = new bytes4[](selectorCount);\n            facets_[numFacets].functionSelectors[0] = selector;\n            numFacetSelectors[numFacets] = 1;\n            numFacets++;\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](selectorCount);\n        // loop through function selectors\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\n            bytes4 selector = ds.selectors[selectorIndex];\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            if (_facet == facetAddress_) {\n                _facetFunctionSelectors[numSelectors] = selector;\n                numSelectors++;\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        // create an array set to the maximum size possible\n        facetAddresses_ = new address[](selectorCount);\n        uint256 numFacets;\n        // loop through function selectors\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\n            bytes4 selector = ds.selectors[selectorIndex];\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            bool continueLoop = false;\n            // see if we have collected the address already and break out of loop if we have\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                if (facetAddress_ == facetAddresses_[facetIndex]) {\n                    continueLoop = true;\n                    break;\n                }\n            }\n            // continue loop if we already have the address\n            if (continueLoop) {\n                continueLoop = false;\n                continue;\n            }\n            // include address\n            facetAddresses_[numFacets] = facetAddress_;\n            numFacets++;\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet address that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds.facetAddressAndSelectorPosition[_functionSelector].facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/facets/FeeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IFee.sol\";\nimport \"../storage/RoleAccessControl.sol\";\nimport \"../process/FeeQueryProcess.sol\";\nimport \"../process/FeeRewardsProcess.sol\";\nimport \"../process/ClaimRewardsProcess.sol\";\nimport \"../process/OracleProcess.sol\";\nimport \"../process/GasProcess.sol\";\n\ncontract FeeFacet is IFee {\n    function distributeFeeRewards(uint256 interval, OracleProcess.OracleParam[] calldata oracles) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        OracleProcess.setOraclePrice(oracles);\n        FeeRewardsProcess.distributeFeeRewards(interval);\n        OracleProcess.clearOraclePrice();\n        GasProcess.addLossExecutionFee(startGas);\n    }\n\n    function createClaimRewards(address claimUsdToken, uint256 executionFee) external payable override {\n        ClaimRewardsProcess.createClaimRewards(msg.sender, claimUsdToken, executionFee);\n    }\n\n    function executeClaimRewards(uint256 requestId, OracleProcess.OracleParam[] calldata oracles) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        ClaimRewards.Request memory request = ClaimRewards.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.ClaimRewardsRequestNotExists();\n        }\n        OracleProcess.setOraclePrice(oracles);\n        ClaimRewardsProcess.claimRewards(requestId, request);\n        OracleProcess.clearOraclePrice();\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                IVault(address(this)).getPortfolioVaultAddress(),\n                request.executionFee,\n                startGas,\n                msg.sender,\n                request.account\n            )\n        );\n    }\n\n    function cancelClaimRewards(uint256 requestId, bytes32 reasonCode) external {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        ClaimRewards.Request memory request = ClaimRewards.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.ClaimRewardsRequestNotExists();\n        }\n        ClaimRewardsProcess.cancelClaimRewards(requestId, request, reasonCode);\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                IVault(address(this)).getPortfolioVaultAddress(),\n                request.executionFee,\n                startGas,\n                msg.sender,\n                request.account\n            )\n        );\n    }\n\n    function getPoolTokenFee(address stakeToken, address token) external view override returns (uint256) {\n        return FeeQueryProcess.getPoolTokenFeeAmount(stakeToken, token);\n    }\n\n    function getCumulativeRewardsPerStakeToken(address stakeToken) external view override returns (uint256) {\n        return FeeQueryProcess.getCumulativeRewardsPerStakeToken(stakeToken);\n    }\n\n    function getMarketTokenFee(bytes32 symbol, address token) external view override returns (uint256) {\n        return FeeQueryProcess.getMarketTokenFeeAmount(symbol, token);\n    }\n\n    function getStakingTokenFee(address stakeToken, address token) external view override returns (uint256) {\n        return FeeQueryProcess.getStakingTokenFee(stakeToken, token);\n    }\n\n    function getDaoTokenFee(address stakeToken, address token) external view override returns (uint256) {\n        return FeeQueryProcess.getDaoTokenFee(stakeToken, token);\n    }\n\n    function getAccountFeeRewards() external view override returns (AccountFeeRewards[] memory) {\n        return FeeQueryProcess.getAccountFeeRewards(msg.sender);\n    }\n\n    function getAccountsFeeRewards(\n        address[] calldata accounts\n    ) external view override returns (AccountFeeRewards[][] memory) {\n        AccountFeeRewards[][] memory result = new AccountFeeRewards[][](accounts.length);\n        for (uint256 i; i < accounts.length; i++) {\n            result[i] = FeeQueryProcess.getAccountFeeRewards(accounts[i]);\n        }\n        return result;\n    }\n\n}\n"
    },
    "contracts/facets/LiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/ILiquidation.sol\";\nimport \"../process/LiquidationProcess.sol\";\nimport \"../process/GasProcess.sol\";\nimport \"../storage/InsuranceFund.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract LiquidationFacet is ILiquidation {\n    using InsuranceFund for InsuranceFund.Props;\n\n    function liquidationPosition(bytes32 positionKey, OracleProcess.OracleParam[] calldata oracles) external override {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        uint256 startGas = gasleft();\n        OracleProcess.setOraclePrice(oracles);\n        LiquidationProcess.liquidationIsolatePosition(positionKey);\n        OracleProcess.clearOraclePrice();\n        GasProcess.addLossExecutionFee(startGas);\n    }\n\n    function liquidationAccount(address account, OracleProcess.OracleParam[] calldata oracles) external override {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        uint256 startGas = gasleft();\n        OracleProcess.setOraclePrice(oracles);\n        LiquidationProcess.liquidationCrossPositions(account);\n        OracleProcess.clearOraclePrice();\n        GasProcess.addLossExecutionFee(startGas);\n    }\n\n    function getInsuranceFunds(address stakeToken, address token) external view override returns (uint256) {\n        return InsuranceFund.load(stakeToken).getTokenFee(token);\n    }\n\n    function getAllCleanInfos() external view override returns (LiabilityClean.LiabilityCleanInfo[] memory) {\n        return LiabilityClean.getAllCleanInfo();\n    }\n}\n"
    },
    "contracts/facets/MarketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../process/MarketQueryProcess.sol\";\nimport \"../process/ConfigProcess.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../storage/UuidCreator.sol\";\n\ncontract MarketFacet is IMarket {\n    function getAllSymbols() external view override returns (SymbolInfo[] memory) {\n        bytes32[] memory symbols = CommonData.getAllSymbols();\n        SymbolInfo[] memory infos = new SymbolInfo[](symbols.length);\n        for (uint256 i; i < symbols.length; i++) {\n            infos[i] = _getSingleSymbol(symbols[i]);\n        }\n        return infos;\n    }\n\n    function getSymbol(bytes32 code) external view override returns (SymbolInfo memory params) {\n        return _getSingleSymbol(code);\n    }\n\n    function getStakeUsdToken() external view override returns (address) {\n        return CommonData.getStakeUsdToken();\n    }\n\n    function getMarketInfo(\n        bytes32 code,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external view override returns (MarketInfo memory) {\n        return MarketQueryProcess.getMarketInfo(code, oracles);\n    }\n\n    function getLastUuid(bytes32 key) external view override returns (uint256) {\n        return UuidCreator.getId(key);\n    }\n\n    function _getSingleSymbol(bytes32 code) internal view returns (SymbolInfo memory params) {\n        Symbol.Props storage props = Symbol.load(code);\n        if (props.stakeToken != address(0)) {\n            params.code = props.code;\n            params.status = props.status;\n            params.stakeToken = props.stakeToken;\n            params.indexToken = props.indexToken;\n            params.baseToken = props.baseToken;\n            params.config = ConfigProcess.getSymbolConfig(code).config;\n        }\n    }\n}\n"
    },
    "contracts/facets/MarketManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IMarketManager.sol\";\nimport \"../process/MarketFactoryProcess.sol\";\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/RoleAccessControl.sol\";\nimport \"../utils/AddressUtils.sol\";\nimport \"../utils/TypeUtils.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MarketManagerFacet is IMarketManager, ReentrancyGuard {\n    function createMarket(MarketFactoryProcess.CreateMarketParams calldata params) external override nonReentrant {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_CONFIG);\n        TypeUtils.validBytes32Empty(params.code);\n        TypeUtils.validStringEmpty(params.stakeTokenName);\n        AddressUtils.validEmpty(params.indexToken);\n        AddressUtils.validEmpty(params.baseToken);\n        MarketFactoryProcess.createMarket(params);\n    }\n\n    function createStakeUsdPool(string calldata stakeTokenName) external override nonReentrant returns (address) {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_CONFIG);\n        TypeUtils.validStringEmpty(stakeTokenName);\n        return MarketFactoryProcess.createStakeUsdPool(stakeTokenName);\n    }\n}\n"
    },
    "contracts/facets/OracleFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IOracle.sol\";\n\ncontract OracleFacet is IOracle {\n    function getLatestUsdPrice(address token, bool min) external view returns (int256) {\n        return OracleProcess.getLatestUsdPrice(token, min);\n    }\n\n    function setOraclePrices(OracleProcess.OracleParam[] calldata params) external {\n        OracleProcess.setOraclePrice(params);\n    }\n}\n"
    },
    "contracts/facets/OrderFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/IOrder.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../process/AssetsProcess.sol\";\nimport \"../process/OrderProcess.sol\";\nimport \"../process/CancelOrderProcess.sol\";\nimport \"../process/GasProcess.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/Order.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract OrderFacet is IOrder, ReentrancyGuard {\n    using SafeCast for uint256;\n    using Account for Account.Props;\n    using Order for Order.Props;\n    using Config for Config.Props;\n\n    function createOrderRequest(PlaceOrderParams calldata params) external payable override nonReentrant {\n        address account = msg.sender;\n        if (params.posSide == Order.PositionSide.INCREASE && !params.isCrossMargin) {\n            require(!params.isNativeToken || msg.value == params.orderMargin, \"Deposit native token amount error!\");\n            AssetsProcess.depositToVault(\n                AssetsProcess.DepositParams(\n                    account,\n                    params.marginToken,\n                    params.orderMargin,\n                    AssetsProcess.DepositFrom.ORDER,\n                    params.isNativeToken\n                )\n            );\n        }\n        Account.Props storage accountProps = Account.loadOrCreate(account);\n        OrderProcess.createOrderRequest(accountProps, params, true);\n    }\n\n    function batchCreateOrderRequest(PlaceOrderParams[] calldata params) external payable {\n        address account = msg.sender;\n        Account.Props storage accountProps = Account.loadOrCreate(account);\n        uint256 totalExecutionFee;\n        Config.ChainConfig memory chainConfig = Config.getChainConfig();\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].posSide == Order.PositionSide.INCREASE) {\n                revert Errors.OnlyDecreaseOrderSupported();\n            }\n            GasProcess.validateExecutionFeeLimit(params[i].executionFee, chainConfig.placeDecreaseOrderGasFeeLimit);\n            OrderProcess.createOrderRequest(accountProps, params[i], false);\n            totalExecutionFee += params[i].executionFee;\n        }\n        require(msg.value == totalExecutionFee, \"Batch place order with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                accountProps.owner,\n                chainConfig.wrapperToken,\n                totalExecutionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n    }\n\n    function executeOrder(uint256 orderId, OracleProcess.OracleParam[] calldata oracles) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        Order.OrderInfo memory order = Order.get(orderId);\n        if (order.account == address(0)) {\n            revert Errors.OrderNotExists(orderId);\n        }\n        OracleProcess.setOraclePrice(oracles);\n        OrderProcess.executeOrder(orderId, order);\n        OracleProcess.clearOraclePrice();\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                order.isExecutionFeeFromTradeVault\n                    ? IVault(address(this)).getTradeVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                order.executionFee,\n                startGas,\n                msg.sender,\n                order.account\n            )\n        );\n    }\n\n    function cancelOrder(uint256 orderId, bytes32 reasonCode) external override {\n        uint256 startGas = gasleft();\n        Order.OrderInfo memory order = Order.get(orderId);\n        if (order.account == address(0)) {\n            revert Errors.OrderNotExists(orderId);\n        }\n        bool isKeeper = RoleAccessControl.hasRole(RoleAccessControl.ROLE_KEEPER);\n        if (!isKeeper && order.account != msg.sender) {\n            revert Errors.OrderNotExists(orderId);\n        }\n\n        CancelOrderProcess.cancelOrder(orderId, order, reasonCode);\n        \n        if (isKeeper) {\n            GasProcess.processExecutionFee(\n                GasProcess.PayExecutionFeeParams(\n                    order.isExecutionFeeFromTradeVault\n                        ? IVault(address(this)).getTradeVaultAddress()\n                        : IVault(address(this)).getPortfolioVaultAddress(),\n                    order.executionFee,\n                    startGas,\n                    msg.sender,\n                    order.account\n                )\n            );\n        } else {\n            VaultProcess.transferOut(\n                order.isExecutionFeeFromTradeVault\n                    ? IVault(address(this)).getTradeVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                Config.getWrapperToken(),\n                address(this),\n                order.executionFee\n            );\n            VaultProcess.withdrawEther(order.account, order.executionFee);\n        }\n    }\n\n    receive() external payable {}\n\n    function getAccountOrders(address account) external view override returns (AccountOrder[] memory) {\n        Account.Props storage accountProps = Account.load(account);\n        uint256[] memory orders = accountProps.getOrders();\n        AccountOrder[] memory orderList = new AccountOrder[](orders.length);\n        Order.Props storage orderStorage = Order.load();\n        for (uint256 i; i < orders.length; i++) {\n            orderList[i].orderId = orders[i];\n            orderList[i].orderInfo = orderStorage.get(orders[i]);\n        }\n        return orderList;\n    }\n}\n"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { LibDiamond } from \"../storage/LibDiamond.sol\";\n\ncontract OwnershipFacet {\n    function transferOwnership(address _newOwner) external {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/facets/PoolFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../process/LpPoolQueryProcess.sol\";\n\ncontract PoolFacet is IPool, ReentrancyGuard {\n\n    function getUsdPool() external view override returns (UsdPoolInfo memory) {\n        return LpPoolQueryProcess.getUsdPool();\n    }\n\n    function getUsdPoolWithOracle(\n        OracleProcess.OracleParam[] calldata oracles\n    ) external view override returns (UsdPoolInfo memory) {\n        return LpPoolQueryProcess.getUsdPoolWithOracle(oracles);\n    }\n\n    function getPool(address stakeToken) external view override returns (PoolInfo memory) {\n        OracleProcess.OracleParam[] memory oracles;\n        return LpPoolQueryProcess.getPool(stakeToken, oracles);\n    }\n\n    function getPoolWithOracle(\n        address stakeToken,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external view override returns (PoolInfo memory) {\n        return LpPoolQueryProcess.getPool(stakeToken, oracles);\n    }\n\n    function getAllPools(\n        OracleProcess.OracleParam[] calldata oracles\n    ) external view override returns (PoolInfo[] memory) {\n        return LpPoolQueryProcess.getAllPools(oracles);\n    }\n\n}\n"
    },
    "contracts/facets/PositionFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../process/AssetsProcess.sol\";\nimport \"../process/DecreasePositionProcess.sol\";\nimport \"../process/PositionMarginProcess.sol\";\nimport \"../process/GasProcess.sol\";\nimport \"../process/ConfigProcess.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../storage/RoleAccessControl.sol\";\nimport \"../utils/ChainUtils.sol\";\n\ncontract PositionFacet is IPosition, ReentrancyGuard {\n    using Account for Account.Props;\n    using PositionQueryProcess for Position.Props;\n    using DecreasePositionProcess for Position.Props;\n    using Position for Position.Props;\n\n    bytes32 constant AUTO_REDUCE_ID_KEY = keccak256(\"AUTO_REDUCE_ID_KEY\");\n\n    function createUpdatePositionMarginRequest(UpdatePositionMarginParams calldata params) external payable override {\n        if (params.updateMarginAmount == 0) {\n            revert Errors.AmountZeroNotAllowed();\n        }\n        address account = msg.sender;\n        Account.Props storage accountProps = Account.load(account);\n        if (!accountProps.hasPosition(params.positionKey)) {\n            revert Errors.PositionNotExists();\n        }\n        Position.Props storage position = Position.load(params.positionKey);\n        if (position.isCrossMargin) {\n            revert Errors.OnlyIsolateSupported();\n        }\n        if (params.isAdd) {\n            require(!params.isNativeToken || msg.value == params.updateMarginAmount, \"Deposit eth amount error!\");\n            AssetsProcess.depositToVault(\n                AssetsProcess.DepositParams(\n                    account,\n                    params.isNativeToken ? Config.getWrapperToken() : params.marginToken,\n                    params.updateMarginAmount,\n                    AssetsProcess.DepositFrom.ORDER,\n                    params.isNativeToken\n                )\n            );\n        }\n\n        (uint256 updateMarginAmount, bool isExecutionFeeFromTradeVault) = _validateUpdateMarginExecutionFee(\n            accountProps,\n            params\n        );\n\n        PositionMarginProcess.createUpdatePositionMarginRequest(\n            account,\n            params,\n            updateMarginAmount,\n            isExecutionFeeFromTradeVault\n        );\n    }\n\n    function executeUpdatePositionMarginRequest(\n        uint256 requestId,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        UpdatePositionMargin.Request memory request = UpdatePositionMargin.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.UpdateLeverageRequestNotExists();\n        }\n        OracleProcess.setOraclePrice(oracles);\n        PositionMarginProcess.updatePositionMargin(requestId, request);\n        OracleProcess.clearOraclePrice();\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                request.isExecutionFeeFromTradeVault\n                    ? IVault(address(this)).getTradeVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                request.executionFee,\n                startGas,\n                msg.sender,\n                request.account\n            )\n        );\n    }\n\n    function cancelUpdatePositionMarginRequest(uint256 requestId, bytes32 reasonCode) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        UpdatePositionMargin.Request memory request = UpdatePositionMargin.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.UpdatePositionMarginRequestNotExists();\n        }\n        PositionMarginProcess.cancelUpdatePositionMarginRequest(requestId, request, reasonCode);\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                request.isExecutionFeeFromTradeVault\n                    ? IVault(address(this)).getTradeVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                request.executionFee,\n                startGas,\n                msg.sender,\n                request.account\n            )\n        );\n    }\n\n    function createUpdateLeverageRequest(UpdateLeverageParams calldata params) external payable override {\n        IConfig.SymbolConfigParams memory symbolConfig = ConfigProcess.getSymbolConfig(params.symbol);\n        Symbol.Props memory symbolProps = Symbol.load(params.symbol);\n        if (symbolProps.code.length == 0) {\n            revert Errors.SymbolNotExists();\n        }\n        if (symbolProps.status != Symbol.Status.OPEN) {\n            revert Errors.SymbolStatusInvalid(params.symbol);\n        }\n        if (params.leverage > symbolConfig.config.maxLeverage || params.leverage < 1 * CalUtils.RATE_PRECISION) {\n            revert Errors.LeverageInvalid(params.symbol, params.leverage);\n        }\n        address account = msg.sender;\n        Account.Props storage accountProps = Account.load(account);\n\n        if (params.addMarginAmount > 0 && !params.isCrossMargin) {\n            require(!params.isNativeToken || msg.value == params.addMarginAmount, \"Deposit eth amount error!\");\n            AssetsProcess.depositToVault(\n                AssetsProcess.DepositParams(\n                    account,\n                    params.isNativeToken ? Config.getWrapperToken() : params.marginToken,\n                    params.addMarginAmount,\n                    AssetsProcess.DepositFrom.ORDER,\n                    params.isNativeToken\n                )\n            );\n        }\n\n        (uint256 addMarginAmount, bool isExecutionFeeFromTradeVault) = _validateUpdateLeverageExecutionFee(\n            accountProps,\n            params\n        );\n\n        PositionMarginProcess.createUpdateLeverageRequest(\n            account,\n            params,\n            addMarginAmount,\n            isExecutionFeeFromTradeVault\n        );\n    }\n\n    function executeUpdateLeverageRequest(\n        uint256 requestId,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        UpdateLeverage.Request memory request = UpdateLeverage.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.UpdateLeverageRequestNotExists();\n        }\n        OracleProcess.setOraclePrice(oracles);\n        PositionMarginProcess.updatePositionLeverage(requestId, request);\n        OracleProcess.clearOraclePrice();\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                request.isExecutionFeeFromTradeVault\n                    ? IVault(address(this)).getTradeVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                request.executionFee,\n                startGas,\n                msg.sender,\n                request.account\n            )\n        );\n    }\n\n    function cancelUpdateLeverageRequest(uint256 requestId, bytes32 reasonCode) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        UpdateLeverage.Request memory request = UpdateLeverage.get(requestId);\n        if (request.account == address(0)) {\n            revert Errors.UpdateLeverageRequestNotExists();\n        }\n        PositionMarginProcess.cancelUpdateLeverageRequest(requestId, request, reasonCode);\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                request.isExecutionFeeFromTradeVault\n                    ? IVault(address(this)).getTradeVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                request.executionFee,\n                startGas,\n                msg.sender,\n                request.account\n            )\n        );\n    }\n\n    function autoReducePositions(bytes32[] calldata positionKeys) external override {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        uint256 requestId = UuidCreator.nextId(AUTO_REDUCE_ID_KEY);\n        for (uint256 i; i < positionKeys.length; i++) {\n            Position.Props storage position = Position.load(positionKeys[i]);\n            position.checkExists();\n            position.decreasePosition(\n                DecreasePositionProcess.DecreasePositionParams(\n                    requestId,\n                    position.symbol,\n                    false,\n                    position.isCrossMargin,\n                    position.marginToken,\n                    position.qty,\n                    OracleProcess.getLatestUsdUintPrice(position.indexToken, position.isLong)\n                )\n            );\n        }\n        GasProcess.addLossExecutionFee(startGas);\n    }\n\n    function getAllPositions(address account) external view override returns (PositionInfo[] memory) {\n        Account.Props storage accountInfo = Account.load(account);\n        bytes32[] memory positionKeys = accountInfo.getAllPosition();\n        PositionInfo[] memory positions = new PositionInfo[](positionKeys.length);\n        for (uint256 i; i < positionKeys.length; i++) {\n            Position.Props storage position = Position.load(positionKeys[i]);\n            positions[i].position = position;\n            // if (!position.isCrossMargin) {\n            //     positions[i].liquidationPrice = position.getLiquidationPrice();\n            // }\n        }\n        return positions;\n    }\n\n    function getSinglePosition(\n        address account,\n        bytes32 symbol,\n        address marginToken,\n        bool isCrossMargin\n    ) external pure override returns (Position.Props memory) {\n        return Position.load(account, symbol, marginToken, isCrossMargin);\n    }\n\n    function _validateUpdateMarginExecutionFee(\n        Account.Props storage accountProps,\n        UpdatePositionMarginParams calldata params\n    ) internal returns (uint256, bool) {\n        Config.Props storage config = Config.load();\n        GasProcess.validateExecutionFeeLimit(params.executionFee, config.chainConfig.positionUpdateMarginGasFeeLimit);\n        if (params.isNativeToken && params.isAdd && params.updateMarginAmount >= params.executionFee) {\n            return (params.updateMarginAmount - params.executionFee, true);\n        }\n        require(msg.value == params.executionFee, \"update margin with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                accountProps.owner,\n                config.chainConfig.wrapperToken,\n                params.executionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n        return (params.updateMarginAmount, false);\n    }\n\n    function _validateUpdateLeverageExecutionFee(\n        Account.Props storage accountProps,\n        UpdateLeverageParams calldata params\n    ) internal returns (uint256, bool) {\n        Config.ChainConfig memory chainConfig = Config.getChainConfig();\n        GasProcess.validateExecutionFeeLimit(params.executionFee, chainConfig.positionUpdateLeverageGasFeeLimit);\n        if (params.isNativeToken && params.addMarginAmount >= params.executionFee && !params.isCrossMargin) {\n            return (params.addMarginAmount - params.executionFee, true);\n        }\n        require(msg.value == params.executionFee, \"update leverage with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                accountProps.owner,\n                chainConfig.wrapperToken,\n                params.executionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n        return (params.addMarginAmount, false);\n    }\n}\n"
    },
    "contracts/facets/RebalanceFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IRebalance.sol\";\nimport \"../process/RebalanceProcess.sol\";\nimport \"../process/SwapProcess.sol\";\nimport \"../process/GasProcess.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract RebalanceFacet is IRebalance {\n\n    function autoRebalance(OracleProcess.OracleParam[] calldata oracles) external override {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        uint256 startGas = gasleft();\n        OracleProcess.setOraclePrice(oracles);\n        RebalanceProcess.autoRebalance();\n        OracleProcess.clearOraclePrice();\n        GasProcess.addLossExecutionFee(startGas);\n    }\n\n}\n"
    },
    "contracts/facets/RoleAccessControlFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IRoleAccessControl.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract RoleAccessControlFacet is IRoleAccessControl {\n    modifier onlyRoleAdmin() {\n        if (!RoleAccessControl.hasRole(msg.sender, RoleAccessControl.ROLE_ADMIN)) {\n            revert Errors.InvalidRoleAccess(msg.sender, RoleAccessControl.ROLE_ADMIN);\n        }\n        _;\n    }\n\n    constructor() {\n    }\n\n    function hasRole(address account, bytes32 role) external view returns (bool) {\n        return RoleAccessControl.hasRole(account, role);\n    }\n\n    function grantRole(address account, bytes32 role) external onlyRoleAdmin {\n        if (!isRoleValid(role)) {\n            revert Errors.InvalidRoleName(role);\n        } \n        RoleAccessControl.grantRole(account, role);\n    }\n\n    function revokeRole(address account, bytes32 role) external onlyRoleAdmin {\n        RoleAccessControl.revokeRole(account, role);\n    }\n\n    function revokeAllRole(address account) external onlyRoleAdmin {\n        RoleAccessControl.revokeAllRole(account);\n    }\n\n    function isRoleValid(bytes32 role) internal pure returns (bool) {\n        return\n            role == RoleAccessControl.ROLE_ADMIN ||\n            role == RoleAccessControl.ROLE_CONFIG ||\n            role == RoleAccessControl.ROLE_KEEPER;\n    }\n}\n"
    },
    "contracts/facets/StakeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IStake.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../process/MintProcess.sol\";\nimport \"../process/RedeemProcess.sol\";\nimport \"../process/AssetsProcess.sol\";\nimport \"../process/GasProcess.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../storage/RoleAccessControl.sol\";\nimport \"../utils/AddressUtils.sol\";\n\ncontract StakeFacet is IStake, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Config for Config.Props;\n    using LpPool for LpPool.Props;\n    using Account for Account.Props;\n\n    function createMintStakeTokenRequest(MintStakeTokenParams calldata params) external payable override nonReentrant {\n        if (params.requestTokenAmount == 0) {\n            revert Errors.MintWithAmountZero();\n        }\n        if (AddressUtils.isEmpty(params.receiver) || AddressUtils.isEmpty(params.stakeToken)) {\n            revert Errors.MintWithParamError();\n        }\n\n        address account = msg.sender;\n        address token = params.requestToken;\n        if (CommonData.getStakeUsdToken() == params.stakeToken) {\n            if (!UsdPool.isSupportStableToken(token)) {\n                revert Errors.MintTokenInvalid(params.stakeToken, token);\n            }\n        } else if (CommonData.isStakeTokenSupport(params.stakeToken)) {\n            LpPool.Props storage pool = LpPool.load(params.stakeToken);\n            if (\n                pool.baseToken != token &&\n                (!params.isCollateral || (params.isCollateral && !pool.isStakeCollateralSupport(token)))\n            ) {\n                revert Errors.MintTokenInvalid(params.stakeToken, token);\n            }\n        } else {\n            revert Errors.StakeTokenInvalid(params.stakeToken);\n        }\n\n        if (params.walletRequestTokenAmount > 0) {\n            require(!params.isNativeToken || msg.value == params.walletRequestTokenAmount, \"Deposit eth amount error!\");\n            AssetsProcess.depositToVault(\n                AssetsProcess.DepositParams(\n                    account,\n                    params.requestToken,\n                    params.walletRequestTokenAmount,\n                    params.isCollateral ? AssetsProcess.DepositFrom.MINT_COLLATERAL : AssetsProcess.DepositFrom.MINT,\n                    params.isNativeToken\n                )\n            );\n        }\n\n        (uint256 walletRequestTokenAmount, bool isExecutionFeeFromLpVault) = MintProcess\n            .validateAndDepositMintExecutionFee(account, params);\n        if (params.requestTokenAmount < walletRequestTokenAmount) {\n            revert Errors.MintWithParamError();\n        }\n\n        MintProcess.createMintStakeTokenRequest(\n            params,\n            account,\n            token,\n            walletRequestTokenAmount,\n            isExecutionFeeFromLpVault\n        );\n\n    }\n\n    function executeMintStakeToken(\n        uint256 requestId,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external override nonReentrant {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        Mint.Request memory mintRequest = Mint.get(requestId);\n        if (mintRequest.account == address(0)) {\n            revert Errors.MintRequestNotExists();\n        }\n        OracleProcess.setOraclePrice(oracles);\n\n        MintProcess.executeMintStakeToken(requestId, mintRequest);\n\n        OracleProcess.clearOraclePrice();\n\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                mintRequest.isExecutionFeeFromLpVault\n                    ? IVault(address(this)).getLpVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                mintRequest.executionFee,\n                startGas,\n                msg.sender,\n                mintRequest.account\n            )\n        );\n    }\n\n    function cancelMintStakeToken(uint256 requestId, bytes32 reasonCode) external {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        Mint.Request memory mintRequest = Mint.get(requestId);\n        if (mintRequest.account == address(0)) {\n            revert Errors.MintRequestNotExists();\n        }\n\n        MintProcess.cancelMintStakeToken(requestId, mintRequest, reasonCode);\n\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                mintRequest.isExecutionFeeFromLpVault\n                    ? IVault(address(this)).getLpVaultAddress()\n                    : IVault(address(this)).getPortfolioVaultAddress(),\n                mintRequest.executionFee,\n                startGas,\n                msg.sender,\n                mintRequest.account\n            )\n        );\n    }\n\n    function createRedeemStakeTokenRequest(\n        RedeemStakeTokenParams calldata params\n    ) external payable override nonReentrant {\n        require(params.unStakeAmount > 0, \"unStakeAmount == 0\");\n        AddressUtils.validEmpty(params.receiver);\n\n        address account = msg.sender;\n        uint256 stakeTokenAmount = StakeToken(params.stakeToken).balanceOf(account);\n        if (stakeTokenAmount == 0) {\n            revert Errors.RedeemWithAmountNotEnough(account, params.stakeToken);\n        }\n        if (stakeTokenAmount < params.unStakeAmount) {\n            revert Errors.RedeemWithAmountNotEnough(account, params.stakeToken);\n        }\n        if (CommonData.getStakeUsdToken() == params.stakeToken) {\n            if (!UsdPool.isSupportStableToken(params.redeemToken)) {\n                revert Errors.RedeemTokenInvalid(params.stakeToken, params.redeemToken);\n            }\n        } else if (CommonData.isStakeTokenSupport(params.stakeToken)) {\n            LpPool.Props storage pool = LpPool.load(params.stakeToken);\n            if (pool.baseToken != params.redeemToken) {\n                revert Errors.RedeemTokenInvalid(params.stakeToken, params.redeemToken);\n            }\n        } else {\n            revert Errors.StakeTokenInvalid(params.stakeToken);\n        }\n\n        RedeemProcess.validateAndDepositRedeemExecutionFee(account, params.executionFee);\n        RedeemProcess.createRedeemStakeTokenRequest(params, account, params.unStakeAmount);\n    }\n\n    function executeRedeemStakeToken(\n        uint256 requestId,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external override nonReentrant {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        OracleProcess.setOraclePrice(oracles);\n        Redeem.Request memory request = Redeem.get(requestId);\n        if (request.receiver == address(0)) {\n            revert Errors.RedeemRequestNotExists();\n        }\n        RedeemProcess.executeRedeemStakeToken(requestId, request);\n\n        OracleProcess.clearOraclePrice();\n\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                IVault(address(this)).getPortfolioVaultAddress(),\n                request.executionFee,\n                startGas,\n                msg.sender,\n                request.account\n            )\n        );\n    }\n\n    function cancelRedeemStakeToken(uint256 requestId, bytes32 reasonCode) external {\n        uint256 startGas = gasleft();\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        Redeem.Request memory redeemRequest = Redeem.get(requestId);\n        if (redeemRequest.receiver == address(0)) {\n            revert Errors.RedeemRequestNotExists();\n        }\n\n        RedeemProcess.cancelRedeemStakeToken(requestId, redeemRequest, reasonCode);\n\n        GasProcess.processExecutionFee(\n            GasProcess.PayExecutionFeeParams(\n                IVault(address(this)).getPortfolioVaultAddress(),\n                redeemRequest.executionFee,\n                startGas,\n                msg.sender,\n                redeemRequest.account\n            )\n        );\n    }\n}\n"
    },
    "contracts/facets/StakingAccountFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IStakingAccount.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../storage/CommonData.sol\";\n\ncontract StakingAccountFacet is IStakingAccount {\n    using StakingAccount for StakingAccount.Props;\n\n    function getAccountPoolBalance(\n        address account,\n        address stakeToken\n    ) external view override returns (TokenBalance memory) {\n        StakingAccount.Props storage stakingAccount = StakingAccount.load(account);\n        address[] memory tokens = stakingAccount.getCollateralTokens(stakeToken);\n        uint256[] memory amounts = new uint256[](tokens.length);\n        uint256[] memory liabilities = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            StakingAccount.CollateralData memory data = stakingAccount.getCollateralToken(stakeToken, tokens[i]);\n            amounts[i] = data.amount;\n            liabilities[i] = data.stakeLiability;\n        }\n\n        return TokenBalance(stakingAccount.stakeTokenBalances[stakeToken].stakeAmount, tokens, amounts, liabilities);\n    }\n\n    function getAccountPoolCollateralAmount(\n        address account,\n        address stakeToken,\n        address collateral\n    ) external view override returns (uint256) {\n        return StakingAccount.load(account).getCollateralToken(stakeToken, collateral).amount;\n    }\n\n    function getAccountUsdPoolAmount(address account) external view override returns (uint256) {\n        return StakingAccount.load(account).stakeUsdAmount;\n    }\n}\n"
    },
    "contracts/facets/SwapFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../process/SwapProcess.sol\";\nimport \"../process/AssetsProcess.sol\";\nimport \"../storage/RoleAccessControl.sol\";\n\ncontract SwapFacet is ISwap {\n    using SafeCast for uint256;\n    using Account for Account.Props;\n\n    function swapPortfolioToPayLiability(\n        address[] calldata accounts,\n        address[][] calldata accountTokens\n    ) external override {\n        RoleAccessControl.checkRole(RoleAccessControl.ROLE_KEEPER);\n        for (uint256 i; i < accounts.length; i++) {\n            Account.Props storage accountProps = Account.load(accounts[i]);\n            accountProps.checkExists();\n            for (uint256 j; j < accountTokens[i].length; j++) {\n                _swapSingleLiability(accountProps, accountTokens[i][j]);\n            }\n        }\n    }\n\n    function _swapSingleLiability(Account.Props storage accountProps, address token) internal returns(SwapResult memory) {\n        uint256 liability = accountProps.getTokenBalance(token).liability;\n        if (liability <= 0) {\n            revert Errors.IgnoreSwapWithAccountLiabilityZero();\n        }\n        address[] memory tokens = accountProps.getSortedTokensByDiscount();\n        uint256[] memory amounts = new uint256[](tokens.length);\n        uint256[] memory minToAmounts = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            amounts[i] = accountProps.getAvailableTokenAmount(tokens[i]);\n        }\n        address portfolioVaultAddress = IVault(address(this)).getPortfolioVaultAddress();\n        return\n            _swapUserTokens(\n                accountProps.owner,\n                SwapParams(\n                    portfolioVaultAddress,\n                    tokens,\n                    amounts,\n                    minToAmounts,\n                    token,\n                    portfolioVaultAddress,\n                    liability\n                )\n            );\n    }\n\n    function _swapUserTokens(address account, SwapParams memory params) internal returns (SwapResult memory) {\n        SwapResult memory swapResult = SwapProcess.swap(params);\n        AssetsProcess.UpdateAccountTokenParams memory updateAccountParams;\n        updateAccountParams.account = account;\n        updateAccountParams.tokens = new address[](swapResult.fromTokens.length + 1);\n        updateAccountParams.changedTokenAmounts = new int256[](swapResult.fromTokens.length + 1);\n        for (uint256 i; i < swapResult.fromTokens.length; i++) {\n            updateAccountParams.tokens[i] = swapResult.fromTokens[i];\n            updateAccountParams.changedTokenAmounts[i] = -(swapResult.reduceFromAmounts[i].toInt256());\n        }\n        updateAccountParams.tokens[swapResult.fromTokens.length] = swapResult.toToken;\n        updateAccountParams.changedTokenAmounts[swapResult.fromTokens.length] = swapResult.toTokenAmount.toInt256();\n        AssetsProcess.updateAccountToken(updateAccountParams);\n        return swapResult;\n    }\n}\n"
    },
    "contracts/facets/VaultFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IVault.sol\";\nimport \"../vault/TradeVault.sol\";\nimport \"../vault/LpVault.sol\";\nimport \"../vault/PortfolioVault.sol\";\n\ncontract VaultFacet is IVault {\n    TradeVault private immutable tradeVault;\n    LpVault private immutable lpVault;\n    PortfolioVault private immutable portfolioVault;\n\n    constructor(TradeVault _tradeVault, LpVault _lpVault, PortfolioVault _portfolioVault) {\n        tradeVault = _tradeVault;\n        lpVault = _lpVault;\n        portfolioVault = _portfolioVault;\n    }\n\n    function getTradeVault() external view override returns (TradeVault) {\n        return tradeVault;\n    }\n\n    function getLpVault() external view override returns (LpVault) {\n        return lpVault;\n    }\n\n    function getPortfolioVault() external view override returns (PortfolioVault) {\n        return portfolioVault;\n    }\n\n    function getTradeVaultAddress() external view override returns (address) {\n        return address(tradeVault);\n    }\n\n    function getLpVaultAddress() external view override returns (address) {\n        return address(lpVault);\n    }\n\n    function getPortfolioVaultAddress() external view override returns (address) {\n        return address(portfolioVault);\n    }\n}\n"
    },
    "contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/AssetsProcess.sol\";\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/Withdraw.sol\";\nimport \"../storage/Account.sol\";\n\ninterface IAccount {\n\n    struct AccountInfo {\n        address owner;\n        Account.TokenBalance[] tokenBalances;\n        address[] tokens;\n        bytes32[] positions;\n        uint256 portfolioNetValue;\n        uint256 totalUsedValue;\n        int256 availableValue;\n        uint256 orderHoldInUsd;\n        int256 crossMMR;\n        int256 crossNetValue;\n        uint256 totalMM;\n    }\n\n    function deposit(address token, uint256 amount) external payable;\n\n    function createWithdrawRequest(address token, uint256 amount) external;\n\n    function executeWithdraw(uint256 requestId, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function cancelWithdraw(uint256 requestId, bytes32 reasonCode) external;\n    \n    function batchUpdateAccountToken(AssetsProcess.UpdateAccountTokenParams calldata params) external;\n\n    function getAccountInfo(address account) external view returns (AccountInfo memory);\n\n    function getAccountInfoWithOracles(address account, OracleProcess.OracleParam[] calldata oracles) external view returns (AccountInfo memory);\n}\n"
    },
    "contracts/interfaces/IAutoReduce.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/LiabilityClean.sol\";\n\ninterface IAutoReduce {\n    function autoReduce(\n        bytes32[] calldata positionKeys,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external;\n\n    function autoRedeem(\n        address stakeToken,\n        address[] calldata account,\n        address collateral,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external;\n}\n"
    },
    "contracts/interfaces/IConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../storage/Config.sol\";\n\ninterface IConfig {\n    struct CommonConfigParams {\n        address wrapperToken;\n        uint256 mintGasFeeLimit;\n        uint256 redeemGasFeeLimit;\n        uint256 placeIncreaseOrderGasFeeLimit;\n        uint256 placeDecreaseOrderGasFeeLimit;\n        uint256 positionUpdateMarginGasFeeLimit;\n        uint256 positionUpdateLeverageGasFeeLimit;\n        uint256 claimRewardsGasFeeLimit;\n        address[] tradeTokens;\n        Config.TradeTokenConfig[] tradeTokenConfigs;\n        uint256 minOrderMarginUSD;\n        uint256 availableCollateralRatio;\n        uint256 crossLtvLimit;\n        uint256 executeOrderMinBlockGap;\n        uint256 executeOrderMaxBlockGap;\n        uint256 executePositionMarginMinBlockGap;\n        uint256 executePositionMarginMaxBlockGap;\n        uint256 executeLeverageMinBlockGap;\n        uint256 executeLeverageMaxBlockGap;\n        uint256 maxMaintenanceMarginRate;\n        uint256 fundingFeeBaseRate;\n        uint256 tradingFeeStakingRewardsRatio;\n        uint256 tradingFeePoolRewardsRatio;\n        uint256 tradingFeeUsdPoolRewardsRatio;\n        uint256 borrowingFeeStakingRewardsRatio;\n        uint256 borrowingFeePoolRewardsRatio;\n        uint256 autoReduceProfitFactor;\n        uint256 autoReduceLiquidityFactor;\n        uint256 swapSlipperTokenFactor;\n        uint256 minPrecisionMultiple;\n        uint256 stakeCollateralProtectFactor;\n        uint256 stakeCollateralFactor;\n        uint256 mintFeeStakingRewardsRatio;\n        uint256 mintFeePoolRewardsRatio;\n        uint256 redeemFeeStakingRewardsRatio;\n        uint256 redeemFeePoolRewardsRatio;\n        address uniswapRouter;\n        uint256 poolRewardsIntervalLimit;\n    }\n\n    struct LpPoolConfigParams {\n        address stakeToken;\n        uint256 baseInterestRate;\n        uint256 poolLiquidityLimit;\n        uint256 mintFeeRate;\n        uint256 redeemFeeRate;\n        uint256 poolPnlRatioLimit;\n        uint256 collateralStakingRatioLimit;\n        uint256 unsettledBaseTokenRatioLimit;\n        uint256 unsettledStableTokenRatioLimit;\n        uint256 poolStableTokenRatioLimit;\n        uint256 poolStableTokenLossLimit;\n        address[] assetTokens;\n        address[] supportCollateralTokens;\n        Config.StakeCollateralConfig[] collateralTokensConfigs;\n    }\n\n    struct UsdPoolConfigParams {\n        uint256 poolLiquidityLimit;\n        uint256 mintFeeRate;\n        uint256 redeemFeeRate;\n        uint256 unsettledRatioLimit;\n        address[] supportStableTokens;\n        uint256[] stableTokensBorrowingInterestRate;\n        uint256[] stableTokensRatioLimit;\n    }\n\n    struct SymbolConfigParams {\n        bytes32 symbol;\n        Config.SymbolConfig config;\n    }\n}\n"
    },
    "contracts/interfaces/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamond {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamond } from \"./IDiamond.sol\";\n\ninterface IDiamondCut is IDiamond {    \n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;    \n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/IFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\nimport \"../process/FeeQueryProcess.sol\";\n\ninterface IFee {\n\n    struct AccountFeeRewards {\n        address stakeToken;\n        address token;\n        uint256 rewards;\n    }\n\n    function distributeFeeRewards(uint256 interval, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function createClaimRewards(address claimUsdToken, uint256 executionFee) external payable;\n\n    function executeClaimRewards(uint256 requestId, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function getPoolTokenFee(address stakeToken, address token) external view returns (uint256);\n\n    function getCumulativeRewardsPerStakeToken(address stakeToken) external view returns (uint256);\n\n    function getMarketTokenFee(bytes32 symbol, address token) external view returns (uint256);\n\n    function getStakingTokenFee(address stakeToken, address token) external view returns (uint256);\n\n    function getDaoTokenFee(address stakeToken, address token) external view returns (uint256);\n\n    function getAccountFeeRewards() external view returns (AccountFeeRewards[] memory);\n\n    function getAccountsFeeRewards(address[] calldata accounts) external view returns (AccountFeeRewards[][] memory);\n}\n"
    },
    "contracts/interfaces/ILiquidation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/LiabilityClean.sol\";\n\ninterface ILiquidation {\n    function liquidationPosition(bytes32 positionKey, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function liquidationAccount(address account, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function getInsuranceFunds(address stakeToken, address token) external view returns (uint256);\n\n    function getAllCleanInfos() external view returns (LiabilityClean.LiabilityCleanInfo[] memory);\n}\n"
    },
    "contracts/interfaces/IMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/MarketQueryProcess.sol\";\nimport \"../interfaces/IConfig.sol\";\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/Market.sol\";\n\ninterface IMarket {\n\n    struct SymbolInfo {\n        bytes32 code;\n        Symbol.Status status;\n        address stakeToken;\n        address indexToken;\n        address baseToken;\n        Config.SymbolConfig config;\n    }\n\n    struct MarketInfo {\n        Symbol.Props symbolInfo;\n        uint256 longPositionInterest;\n        uint256 longPositionEntryPrice;\n        uint256 totalShortPositionInterest;\n        Market.MarketPosition[] shortPositions;\n        uint256 availableLiquidity;\n        Market.FundingFee fundingFee;\n    }\n    \n    function getAllSymbols() external view returns (SymbolInfo[] memory);\n\n    function getSymbol(bytes32 code) external view returns (SymbolInfo memory);\n\n    function getStakeUsdToken() external view returns (address);\n\n    function getMarketInfo(bytes32 code, OracleProcess.OracleParam[] calldata oracles) external view returns (MarketInfo memory);\n\n    function getLastUuid(bytes32 key) external view returns(uint256);\n}\n"
    },
    "contracts/interfaces/IMarketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/MarketFactoryProcess.sol\";\nimport \"../process/ConfigProcess.sol\";\nimport \"../interfaces/IConfig.sol\";\n\ninterface IMarketManager {\n    function createMarket(MarketFactoryProcess.CreateMarketParams calldata params) external;\n\n    function createStakeUsdPool(string calldata stakeTokenName) external returns (address);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\n\ninterface IOracle {\n    \n  function getLatestUsdPrice(address token, bool min) external view returns (int256);\n\n  function setOraclePrices(OracleProcess.OracleParam[] calldata params) external;\n}\n"
    },
    "contracts/interfaces/IOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OrderProcess.sol\";\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/Order.sol\";\n\ninterface IOrder {\n    struct PlaceOrderParams {\n        bytes32 symbol;\n        bool isCrossMargin;\n        bool isNativeToken;\n        Order.Side orderSide;\n        Order.PositionSide posSide;\n        Order.Type orderType;\n        Order.StopType stopType;\n        address marginToken;\n        uint256 qty; // decrease only\n        uint256 orderMargin; // increase only\n        uint256 leverage;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 placeTime;\n    }\n\n    struct AccountOrder {\n        uint256 orderId;\n        Order.OrderInfo orderInfo;\n    }\n\n    function createOrderRequest(PlaceOrderParams calldata params) external payable;\n\n    function batchCreateOrderRequest(PlaceOrderParams[] calldata params) external payable;\n\n    function executeOrder(uint256 orderId, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function cancelOrder(uint256 orderId, bytes32 reasonCode) external;\n\n    function getAccountOrders(address account) external view returns (AccountOrder[] memory);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Mint.sol\";\nimport \"../storage/Redeem.sol\";\n\ninterface IPool {\n\n    struct PoolInfo {\n        address stakeToken;\n        string stakeTokenName;\n        address baseToken;\n        bytes32 symbol;\n        MintTokenBalance baseTokenBalance;\n        address[] stableTokens;\n        MintTokenBalance[] stableTokenBalances;\n        uint256 poolValue;\n        uint256 availableLiquidity;\n        int256 poolPnl;\n        uint256 totalSupply;\n        LpPool.BorrowingFee borrowingFee;\n        uint256 apr;\n    }\n\n    struct MintTokenBalance {\n        uint256 amount;\n        uint256 liability;\n        uint256 holdAmount;\n        int256 unsettledAmount;\n        uint256 lossAmount;\n        address[] collateralTokens;\n        uint256[] collateralAmounts;\n    }\n\n    struct UsdPoolInfo {\n        address[] stableTokens;\n        UsdPool.TokenBalance[] stableTokenBalances;\n        uint256[] stableTokenMaxWithdraws;\n        uint256 poolValue;\n        uint256 totalSupply;\n        uint256[] tokensAvailableLiquidity;\n        UsdPool.BorrowingFee[] borrowingFees;\n        uint256 apr;\n    }\n\n    function getPool(address stakeToken) external view returns (PoolInfo memory);\n\n    function getUsdPool() external view returns (UsdPoolInfo memory);\n\n    function getPoolWithOracle(address stakeToken, OracleProcess.OracleParam[] calldata oracles) external view returns (PoolInfo memory);\n\n    function getUsdPoolWithOracle(OracleProcess.OracleParam[] calldata oracles) external view returns (UsdPoolInfo memory);\n\n    function getAllPools(OracleProcess.OracleParam[] calldata oracles) external view returns (PoolInfo[] memory);\n}\n"
    },
    "contracts/interfaces/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/UpdatePositionMargin.sol\";\nimport \"../storage/UpdateLeverage.sol\";\n\ninterface IPosition {\n\n    struct UpdatePositionMarginParams {\n        bytes32 positionKey;\n        bool isAdd;\n        bool isNativeToken;\n        address marginToken;\n        uint256 updateMarginAmount;\n        uint256 executionFee;\n    }\n\n    struct UpdateLeverageParams {\n        bytes32 symbol;\n        bool isLong;\n        bool isNativeToken;\n        bool isCrossMargin;\n        uint256 leverage;\n        address marginToken;\n        uint256 addMarginAmount;\n        uint256 executionFee;\n    }\n\n    struct PositionInfo {\n        Position.Props position;\n        uint256 liquidationPrice;\n    }\n\n    function createUpdatePositionMarginRequest(UpdatePositionMarginParams calldata params) external payable;\n\n    function executeUpdatePositionMarginRequest(\n        uint256 requestId,\n        OracleProcess.OracleParam[] calldata oracles\n    ) external;\n\n    function cancelUpdatePositionMarginRequest(uint256 orderId, bytes32 reasonCode) external;\n\n    function createUpdateLeverageRequest(UpdateLeverageParams calldata params) external payable;\n\n    function executeUpdateLeverageRequest(uint256 requestId, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function cancelUpdateLeverageRequest(uint256 orderId, bytes32 reasonCode) external;\n\n    function autoReducePositions(bytes32[] calldata positionKeys) external;\n\n    function getAllPositions(address account) external view returns (PositionInfo[] memory);\n\n    function getSinglePosition(\n        address account,\n        bytes32 symbol,\n        address marginToken,\n        bool isCrossMargin\n    ) external pure returns (Position.Props memory);\n}\n"
    },
    "contracts/interfaces/IRebalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\n\ninterface IRebalance {\n    struct RebalancePortfolioParams {\n        address token;\n        bool isBaseToken;\n        address[] stakeTokens;\n    }\n\n    struct RebalancePortfolioToPoolParams {\n        address token;\n        bool isBaseToken;\n        uint256 rebalanceToLimitAmount;\n        address[] stakeTokens;\n        address[] autoSwapUsers;\n    }\n\n    struct TransferTokenParams {\n        address stakeToken;\n        address[] tokens;\n        uint256[] transferAmounts;\n    }\n\n    struct RebalancePoolStableTokenParams {\n        address stakeToken;\n        bool swapToBase;\n        address[] stableTokens;\n        int256[] changedStableAmount;\n        int256[] changedStableLossAmount;\n        uint256[] transferToBaseTokenAmount;\n        uint256[] transferToStableTokenAmount;\n        uint256[] usdSettleAmount;\n        uint256[] usdAddAmount;\n    }\n\n    function autoRebalance(OracleProcess.OracleParam[] calldata oracles) external;\n\n    // function rebalancePortfolio(RebalancePortfolioParams[] calldata params) external;\n\n    // function rebalancePortfolioToPool(RebalancePortfolioToPoolParams calldata params) external;\n\n    // function transferUnsettleToken(TransferTokenParams[] calldata params) external;\n\n    // function rebalancePoolStableTokens(RebalancePoolStableTokenParams[] calldata params) external;\n}\n"
    },
    "contracts/interfaces/IRoleAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IRoleAccessControl {\n\n    function hasRole(address account, bytes32 role) external view returns(bool);\n\n    function grantRole(address account, bytes32 role) external;\n\n    function revokeRole(address account, bytes32 role) external;\n\n    function revokeAllRole(address account) external;\n\n}"
    },
    "contracts/interfaces/IStake.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/Mint.sol\";\nimport \"../storage/Redeem.sol\";\n\ninterface IStake {\n\n    struct MintStakeTokenParams {\n        address receiver;\n        address stakeToken;\n        address requestToken;\n        uint256 requestTokenAmount;\n        uint256 walletRequestTokenAmount;\n        uint256 minStakeAmount;\n        uint256 executionFee;\n        bool isCollateral;\n        bool isNativeToken;\n    }\n\n    struct RedeemStakeTokenParams {\n        address receiver;\n        address stakeToken;\n        address redeemToken;\n        uint256 unStakeAmount;\n        uint256 minRedeemAmount;\n        uint256 executionFee;\n    }\n\n    function createMintStakeTokenRequest(MintStakeTokenParams calldata params) external payable;\n\n    function executeMintStakeToken(uint256 requestId, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function cancelMintStakeToken(uint256 requestId, bytes32 reasonCode) external;\n\n    function createRedeemStakeTokenRequest(RedeemStakeTokenParams calldata params) external payable;\n\n    function executeRedeemStakeToken(uint256 requestId, OracleProcess.OracleParam[] calldata oracles) external;\n\n    function cancelRedeemStakeToken(uint256 requestId, bytes32 reasonCode) external;\n\n}\n"
    },
    "contracts/interfaces/IStakingAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IStakingAccount {\n    struct TokenBalance {\n        uint256 stakeAmount;\n        address[] collateralTokens;\n        uint256[] collateralAmounts;\n        uint256[] collateralStakeLiability;\n    }\n\n    function getAccountPoolBalance(address account, address stakeToken) external view returns (TokenBalance memory);\n\n    function getAccountPoolCollateralAmount(\n        address account,\n        address stakeToken,\n        address collateral\n    ) external view returns (uint256);\n\n    function getAccountUsdPoolAmount(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../process/AccountProcess.sol\";\nimport \"../process/RebalanceProcess.sol\";\nimport \"../process/OracleProcess.sol\";\nimport \"../storage/Withdraw.sol\";\n\ninterface ISwap {\n    struct SwapParams {\n        address fromTokenAddress;\n        address[] fromTokens;\n        uint256[] fromAmounts;\n        uint256[] minToTokenAmounts;\n        address toToken;\n        address toTokenAddress;\n        uint256 toTokenAmount;\n    }\n\n    struct SwapSingleParam {\n        address fromTokenAddress;\n        address fromToken;\n        uint256 fromAmount;\n        uint256 minToTokenAmount;\n        address toToken;\n        address toTokenAddress;\n    }\n\n    struct SwapResult {\n        address[] fromTokens;\n        uint256[] reduceFromAmounts;\n        address toToken;\n        uint256 toTokenAmount;\n        uint256 expectToTokenAmount;\n    }\n\n    struct SwapSingleResult {\n        address fromToken;\n        uint256 reduceFromAmount;\n        address toToken;\n        uint256 toTokenAmount;\n    }\n\n    function swapPortfolioToPayLiability(address[] calldata accounts, address[][] calldata accountTokens) external;\n}\n"
    },
    "contracts/interfaces/ITest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface ITest {\n\n    \n    function test() external pure returns (string memory name);\n\n}\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../vault/TradeVault.sol\";\nimport \"../vault/LpVault.sol\";\nimport \"../vault/PortfolioVault.sol\";\n\ninterface IVault {\n\n    function getTradeVault() external view returns (TradeVault);\n\n    function getLpVault() external view returns (LpVault);\n\n    function getPortfolioVault() external view returns (PortfolioVault);\n\n    function getTradeVaultAddress() external view returns (address);\n\n    function getLpVaultAddress() external view returns (address);\n\n    function getPortfolioVaultAddress() external view returns (address);\n    \n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"../utils/RoleKeys.sol\";\n\ncontract MockToken is ERC20 {\n    uint8 tokenTecimals = 18;\n\n    constructor(string memory symbol_, uint8 _decimals) ERC20(\"Mock token\", symbol_) {\n        tokenTecimals = _decimals;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external {\n        _burn(account, amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return tokenTecimals;\n    }\n}\n"
    },
    "contracts/mock/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title Multicall3\n/// @notice Aggregate results from multiple function calls\n/// @dev Multicall & Multicall2 backwards-compatible\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\n/// @author Andreas Bigger <andreas@nascent.xyz>\n/// @author Matt Solomon <matt@mattsolomon.dev>\ncontract Multicall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    /// @notice Backwards-compatible call aggregation with Multicall\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return returnData An array of bytes containing the responses\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        Call calldata call;\n        for (uint256 i; i < length; ) {\n            bool success;\n            call = calls[i];\n            (success, returnData[i]) = call.target.call(call.callData);\n            require(success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls without requiring success\n    /// @param requireSuccess If true, require all calls to succeed\n    /// @param calls An array of Call structs\n    /// @return returnData An array of Result structs\n    function tryAggregate(\n        bool requireSuccess,\n        Call[] calldata calls\n    ) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call calldata call;\n        for (uint256 i; i < length; ) {\n            Result memory result = returnData[i];\n            call = calls[i];\n            (result.success, result.returnData) = call.target.call(call.callData);\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function tryBlockAndAggregate(\n        bool requireSuccess,\n        Call[] calldata calls\n    ) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    /// @notice Backwards-compatible with Multicall2\n    /// @notice Aggregate calls and allow failures using tryAggregate\n    /// @param calls An array of Call structs\n    /// @return blockNumber The block number where the calls were executed\n    /// @return blockHash The hash of the block where the calls were executed\n    /// @return returnData An array of Result structs\n    function blockAndAggregate(\n        Call[] calldata calls\n    ) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n\n    /// @notice Aggregate calls, ensuring each returns success if required\n    /// @param calls An array of Call3 structs\n    /// @return returnData An array of Result structs\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3 calldata calli;\n        for (uint256 i; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            (result.success, result.returnData) = calli.target.call(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x64)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Aggregate calls with a msg value\n    /// @notice Reverts if msg.value is less than the sum of the call values\n    /// @param calls An array of Call3Value structs\n    /// @return returnData An array of Result structs\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new Result[](length);\n        Call3Value calldata calli;\n        for (uint256 i; i < length; ) {\n            Result memory result = returnData[i];\n            calli = calls[i];\n            uint256 val = calli.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n            (result.success, result.returnData) = calli.target.call{ value: val }(calli.callData);\n            assembly {\n                // Revert if the call fails and failure is not allowed\n                // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n                    // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                    // set data offset\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n                    // set length of revert string\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n                    // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\n                    revert(0x00, 0x84)\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\n    }\n\n    /// @notice Returns the block hash for the given block number\n    /// @param blockNumber The block number\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n        blockHash = blockhash(blockNumber);\n    }\n\n    /// @notice Returns the block number\n    function getBlockNumber() public view returns (uint256 blockNumber) {\n        blockNumber = block.number;\n    }\n\n    /// @notice Returns the block coinbase\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\n        coinbase = block.coinbase;\n    }\n\n    /// @notice Returns the block prevrandao\n    function getCurrentBlockPrevrandao() public view returns (uint256 prevrandao) {\n        prevrandao = block.prevrandao;\n    }\n\n    /// @notice Returns the block gas limit\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n        gaslimit = block.gaslimit;\n    }\n\n    /// @notice Returns the block timestamp\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    /// @notice Returns the (ETH) balance of a given address\n    function getEthBalance(address addr) public view returns (uint256 balance) {\n        balance = addr.balance;\n    }\n\n    /// @notice Returns the block hash of the last block\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\n        unchecked {\n            blockHash = blockhash(block.number - 1);\n        }\n    }\n\n    /// @notice Gets the base fee of the given block\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\n    function getBasefee() public view returns (uint256 basefee) {\n        basefee = block.basefee;\n    }\n\n    /// @notice Returns the chain id\n    function getChainId() public view returns (uint256 chainid) {\n        chainid = block.chainid;\n    }\n}\n"
    },
    "contracts/mock/WETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IWETH.sol\";\nimport \"../mock/MockToken.sol\";\nimport \"hardhat/console.sol\";\n\ncontract WETH is MockToken, IWETH {\n    error WithdrawFailed(address account, uint256 amount);\n\n    constructor() MockToken(\"Mock for WETH\", 18) {}\n\n    function deposit() external payable override {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external override {\n        _burn(msg.sender, amount);\n        (bool success, ) = msg.sender.call{ value: amount }(\"\");\n        if (!success) {\n            revert WithdrawFailed(msg.sender, amount);\n        }\n    }\n    \n}\n"
    },
    "contracts/process/AccountProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/Position.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./PositionQueryProcess.sol\";\n\nlibrary AccountProcess {\n    using SafeERC20 for IERC20;\n    using Account for Account.Props;\n    using PositionQueryProcess for Position.Props;\n    using Config for Config.Props;\n    using Position for Position.Props;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedMath for int256;\n    using SignedSafeMath for int256;\n\n    function getCrossMMR(\n        Account.Props storage accountProps,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (int256, int256, uint256) {\n        uint256 portfolioNetValue = getPortfolioNetValue(accountProps, oracles);\n        uint256 totalUsedValue = getTotalUsedValue(accountProps, oracles);\n        PositionQueryProcess.PositionStaticsCache memory cache = PositionQueryProcess.getAccountAllCrossPositionValue(\n            accountProps,\n            oracles\n        );\n        int256 crossNetValue = portfolioNetValue.toInt256() +\n            cache.totalIMUsd.toInt256() +\n            cache.totalPnl -\n            totalUsedValue.toInt256() -\n            cache.totalPosFee;\n        if (cache.totalMM <= 0) {\n            return (0, crossNetValue, cache.totalMM);\n        }\n        console.log(\"portfolioNetValue\", portfolioNetValue);\n        console.log(\"totalIMUsd\", cache.totalIMUsd);\n        consoleInt(\"totalPnl\", cache.totalPnl);\n        console.log(\"totalUsedValue\", totalUsedValue);\n        consoleInt(\"totalPosFee\", cache.totalPosFee);\n        console.log(\"totalMM\", cache.totalMM);\n        consoleInt(\"crossNetValue\", crossNetValue);\n        return (\n            crossNetValue <= 0\n                ? int256(0)\n                : CalUtils.divToPrecision(crossNetValue.toUint256(), cache.totalMM, CalUtils.RATE_PRECISION).toInt256(),\n            crossNetValue,\n            cache.totalMM\n        );\n    }\n\n    function consoleInt(string memory code, int256 value) internal pure {\n        if (value >= 0) {\n            console.log(code, value.toUint256());\n        } else {\n            console.log(\"-\", code, (-value).toUint256());\n        }\n    }\n\n    function isCrossLiquidation(Account.Props storage accountProps) external view returns (bool) {\n        OracleProcess.OracleParam[] memory oracles;\n        (, int256 crossNetValue, uint256 totalMM) = getCrossMMR(accountProps, oracles);\n        return crossNetValue <= 0 || crossNetValue.toUint256() <= totalMM;\n    }\n\n    function getPortfolioNetValue(Account.Props storage accountProps) public view returns (uint256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getPortfolioNetValue(accountProps, oracles);\n    }\n\n    function getPortfolioNetValue(\n        Account.Props storage accountProps,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (uint256) {\n        uint256 totalNetValue;\n        Config.Props storage config = Config.load();\n        address[] memory tokens = accountProps.getTokens();\n        for (uint256 i; i < tokens.length; i++) {\n            if (!config.isTradeCollateralSupport(tokens[i])) {\n                continue;\n            }\n            Account.TokenBalance memory tokenBalance = accountProps.tokenBalances[tokens[i]];\n            totalNetValue = totalNetValue.add(_getTokenNetValue(tokens[i], tokenBalance, config, oracles));\n        }\n        return totalNetValue;\n    }\n\n    function getTotalUsedValue(Account.Props storage accountProps) public view returns (uint256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getTotalUsedValue(accountProps, oracles);\n    }\n\n    function getTotalUsedValue(\n        Account.Props storage accountProps,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (uint256) {\n        uint256 totalUsedValue;\n        address[] memory tokens = accountProps.getTokens();\n        Config.Props storage config = Config.load();\n        for (uint256 i; i < tokens.length; i++) {\n            Account.TokenBalance memory tokenBalance = accountProps.tokenBalances[tokens[i]];\n            totalUsedValue = totalUsedValue.add(_getTokenUsedValue(tokens[i], tokenBalance, config, oracles));\n        }\n        if (accountProps.orderHoldInUsd > 0) {\n            totalUsedValue += accountProps.orderHoldInUsd;\n        }\n        return totalUsedValue;\n    }\n\n    function getCrossUsedValueAndBorrowingValue(\n        Account.Props storage accountProps,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (uint256, uint256) {\n        uint256 totalUsedValue;\n        uint256 totalBorrowingValue;\n        address[] memory tokens = accountProps.getTokens();\n        Config.Props storage config = Config.load();\n        for (uint256 i; i < tokens.length; i++) {\n            Account.TokenBalance memory tokenBalance = accountProps.tokenBalances[tokens[i]];\n            totalUsedValue = totalUsedValue.add(_getTokenUsedValue(tokens[i], tokenBalance, config, oracles));\n            uint256 positionUsedAmount = tokenBalance.usedAmount - tokenBalance.liability;\n            if (positionUsedAmount > tokenBalance.amount) {\n                totalBorrowingValue += CalUtils.tokenToUsd(\n                    positionUsedAmount - tokenBalance.amount,\n                    TokenUtils.decimals(tokens[i]),\n                    OracleProcess.getOraclePrices(oracles, tokens[i], true)\n                );\n            }\n        }\n        if (accountProps.orderHoldInUsd > 0) {\n            totalUsedValue += accountProps.orderHoldInUsd;\n        }\n        return (totalUsedValue, totalBorrowingValue);\n    }\n\n    function getCrossNetValueAndTotalQty(\n        Account.Props storage accountProps\n    ) public view returns (uint256 crossNetValue, uint256 totalQty) {\n        uint256 portfolioNetValue = getPortfolioNetValue(accountProps);\n        uint256 totalUsedValue = getTotalUsedValue(accountProps);\n        PositionQueryProcess.PositionStaticsCache memory cache = PositionQueryProcess.getAccountAllCrossPositionValue(\n            accountProps\n        );\n        int256 crossNetValueInt = portfolioNetValue.toInt256() +\n            cache.totalIMUsd.toInt256() +\n            cache.totalPnl -\n            totalUsedValue.toInt256() -\n            cache.totalPosFee;\n        crossNetValue = crossNetValueInt <= 0 ? 0 : crossNetValueInt.toUint256();\n        totalQty = cache.totalQty;\n    }\n\n    function getCrossAvailableValue(Account.Props storage accountProps) public view returns (int256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getCrossAvailableValue(accountProps, oracles);\n    }\n\n    function getCrossAvailableValue(\n        Account.Props storage accountProps,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (int256) {\n        uint256 totalNetValue = getPortfolioNetValue(accountProps, oracles);\n        (uint256 totalUsedValue, uint256 totalBorrowingValue) = getCrossUsedValueAndBorrowingValue(\n            accountProps,\n            oracles\n        );\n\n        PositionQueryProcess.PositionStaticsCache memory cache = PositionQueryProcess.getAccountAllCrossPositionValue(\n            accountProps,\n            oracles\n        );\n        return\n            totalNetValue.toInt256() +\n            cache.totalIMUsd.toInt256() -\n            totalUsedValue.toInt256() +\n            (cache.totalPnl >= 0 ? int256(0) : cache.totalPnl) -\n            (cache.totalIMUsdFromBalance + totalBorrowingValue).toInt256();\n    }\n\n    function _getTokenNetValue(\n        address token,\n        Account.TokenBalance memory tokenBalance,\n        Config.Props storage config,\n        OracleProcess.OracleParam[] memory oracles\n    ) internal view returns (uint256) {\n        if (tokenBalance.amount > tokenBalance.usedAmount) {\n            uint256 tokenValue = CalUtils.tokenToUsd(\n                tokenBalance.amount - tokenBalance.usedAmount,\n                TokenUtils.decimals(token),\n                OracleProcess.getOraclePrices(oracles, token, true)\n            );\n            return CalUtils.mulRate(tokenValue, config.getTradeCollateralDiscount(token));\n        }\n        return 0;\n    }\n\n    function _getTokenUsedValue(\n        address token,\n        Account.TokenBalance memory tokenBalance,\n        Config.Props storage config,\n        OracleProcess.OracleParam[] memory oracles\n    ) internal view returns (uint256) {\n        if (tokenBalance.usedAmount > tokenBalance.amount) {\n            uint256 tokenUsedValue = CalUtils.tokenToUsd(\n                tokenBalance.usedAmount - tokenBalance.amount,\n                TokenUtils.decimals(token),\n                OracleProcess.getOraclePrices(oracles, token, true)\n            );\n            if (config.getTradeTokenConfig(token).liquidationFactor > 0) {\n                return\n                    tokenUsedValue +\n                    CalUtils.mulRate(tokenUsedValue, config.getTradeTokenConfig(token).liquidationFactor);\n            } else {\n                return tokenUsedValue;\n            }\n        }\n        return 0;\n    }\n}\n"
    },
    "contracts/process/AssetsProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../utils/TransferUtils.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../storage/Withdraw.sol\";\nimport \"../storage/Order.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"./AccountProcess.sol\";\nimport \"./VaultProcess.sol\";\n\nlibrary AssetsProcess {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Account for Account.Props;\n    using Config for Config.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using CommonData for CommonData.Props;\n\n    struct UpdateAccountTokenParams {\n        address account;\n        address[] tokens;\n        int256[] changedTokenAmounts;\n    }\n\n    bytes32 constant WITHDRAW_ID_KEY = keccak256(\"WITHDRAW_ID_KEY\");\n\n    event CreateWithdrawEvent(uint256 indexed requestId, Withdraw.Request data);\n    event WithdrawSuccessEvent(uint256 indexed requestId, Withdraw.Request data);\n    event CancelWithdrawEvent(uint256 indexed requestId, Withdraw.Request data, bytes32 reasonCode);\n    event Deposit(DepositParams data);\n\n    enum DepositFrom {\n        MANUAL,\n        ORDER,\n        MINT,\n        MINT_COLLATERAL\n    }\n\n    struct DepositParams {\n        address account;\n        address token;\n        uint256 amount;\n        DepositFrom from;\n        bool isNativeToken;\n    }\n\n    struct WithdrawParams {\n        address stakeToken;\n        address account;\n        address token;\n        uint256 amount;\n    }\n\n    function depositToVault(DepositParams calldata params) public returns (address) {\n        IVault vault = IVault(address(this));\n        address targetAddress;\n        if (DepositFrom.MANUAL == params.from || DepositFrom.MINT_COLLATERAL == params.from) {\n            targetAddress = vault.getPortfolioVaultAddress();\n        } else if (DepositFrom.ORDER == params.from) {\n            targetAddress = vault.getTradeVaultAddress();\n        } else if (DepositFrom.MINT == params.from) {\n            targetAddress = vault.getLpVaultAddress();\n        }\n        address token = params.token;\n        if (params.isNativeToken) {\n            address wrapperToken = Config.load().getWrapperToken();\n            require(wrapperToken == params.token, \"Deposit with token error!\");\n            IWETH(wrapperToken).deposit{ value: params.amount }();\n            token = wrapperToken;\n            TransferUtils.transfer(token, targetAddress, params.amount);\n        } else {\n            IERC20(token).safeTransferFrom(params.account, targetAddress, params.amount);\n        }\n        return token;\n    }\n\n    function deposit(DepositParams calldata params) external {\n        address token = depositToVault(params);\n        Account.Props storage accountProps = Account.load(params.account);\n        if (DepositFrom.MANUAL == params.from) {\n            Config.Props storage config = Config.load();\n            if (!config.isTradeCollateralSupport(token)) {\n                revert Errors.TokenIsNotSupportCollateral();\n            }\n            CommonData.Props storage commonData = CommonData.load();\n            uint256 collateralAmount = commonData.getTradeTokenCollateral(token);\n            if (collateralAmount + params.amount > config.getTradeTokenConfig(token).collateralTotalCap) {\n                revert Errors.CollateralTotalCapOverflow(token, config.getTradeTokenConfig(token).collateralTotalCap);\n            }\n            if (accountProps.getTokenAmount(token) > config.getTradeTokenConfig(params.token).collateralUserCap) {\n                revert Errors.CollateralUserCapOverflow(token, config.getTradeTokenConfig(token).collateralUserCap);\n            }\n            commonData.addTradeTokenCollateral(token, params.amount);\n        }\n        if (accountProps.owner == address(0)) {\n            accountProps.owner = params.account;\n        }\n        accountProps.addToken(token, params.amount);\n        if (DepositFrom.MINT != params.from) {\n            accountProps.repayLiability(token);\n        }\n\n        emit Deposit(params);\n    }\n\n    function withdraw(WithdrawParams memory params) public {\n        if (params.amount == 0) {\n            revert Errors.AmountZeroNotAllowed();\n        }\n        Config.Props storage config = Config.load();\n        if (!config.isTradeTokenSupport(params.token)) {\n            revert Errors.OnlyCollateralSupported();\n        }\n        Account.Props storage accountProps = Account.load(params.account);\n\n        if (accountProps.getTokenAmount(params.token) < params.amount) {\n            revert Errors.WithdrawWithNoEnoughAmount();\n        }\n        uint256 tokenPrice = OracleProcess.getLatestUsdUintPrice(params.token, false);\n        int256 amountInUsd = CalUtils\n            .tokenToUsd(params.amount, TokenUtils.decimals(params.token), tokenPrice)\n            .toInt256();\n        if (_hasCrossUsed(accountProps) && AccountProcess.getCrossAvailableValue(accountProps) < amountInUsd) {\n            revert Errors.WithdrawWithNoEnoughAmount();\n        }\n        accountProps.subToken(params.token, params.amount);\n        VaultProcess.transferOut(\n            IVault(address(this)).getPortfolioVaultAddress(),\n            params.token,\n            params.account,\n            params.amount\n        );\n    }\n\n    function createWithdrawRequest(address token, uint256 amount) external {\n        uint256 requestId = UuidCreator.nextId(WITHDRAW_ID_KEY);\n        Withdraw.Request storage request = Withdraw.create(requestId);\n        request.account = msg.sender;\n        request.token = token;\n        request.amount = amount;\n\n        emit CreateWithdrawEvent(requestId, request);\n    }\n\n    function executeWithdraw(uint256 requestId, Withdraw.Request memory request) external {\n        withdraw(WithdrawParams(address(0), request.account, request.token, request.amount));\n        Withdraw.remove(requestId);\n\n        emit WithdrawSuccessEvent(requestId, request);\n    }\n\n    function cancelWithdraw(uint256 requestId, Withdraw.Request memory request, bytes32 reasonCode) external {\n        Withdraw.remove(requestId);\n        emit CancelWithdrawEvent(requestId, request, reasonCode);\n    }\n\n    function updateAccountToken(UpdateAccountTokenParams calldata params) external {\n        Account.Props storage accountProps = Account.load(params.account);\n        accountProps.checkExists();\n        for (uint256 i; i < params.tokens.length; i++) {\n            if (params.changedTokenAmounts[i] > 0) {\n                accountProps.addToken(params.tokens[i], params.changedTokenAmounts[i].toUint256());\n                accountProps.repayLiability(params.tokens[i]);\n            } else {\n                accountProps.subToken(params.tokens[i], params.changedTokenAmounts[i].toUint256());\n            }\n        }\n    }\n\n    function _hasCrossUsed(Account.Props storage account) internal view returns (bool) {\n        if (account.hasLiability()) {\n            return true;\n        }\n        uint256[] memory orders = account.getOrders();\n        Order.Props storage orderProps = Order.load();\n        for (uint256 i; i < orders.length; i++) {\n            if (orderProps.get(orders[i]).isCrossMargin) {\n                return true;\n            }\n        }\n        bytes32[] memory positionKeys = account.getAllPosition();\n        for (uint256 i; i < positionKeys.length; i++) {\n            Position.Props storage position = Position.load(positionKeys[i]);\n            if (position.isCrossMargin) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/process/AutoReduceProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./RedeemProcess.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./DecreasePositionProcess.sol\";\nimport \"./CancelOrderProcess.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/Errors.sol\";\n\nlibrary AutoReduceProcess {\n    using DecreasePositionProcess for Position.Props;\n    using Position for Position.Props;\n    using Account for Account.Props;\n    using StakingAccount for StakingAccount.Props;\n    using Config for Config.Props;\n    using Order for Order.Props;\n\n    bytes32 constant AUTO_REDUCE_ID_KEY = keccak256(\"AUTO_REDUCE_ID_KEY\");\n\n    function autoRedeem(address stakeToken, address[] calldata accounts, address collateral) external {\n        LpPool.Props storage pool = LpPool.load(stakeToken);\n        Config.Props storage config = Config.load();\n        for (uint256 i; i < accounts.length; i++) {\n            StakingAccount.Props storage stakingAccountProps = StakingAccount.load(accounts[i]);\n            StakingAccount.CollateralData memory data = stakingAccountProps.getCollateralToken(stakeToken, collateral);\n            if (data.amount == 0 || data.stakeLiability == 0) {\n                return;\n            }\n            uint256 collateralPrice = OracleProcess.getLatestUsdUintPrice(collateral, pool.baseToken, true);\n            uint256 toStakeLiabilityAmount = CalUtils.tokenToToken(\n                data.amount,\n                TokenUtils.decimals(collateral),\n                TokenUtils.decimals(pool.baseToken),\n                collateralPrice\n            );\n            if (\n                toStakeLiabilityAmount >\n                data.stakeLiability + CalUtils.mulRate(data.stakeLiability, config.getStakeConfig().collateralFactor)\n            ) {\n                revert Errors.LiquidationIgnored(accounts[i]);\n            }\n            RedeemProcess.autoRedeemStakeCollateral(pool, stakingAccountProps, collateral);\n        }\n    }\n\n    function autoReducePositions(bytes32[] calldata positionKeys) external {\n        for (uint256 i; i < positionKeys.length; i++) {\n            _reducePosition(positionKeys[i]);\n        }\n    }\n\n    function _reducePosition(bytes32 positionKey) internal {\n        Position.Props storage position = Position.load(positionKey);\n        if (position.qty == 0) {\n            return;\n        }\n        CancelOrderProcess.cancelSymbolOrders(\n            position.account,\n            position.symbol,\n            position.marginToken,\n            CancelOrderProcess.CANCEL_ORDER_AUTO_REDUCE\n        );\n        uint256 indexPrice = OracleProcess.getLatestUsdUintPrice(position.indexToken, position.isLong);\n        position.decreasePosition(\n            DecreasePositionProcess.DecreasePositionParams(\n                UuidCreator.nextId(AUTO_REDUCE_ID_KEY),\n                position.symbol,\n                false,\n                position.isCrossMargin,\n                position.marginToken,\n                position.qty,\n                indexPrice\n            )\n        );\n    }\n}\n"
    },
    "contracts/process/CancelOrderProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../interfaces/IVault.sol\";\nimport \"./VaultProcess.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/Order.sol\";\n\nlibrary CancelOrderProcess {\n    using Order for Order.Props;\n    using Account for Account.Props;\n\n    bytes32 public constant CANCEL_ORDER_LIQUIDATION = bytes32(abi.encode(\"CANCEL_WITH_LIQUIDATION\"));\n    bytes32 public constant CANCEL_ORDER_AUTO_REDUCE = bytes32(abi.encode(\"CANCEL_WITH_AUTO_REDUCE\"));\n    bytes32 public constant CANCEL_ORDER_POSITION_CLOSE = bytes32(abi.encode(\"CANCEL_WITH_POSITION_CLOSE\"));\n\n    event CancelOrderEvent(uint256 indexed orderId, Order.OrderInfo data, bytes32 reasonCode);\n\n    function cancelAllCrossOrders(address account, bytes32 reasonCode) internal {\n        Account.Props storage accountProps = Account.load(account);\n        uint256[] memory orders = accountProps.getOrders();\n        if (orders.length == 0) {\n            return;\n        }\n        Order.Props storage orderProps = Order.load();\n        for (uint256 i; i < orders.length; i++) {\n            Order.OrderInfo memory order = orderProps.get(orders[i]);\n            if (order.isCrossMargin) {\n                orderProps.remove(orders[i]);\n                accountProps.delOrder(orders[i]);\n                if (Order.PositionSide.INCREASE == order.posSide) {\n                    accountProps.subOrderHoldInUsd(order.orderMargin);\n                }\n                emit CancelOrderEvent(orders[i], order, reasonCode);\n            }\n        }\n    }\n\n    function cancelSymbolOrders(address account, bytes32 symbol, address marginToken, bytes32 reasonCode) internal {\n        Account.Props storage accountProps = Account.load(account);\n        uint256[] memory orders = accountProps.getOrders();\n        if (orders.length == 0) {\n            return;\n        }\n        Order.Props storage orderProps = Order.load();\n        for (uint256 i; i < orders.length; i++) {\n            Order.OrderInfo memory order = orderProps.get(orders[i]);\n            if (order.symbol == symbol && order.marginToken == marginToken && order.isCrossMargin == false) {\n                orderProps.remove(orders[i]);\n                accountProps.delOrder(orders[i]);\n                if (Order.PositionSide.INCREASE == order.posSide) {\n                    VaultProcess.transferOut(\n                        IVault(address(this)).getTradeVaultAddress(),\n                        order.marginToken,\n                        order.account,\n                        order.orderMargin\n                    );\n                }\n                emit CancelOrderEvent(orders[i], order, reasonCode);\n            }\n        }\n    }\n\n    function cancelStopOrders(address account, bytes32 symbol, address marginToken, bool isCrossMargin, bytes32 reasonCode) external {\n        Account.Props storage accountProps = Account.load(account);\n        uint256[] memory orderIds = accountProps.getAllOrders();\n        if (orderIds.length > 0) {\n            Order.Props storage orderPros = Order.load();\n            for (uint256 i; i < orderIds.length; i++) {\n                Order.OrderInfo storage orderInfo = orderPros.get(orderIds[i]);\n                if (\n                    orderInfo.symbol == symbol &&\n                    orderInfo.marginToken == marginToken &&\n                    Order.Type.STOP == orderInfo.orderType &&\n                    orderInfo.isCrossMargin == isCrossMargin\n                ) {\n                    accountProps.delOrder(orderIds[i]);\n                    orderPros.remove(orderIds[i]);\n                    emit CancelOrderEvent(orderIds[i], orderInfo, reasonCode);\n                }\n            }\n        }\n    }\n\n    function cancelOrder(uint256 orderId, Order.OrderInfo memory order, bytes32 reasonCode) external {\n        Account.Props storage accountProps = Account.load(order.account);\n        accountProps.delOrder(orderId);\n        Order.remove(orderId);\n        if (Order.PositionSide.INCREASE == order.posSide) {\n            if (order.isCrossMargin == true) {\n                accountProps.subOrderHoldInUsd(order.orderMargin);\n            } else {\n                VaultProcess.transferOut(\n                    IVault(address(this)).getTradeVaultAddress(),\n                    order.marginToken,\n                    order.account,\n                    order.orderMargin\n                );\n            }\n        }\n        emit CancelOrderEvent(orderId, order, reasonCode);\n    }\n}\n"
    },
    "contracts/process/ClaimRewardsProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IFee.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/FeeRewards.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../storage/ClaimRewards.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"./VaultProcess.sol\";\nimport \"./LpPoolQueryProcess.sol\";\nimport \"./GasProcess.sol\";\nimport \"./AssetsProcess.sol\";\nimport \"./FeeRewardsProcess.sol\";\n\nlibrary ClaimRewardsProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using Config for Config.Props;\n    using UsdPool for UsdPool.Props;\n    using LpPool for LpPool.Props;\n    using LpPoolQueryProcess for LpPool.Props;\n    using LpPoolQueryProcess for UsdPool.Props;\n    using StakingAccount for StakingAccount.Props;\n    using FeeRewards for FeeRewards.MarketRewards;\n    using FeeRewards for FeeRewards.StakingRewards;\n\n    bytes32 constant CLAIM_ID_KEY = keccak256(\"CLAIM_ID_KEY\");\n\n    event CreateClaimRewardsEvent(uint256 indexed requestId, ClaimRewards.Request data);\n    event ClaimRewardsSuccessEvent(uint256 indexed requestId, ClaimRewards.Request data);\n    event CancelClaimRewardsEvent(uint256 indexed requestId, ClaimRewards.Request data, bytes32 reasonCode);\n\n    function createClaimRewards(address account, address claimUsdToken, uint256 executionFee) external {\n        if (!UsdPool.isSupportStableToken(claimUsdToken)) {\n            revert Errors.ClaimTokenNotSupported();\n        }\n        Config.Props storage config = Config.load();\n        GasProcess.validateExecutionFeeLimit(executionFee, config.chainConfig.claimRewardsGasFeeLimit);\n        require(msg.value == executionFee, \"claim rewards with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                account,\n                config.chainConfig.wrapperToken,\n                executionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n        uint256 requestId = UuidCreator.nextId(CLAIM_ID_KEY);\n        ClaimRewards.Request storage request = ClaimRewards.create(requestId);\n        request.account = account;\n        request.claimUsdToken = claimUsdToken;\n        request.executionFee = executionFee;\n        emit CreateClaimRewardsEvent(requestId, request);\n    }\n\n    function claimRewards(uint256 requestId, ClaimRewards.Request memory request) external {\n        address account = request.account;\n        address[] memory stakeTokens = CommonData.getAllStakeTokens();\n        StakingAccount.Props storage stakingAccount = StakingAccount.load(account);\n        StakingAccount.FeeRewards storage accountFeeRewards;\n        for (uint256 i; i < stakeTokens.length; i++) {\n            address stakeToken = stakeTokens[i];\n            FeeRewards.MarketRewards storage feeProps = FeeRewards.loadPoolRewards(stakeToken);\n            FeeRewardsProcess.updateAccountFeeRewards(account, stakeToken);\n            accountFeeRewards = stakingAccount.getFeeRewards(stakeToken);\n            if (accountFeeRewards.realisedRewardsTokenAmount == 0) {\n                continue;\n            }\n            LpPool.Props storage pool = LpPool.load(stakeToken);\n            uint256 withdrawPoolAmount = accountFeeRewards.realisedRewardsTokenAmount;\n            pool.subBaseToken(withdrawPoolAmount);\n            VaultProcess.transferOut(stakeToken, pool.baseToken, account, withdrawPoolAmount);\n            accountFeeRewards.realisedRewardsTokenAmount = 0;\n            accountFeeRewards.openRewardsPerStakeToken = feeProps.getCumulativeRewardsPerStakeToken();\n        }\n\n        accountFeeRewards = stakingAccount.getFeeRewards(\n            CommonData.getStakeUsdToken()\n        );\n        uint256 withdrawAmount = CalUtils.usdToToken(\n            accountFeeRewards.realisedRewardsTokenAmount,\n            TokenUtils.decimals(request.claimUsdToken),\n            OracleProcess.getLatestUsdUintPrice(request.claimUsdToken, false)\n        );\n        UsdPool.Props storage usdPool = UsdPool.load();\n        usdPool.subStableToken(request.claimUsdToken, withdrawAmount);\n        VaultProcess.transferOut(CommonData.getStakeUsdToken(), request.claimUsdToken, account, withdrawAmount);\n\n        ClaimRewards.remove(requestId);\n        emit ClaimRewardsSuccessEvent(requestId, request);\n    }\n\n    function cancelClaimRewards(uint256 requestId, ClaimRewards.Request memory request, bytes32 reasonCode) external {\n        ClaimRewards.remove(requestId);\n        emit CancelClaimRewardsEvent(requestId, request, reasonCode);\n    }\n}\n"
    },
    "contracts/process/ConfigProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IConfig.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../utils/Errors.sol\";\n\nlibrary ConfigProcess {\n    using Config for Config.Props;\n    using LpPool for LpPool.Props;\n    using UsdPool for UsdPool.Props;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    function getConfig() external view returns (IConfig.CommonConfigParams memory config) {\n        Config.Props storage configProps = Config.load();\n        config.mintGasFeeLimit = configProps.chainConfig.mintGasFeeLimit;\n        config.redeemGasFeeLimit = configProps.chainConfig.redeemGasFeeLimit;\n        config.placeIncreaseOrderGasFeeLimit = configProps.chainConfig.placeIncreaseOrderGasFeeLimit;\n        config.placeDecreaseOrderGasFeeLimit = configProps.chainConfig.placeDecreaseOrderGasFeeLimit;\n        config.positionUpdateMarginGasFeeLimit = configProps.chainConfig.positionUpdateMarginGasFeeLimit;\n        config.positionUpdateLeverageGasFeeLimit = configProps.chainConfig.positionUpdateLeverageGasFeeLimit;\n        config.claimRewardsGasFeeLimit = configProps.chainConfig.claimRewardsGasFeeLimit;\n        config.tradeTokens = configProps.tradeConfig.tokens.values();\n        config.tradeTokenConfigs = new Config.TradeTokenConfig[](config.tradeTokens.length);\n        for (uint256 i; i < config.tradeTokens.length; i++) {\n            config.tradeTokenConfigs[i] = configProps.tradeConfig.tokenConfigs[config.tradeTokens[i]];\n        }\n        config.minOrderMarginUSD = configProps.tradeConfig.minOrderMarginUSD;\n        config.availableCollateralRatio = configProps.tradeConfig.availableCollateralRatio;\n        config.crossLtvLimit = configProps.tradeConfig.crossLtvLimit;\n        config.executeOrderMinBlockGap = configProps.tradeConfig.executeOrderMinBlockGap;\n        config.executeOrderMaxBlockGap = configProps.tradeConfig.executeOrderMaxBlockGap;\n        config.executePositionMarginMinBlockGap = configProps.tradeConfig.executePositionMarginMinBlockGap;\n        config.executePositionMarginMaxBlockGap = configProps.tradeConfig.executePositionMarginMaxBlockGap;\n        config.executeLeverageMinBlockGap = configProps.tradeConfig.executeLeverageMinBlockGap;\n        config.executeLeverageMaxBlockGap = configProps.tradeConfig.executeLeverageMaxBlockGap;\n        config.maxMaintenanceMarginRate = configProps.tradeConfig.maxMaintenanceMarginRate;\n        config.fundingFeeBaseRate = configProps.tradeConfig.fundingFeeBaseRate;\n        config.minPrecisionMultiple = configProps.stakeConfig.minPrecisionMultiple;\n        config.stakeCollateralProtectFactor = configProps.stakeConfig.collateralProtectFactor;\n        config.stakeCollateralFactor = configProps.stakeConfig.collateralFactor;\n        config.tradingFeeStakingRewardsRatio = configProps.tradeConfig.tradingFeeStakingRewardsRatio;\n        config.tradingFeePoolRewardsRatio = configProps.tradeConfig.tradingFeePoolRewardsRatio;\n        config.tradingFeeUsdPoolRewardsRatio = configProps.tradeConfig.tradingFeeUsdPoolRewardsRatio;\n        config.borrowingFeeStakingRewardsRatio = configProps.tradeConfig.borrowingFeeStakingRewardsRatio;\n        config.borrowingFeePoolRewardsRatio = configProps.tradeConfig.borrowingFeePoolRewardsRatio;\n        config.autoReduceProfitFactor = configProps.tradeConfig.autoReduceProfitFactor;\n        config.autoReduceLiquidityFactor = configProps.tradeConfig.autoReduceLiquidityFactor;\n        config.swapSlipperTokenFactor = configProps.tradeConfig.swapSlipperTokenFactor;\n        config.mintFeeStakingRewardsRatio = configProps.stakeConfig.mintFeeStakingRewardsRatio;\n        config.mintFeePoolRewardsRatio = configProps.stakeConfig.mintFeePoolRewardsRatio;\n        config.redeemFeeStakingRewardsRatio = configProps.stakeConfig.redeemFeeStakingRewardsRatio;\n        config.redeemFeePoolRewardsRatio = configProps.stakeConfig.redeemFeePoolRewardsRatio;\n        config.uniswapRouter = configProps.commonConfig.uniswapRouter;\n        config.poolRewardsIntervalLimit = configProps.stakeConfig.poolRewardsIntervalLimit;\n    }\n\n    function setConfig(IConfig.CommonConfigParams calldata params) external {\n        Config.Props storage config = Config.load();\n        config.chainConfig.wrapperToken = params.wrapperToken;\n        config.chainConfig.mintGasFeeLimit = params.mintGasFeeLimit;\n        config.chainConfig.redeemGasFeeLimit = params.redeemGasFeeLimit;\n        config.chainConfig.placeIncreaseOrderGasFeeLimit = params.placeIncreaseOrderGasFeeLimit;\n        config.chainConfig.placeDecreaseOrderGasFeeLimit = params.placeDecreaseOrderGasFeeLimit;\n        config.chainConfig.positionUpdateMarginGasFeeLimit = params.positionUpdateMarginGasFeeLimit;\n        config.chainConfig.positionUpdateLeverageGasFeeLimit = params.positionUpdateLeverageGasFeeLimit;\n        config.chainConfig.claimRewardsGasFeeLimit = params.claimRewardsGasFeeLimit;\n        for (uint256 i; i < params.tradeTokens.length; i++) {\n            config.addTradeToken(params.tradeTokens[i], params.tradeTokenConfigs[i]);\n        }\n        config.tradeConfig.minOrderMarginUSD = params.minOrderMarginUSD;\n        config.tradeConfig.availableCollateralRatio = params.availableCollateralRatio;\n        config.tradeConfig.crossLtvLimit = params.crossLtvLimit;\n        config.tradeConfig.executeOrderMinBlockGap = params.executeOrderMinBlockGap;\n        config.tradeConfig.executeOrderMaxBlockGap = params.executeOrderMaxBlockGap;\n        config.tradeConfig.executePositionMarginMinBlockGap = params.executePositionMarginMinBlockGap;\n        config.tradeConfig.executePositionMarginMaxBlockGap = params.executePositionMarginMaxBlockGap;\n        config.tradeConfig.executeLeverageMinBlockGap = params.executeLeverageMinBlockGap;\n        config.tradeConfig.executeLeverageMaxBlockGap = params.executeLeverageMaxBlockGap;\n        config.tradeConfig.maxMaintenanceMarginRate = params.maxMaintenanceMarginRate;\n        config.tradeConfig.fundingFeeBaseRate = params.fundingFeeBaseRate;\n        config.tradeConfig.tradingFeeStakingRewardsRatio = params.tradingFeeStakingRewardsRatio;\n        config.tradeConfig.tradingFeePoolRewardsRatio = params.tradingFeePoolRewardsRatio;\n        config.tradeConfig.tradingFeeUsdPoolRewardsRatio = params.tradingFeeUsdPoolRewardsRatio;\n        config.tradeConfig.borrowingFeeStakingRewardsRatio = params.borrowingFeeStakingRewardsRatio;\n        config.tradeConfig.borrowingFeePoolRewardsRatio = params.borrowingFeePoolRewardsRatio;\n        config.tradeConfig.autoReduceProfitFactor = params.autoReduceProfitFactor;\n        config.tradeConfig.autoReduceLiquidityFactor = params.autoReduceLiquidityFactor;\n        config.tradeConfig.swapSlipperTokenFactor = params.swapSlipperTokenFactor;\n        \n        config.stakeConfig.collateralFactor = params.stakeCollateralFactor;\n        config.stakeConfig.collateralProtectFactor = params.stakeCollateralProtectFactor;\n        config.stakeConfig.minPrecisionMultiple = params.minPrecisionMultiple;\n        config.stakeConfig.mintFeeStakingRewardsRatio = params.mintFeeStakingRewardsRatio;\n        config.stakeConfig.mintFeePoolRewardsRatio = params.mintFeePoolRewardsRatio;\n        config.stakeConfig.redeemFeeStakingRewardsRatio = params.redeemFeeStakingRewardsRatio;\n        config.stakeConfig.redeemFeePoolRewardsRatio = params.redeemFeePoolRewardsRatio;\n        config.commonConfig.uniswapRouter = params.uniswapRouter;\n        config.stakeConfig.poolRewardsIntervalLimit = params.poolRewardsIntervalLimit;\n    }\n\n    function getPoolConfig(address stakeToken) public view returns (IConfig.LpPoolConfigParams memory config) {\n        Config.LpPoolConfig storage lpPoolConfig = Config.load().getPoolConfig(stakeToken);\n        config.assetTokens = lpPoolConfig.assetTokens;\n\n        config.supportCollateralTokens = lpPoolConfig.supportCollateralTokens.values();\n        config.collateralTokensConfigs = new Config.StakeCollateralConfig[](config.supportCollateralTokens.length);\n        for (uint256 i; i < config.supportCollateralTokens.length; i++) {\n            config.collateralTokensConfigs[i] = lpPoolConfig.collateralTokensConfigs[config.supportCollateralTokens[i]];\n        }\n\n        config.poolLiquidityLimit = lpPoolConfig.poolLiquidityLimit;\n        config.mintFeeRate = lpPoolConfig.mintFeeRate;\n        config.redeemFeeRate = lpPoolConfig.redeemFeeRate;\n        config.stakeToken = stakeToken;\n        config.baseInterestRate = lpPoolConfig.baseInterestRate;\n        config.poolPnlRatioLimit = lpPoolConfig.poolPnlRatioLimit;\n        config.collateralStakingRatioLimit = lpPoolConfig.collateralStakingRatioLimit;\n        config.unsettledBaseTokenRatioLimit = lpPoolConfig.unsettledBaseTokenRatioLimit;\n        config.unsettledStableTokenRatioLimit = lpPoolConfig.unsettledStableTokenRatioLimit;\n        config.poolStableTokenRatioLimit = lpPoolConfig.poolStableTokenRatioLimit;\n        config.poolStableTokenLossLimit = lpPoolConfig.poolStableTokenLossLimit;\n    }\n\n    function setPoolConfig(IConfig.LpPoolConfigParams memory params) external {\n        LpPool.Props storage pool = LpPool.load(params.stakeToken);\n        Config.LpPoolConfig storage poolConfig = Config.load().lpPoolConfigs[params.stakeToken];\n        if (pool.stakeToken == address(0)) {\n            revert Errors.PoolNotExists();\n        }\n        poolConfig.baseInterestRate = params.baseInterestRate;\n        poolConfig.assetTokens = params.assetTokens;\n        poolConfig.poolLiquidityLimit = params.poolLiquidityLimit;\n        poolConfig.mintFeeRate = params.mintFeeRate;\n        poolConfig.redeemFeeRate = params.redeemFeeRate;\n        poolConfig.poolPnlRatioLimit = params.poolPnlRatioLimit;\n        poolConfig.collateralStakingRatioLimit = params.collateralStakingRatioLimit;\n        poolConfig.unsettledBaseTokenRatioLimit = params.unsettledBaseTokenRatioLimit;\n        poolConfig.unsettledStableTokenRatioLimit = params.unsettledStableTokenRatioLimit;\n        poolConfig.poolStableTokenRatioLimit = params.poolStableTokenRatioLimit;\n        poolConfig.poolStableTokenLossLimit = params.poolStableTokenLossLimit;\n        for (uint256 i; i < params.supportCollateralTokens.length; i++) {\n            pool.addStakeCollateralToken(params.supportCollateralTokens[i], params.collateralTokensConfigs[i]);\n        }\n    }\n\n    function getUsdPoolConfig() external view returns (IConfig.UsdPoolConfigParams memory config) {\n        UsdPool.Props storage pool = UsdPool.load();\n        Config.UsdPoolConfig storage usdPoolConfig = Config.load().usdPoolConfig;\n        config.mintFeeRate = usdPoolConfig.mintFeeRate;\n        config.poolLiquidityLimit = usdPoolConfig.poolLiquidityLimit;\n        config.redeemFeeRate = usdPoolConfig.redeemFeeRate;\n        config.unsettledRatioLimit = usdPoolConfig.unsettledRatioLimit;\n        config.supportStableTokens = pool.stableTokens.values();\n        config.stableTokensBorrowingInterestRate = new uint256[](config.supportStableTokens.length);\n        config.stableTokensRatioLimit = new uint256[](config.supportStableTokens.length);\n        for (uint256 i; i < config.supportStableTokens.length; i++) {\n            config.stableTokensBorrowingInterestRate[i] = usdPoolConfig.baseInterestRates[\n                config.supportStableTokens[i]\n            ];\n            config.stableTokensRatioLimit[i] = usdPoolConfig.stableTokenRatioLimits[config.supportStableTokens[i]];\n        }\n    }\n\n    function setUsdPoolConfig(IConfig.UsdPoolConfigParams calldata params) external {\n        UsdPool.Props storage pool = UsdPool.load();\n        Config.UsdPoolConfig storage usdPoolConfig = Config.load().usdPoolConfig;\n        pool.addSupportStableTokens(params.supportStableTokens);\n        for (uint256 i; i < params.stableTokensBorrowingInterestRate.length; i++) {\n            usdPoolConfig.baseInterestRates[params.supportStableTokens[i]] = params.stableTokensBorrowingInterestRate[\n                i\n            ];\n            usdPoolConfig.stableTokenRatioLimits[params.supportStableTokens[i]] = params.stableTokensRatioLimit[i];\n        }\n        usdPoolConfig.poolLiquidityLimit = params.poolLiquidityLimit;\n        usdPoolConfig.unsettledRatioLimit = params.unsettledRatioLimit;\n        usdPoolConfig.mintFeeRate = params.mintFeeRate;\n        usdPoolConfig.redeemFeeRate = params.redeemFeeRate;\n    }\n\n    function getSymbolConfig(bytes32 code) external view returns (IConfig.SymbolConfigParams memory config) {\n        config.symbol = code;\n        config.config = Config.load().getSymbolConfig(code);\n    }\n\n    function setSymbolConfig(IConfig.SymbolConfigParams calldata params) external {\n        Config.SymbolConfig storage symbolConfig = Config.load().symbolConfigs[params.symbol];\n        Symbol.Props storage symbolProps = Symbol.load(params.symbol);\n        if (symbolProps.stakeToken == address(0)) {\n            revert Errors.SymbolNotExists();\n        }\n        symbolConfig.maxLeverage = params.config.maxLeverage;\n        symbolConfig.tickSize = params.config.tickSize;\n        symbolConfig.openFeeRate = params.config.openFeeRate;\n        symbolConfig.closeFeeRate = params.config.closeFeeRate;\n        symbolConfig.maxLongOpenInterestCap = params.config.maxLongOpenInterestCap;\n        symbolConfig.maxShortOpenInterestCap = params.config.maxShortOpenInterestCap;\n        symbolConfig.longShortRatioLimit = params.config.longShortRatioLimit;\n        symbolConfig.longShortOiBottomLimit = params.config.longShortOiBottomLimit;\n    }\n}\n"
    },
    "contracts/process/DecreasePositionProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/Order.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/InsuranceFund.sol\";\nimport \"../vault/TradeVault.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../utils/CommonUtils.sol\";\nimport \"./MarketProcess.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./LpPoolProcess.sol\";\nimport \"./FeeProcess.sol\";\nimport \"./VaultProcess.sol\";\nimport \"./AccountProcess.sol\";\nimport \"./CancelOrderProcess.sol\";\nimport \"./PositionQueryProcess.sol\";\nimport \"./FeeQueryProcess.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary DecreasePositionProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using Math for uint256;\n    using Config for Config.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n    using Market for Market.Props;\n\n    struct DecreasePositionParams {\n        uint256 requestId;\n        bytes32 symbol;\n        bool isLiquidation;\n        bool isCrossMargin;\n        address marginToken;\n        uint256 decreaseQty;\n        uint256 executePrice;\n    }\n\n    struct DecreasePositionCache {\n        address stakeToken;\n        Position.Props position;\n        uint256 marginTokenPrice;\n        int256 executePrice;\n        int256 recordPnlToken;\n        int256 settledMargin;\n        uint256 decreaseMargin;\n        uint256 decreaseMarginInUsd;\n        uint256 decreaseMarginInUsdFromBalance;\n        uint256 settledBorrowingFee;\n        uint256 settledBorrowingFeeInUsd;\n        int256 settledFundingFee;\n        int256 settledFundingFeeInUsd;\n        uint256 unHoldPoolAmount;\n        uint256 closeFee;\n        uint256 closeFeeInUsd;\n        int256 realizedPnl;\n        int256 poolPnlToken;\n        bool isLiquidation;\n    }\n\n    function decreasePosition(Position.Props storage position, DecreasePositionParams calldata params) external {\n        int256 totalPnlInUsd = PositionQueryProcess.getPositionUnPnl(position, params.executePrice.toInt256(), false);\n        Symbol.Props memory symbolProps = Symbol.load(params.symbol);\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(params.symbol);\n        DecreasePositionCache memory cache = _updateDecreasePosition(\n            position,\n            params.decreaseQty,\n            totalPnlInUsd,\n            params.executePrice.toInt256(),\n            symbolConfig.closeFeeRate,\n            params.isLiquidation,\n            params.isCrossMargin\n        );\n        if (cache.settledMargin < 0 && !cache.isLiquidation && !position.isCrossMargin) {\n            revert Errors.PositionShouldBeLiquidation();\n        }\n        cache.stakeToken = symbolProps.stakeToken;\n        cache.isLiquidation = params.isLiquidation;\n\n        Account.Props storage accountProps = Account.load(position.account);\n        if (params.decreaseQty == position.qty) {\n            accountProps.delPosition(\n                Position.getPositionKey(position.account, position.symbol, position.marginToken, position.isCrossMargin)\n            );\n            position.reset();\n        } else {\n            position.qty -= params.decreaseQty;\n            position.initialMargin -= cache.decreaseMargin;\n            position.initialMarginInUsd -= cache.decreaseMarginInUsd;\n            position.initialMarginInUsdFromBalance -= cache.decreaseMarginInUsdFromBalance;\n            position.positionFee.realizedBorrowingFee -= cache.settledBorrowingFee;\n            position.positionFee.realizedBorrowingFeeInUsd -= cache.settledBorrowingFeeInUsd;\n            position.holdPoolAmount -= cache.unHoldPoolAmount;\n            position.realizedPnl += cache.realizedPnl;\n            position.positionFee.closeFeeInUsd -= cache.closeFeeInUsd;\n            position.lastUpdateTime = ChainUtils.currentTimestamp();\n        }\n\n        FeeProcess.chargeTradingFee(\n            cache.closeFee,\n            symbolProps.code,\n            cache.isLiquidation ? FeeProcess.FEE_LIQUIDATION : FeeProcess.FEE_CLOSE_POSITION,\n            cache.position.marginToken,\n            cache.position\n        );\n\n        FeeProcess.chargeBorrowingFee(\n            position.isCrossMargin,\n            cache.settledBorrowingFee,\n            symbolProps.stakeToken,\n            cache.position.marginToken,\n            position.account,\n            cache.isLiquidation ? FeeProcess.FEE_LIQUIDATION : FeeProcess.FEE_BORROWING\n        );\n\n        uint256 addLiability = _settleAccount(accountProps, position, cache);\n        if (cache.position.isCrossMargin && addLiability == 0) {\n            accountProps.repayLiability(cache.position.marginToken);\n        }\n        // update pool hold\n        LpPoolProcess.updatePnlAndUnHoldPoolAmount(\n            symbolProps.stakeToken,\n            cache.position.marginToken,\n            cache.unHoldPoolAmount,\n            cache.poolPnlToken,\n            cache.isLiquidation && cache.position.isCrossMargin && cache.poolPnlToken > 0\n                ? cache.poolPnlToken.toUint256()\n                : addLiability\n        );\n\n        // update total borrowing\n        MarketProcess.updateTotalBorrowingFee(\n            symbolProps.stakeToken,\n            cache.position.isLong,\n            cache.position.marginToken,\n            cache.settledBorrowingFee.toInt256(),\n            -cache.settledBorrowingFee.toInt256()\n        );\n\n        // update funding fee\n        MarketProcess.updateMarketFundingFee(\n            symbolProps.code,\n            -cache.settledFundingFee,\n            cache.position.isLong,\n            !position.isCrossMargin,\n            cache.position.marginToken\n        );\n\n        // update & verify OI\n        MarketProcess.updateMarketOI(\n            MarketProcess.UpdateOIParams(\n                false,\n                symbolProps.code,\n                cache.position.marginToken,\n                params.decreaseQty,\n                0,\n                cache.position.isLong\n            )\n        );\n\n        // cancel stop orders\n        CancelOrderProcess.cancelStopOrders(\n            cache.position.account,\n            symbolProps.code,\n            cache.position.marginToken,\n            cache.position.isCrossMargin,\n            CancelOrderProcess.CANCEL_ORDER_POSITION_CLOSE\n        );\n\n        // update insuranceFund\n        if (cache.isLiquidation) {\n            InsuranceFund.addFunds(\n                cache.stakeToken,\n                cache.position.marginToken,\n                cache.position.isCrossMargin\n                    ? CalUtils.usdToToken(\n                        PositionQueryProcess.getPositionMM(cache.position),\n                        TokenUtils.decimals(cache.position.marginToken),\n                        cache.marginTokenPrice\n                    )\n                    : (\n                        cache.decreaseMargin > cache.closeFee.add(cache.poolPnlToken.toUint256())\n                            ? cache.decreaseMargin.sub(cache.closeFee).sub(cache.poolPnlToken.toUint256())\n                            : 0\n                    )\n            );\n            position.emitPositionUpdateEvent(\n                params.requestId,\n                Position.PositionUpdateFrom.LIQUIDATION,\n                params.executePrice\n            );\n        } else {\n            position.emitPositionUpdateEvent(\n                params.requestId,\n                Position.PositionUpdateFrom.ORDER_DECREASE,\n                params.executePrice\n            );\n        }\n    }\n\n    function _updateDecreasePosition(\n        Position.Props storage position,\n        uint256 decreaseQty,\n        int256 pnlInUsd,\n        int256 executePrice,\n        uint256 closeFeeRate,\n        bool isLiquidation,\n        bool isCrossMargin\n    ) internal view returns (DecreasePositionCache memory cache) {\n        cache.position = position;\n        cache.executePrice = executePrice;\n        int256 tokenPrice = OracleProcess.getLatestUsdPrice(position.marginToken, false);\n        cache.marginTokenPrice = tokenPrice.toUint256();\n        uint8 tokenDecimals = TokenUtils.decimals(position.marginToken);\n        if (position.qty == decreaseQty) {\n            cache.decreaseMargin = cache.position.initialMargin;\n            cache.decreaseMarginInUsd = cache.position.initialMarginInUsd;\n            cache.unHoldPoolAmount = cache.position.holdPoolAmount;\n            (cache.settledBorrowingFee, cache.settledBorrowingFeeInUsd) = FeeQueryProcess.calcBorrowingFee(\n                decreaseQty,\n                position\n            );\n            cache.settledFundingFee = cache.position.positionFee.realizedFundingFee;\n            cache.settledFundingFeeInUsd = cache.position.positionFee.realizedFundingFeeInUsd;\n\n            cache.closeFeeInUsd = cache.position.positionFee.closeFeeInUsd;\n            cache.closeFee = FeeQueryProcess.calcCloseFee(tokenDecimals, cache.closeFeeInUsd, tokenPrice.toUint256());\n\n            if (isLiquidation) {\n                cache.settledMargin = isCrossMargin\n                    ? CalUtils.usdToTokenInt(\n                        cache.position.initialMarginInUsd.toInt256() -\n                            _getPosFee(cache) +\n                            pnlInUsd -\n                            PositionQueryProcess.getPositionMM(cache.position).toInt256(),\n                        TokenUtils.decimals(cache.position.marginToken),\n                        tokenPrice\n                    )\n                    : int256(0);\n                cache.recordPnlToken = cache.settledMargin - cache.decreaseMargin.toInt256();\n                cache.poolPnlToken =\n                    cache.decreaseMargin.toInt256() -\n                    CalUtils.usdToTokenInt(\n                        cache.position.initialMarginInUsd.toInt256() + pnlInUsd,\n                        TokenUtils.decimals(cache.position.marginToken),\n                        tokenPrice\n                    );\n            } else {\n                cache.settledMargin = CalUtils.usdToTokenInt(\n                    cache.position.initialMarginInUsd.toInt256() - _getPosFee(cache) + pnlInUsd,\n                    TokenUtils.decimals(cache.position.marginToken),\n                    tokenPrice\n                );\n                cache.recordPnlToken = cache.settledMargin - cache.decreaseMargin.toInt256();\n                cache.poolPnlToken = cache.recordPnlToken > 0\n                    ? -cache.recordPnlToken - cache.closeFee.toInt256()\n                    : -cache.recordPnlToken;\n            }\n            cache.realizedPnl = pnlInUsd;\n        } else {\n            cache.decreaseMargin = cache.position.initialMargin.mul(decreaseQty).div(cache.position.qty);\n            cache.unHoldPoolAmount = cache.position.holdPoolAmount.mul(decreaseQty).div(cache.position.qty);\n            cache.closeFeeInUsd = CalUtils.mulRate(decreaseQty, closeFeeRate);\n            (cache.settledBorrowingFee, cache.settledBorrowingFeeInUsd) = FeeQueryProcess.calcBorrowingFee(\n                decreaseQty,\n                position\n            );\n            cache.settledFundingFee = cache.position.positionFee.realizedFundingFee.mul(decreaseQty.toInt256()).div(\n                cache.position.qty.toInt256()\n            );\n            cache.settledFundingFeeInUsd = cache\n                .position\n                .positionFee\n                .realizedFundingFeeInUsd\n                .mul(decreaseQty.toInt256())\n                .div(cache.position.qty.toInt256());\n\n            if (cache.closeFeeInUsd > cache.position.positionFee.closeFeeInUsd) {\n                cache.closeFeeInUsd = cache.position.positionFee.closeFeeInUsd;\n            }\n            cache.closeFee = FeeQueryProcess.calcCloseFee(tokenDecimals, cache.closeFeeInUsd, tokenPrice.toUint256());\n\n            cache.settledMargin = CalUtils.usdToTokenInt(\n                (cache.position.initialMarginInUsd.toInt256() - _getPosFee(cache) + pnlInUsd)\n                    .mul(decreaseQty.toInt256())\n                    .div(cache.position.qty.toInt256()),\n                TokenUtils.decimals(cache.position.marginToken),\n                tokenPrice\n            );\n            cache.recordPnlToken = cache.settledMargin - cache.decreaseMargin.toInt256();\n            cache.poolPnlToken = cache.recordPnlToken > 0\n                ? -cache.recordPnlToken - cache.closeFee.toInt256()\n                : -cache.recordPnlToken;\n            cache.decreaseMarginInUsd = cache.position.initialMarginInUsd.mul(decreaseQty).div(position.qty);\n            cache.realizedPnl = pnlInUsd.mul(decreaseQty.toInt256()).div(position.qty.toInt256());\n        }\n\n        cache.decreaseMarginInUsdFromBalance = (cache.decreaseMarginInUsd + position.initialMarginInUsdFromBalance >\n            position.initialMarginInUsd)\n            ? cache.decreaseMarginInUsd + position.initialMarginInUsdFromBalance - position.initialMarginInUsd\n            : 0;\n\n        return cache;\n    }\n\n    function _settleAccount(\n        Account.Props storage accountProps,\n        Position.Props storage position,\n        DecreasePositionCache memory cache\n    ) internal returns (uint256 addLiability) {\n        if (position.isCrossMargin) {\n            accountProps.subTokenWithLiability(cache.position.marginToken, cache.closeFee);\n            accountProps.unUseToken(cache.position.marginToken, cache.decreaseMargin);\n            address portfolioVault = IVault(address(this)).getPortfolioVaultAddress();\n            if (cache.recordPnlToken >= 0) {\n                accountProps.addToken(\n                    cache.position.marginToken,\n                    cache.recordPnlToken.toUint256(),\n                    !cache.isLiquidation\n                );\n                VaultProcess.transferOut(\n                    cache.position.isLong ? cache.stakeToken : CommonData.getStakeUsdToken(),\n                    cache.position.marginToken,\n                    portfolioVault,\n                    cache.position.isLong\n                        ? cache.recordPnlToken.toUint256()\n                        : cache.recordPnlToken.toUint256() + cache.closeFee,\n                    true\n                );\n            } else if (cache.recordPnlToken < 0) {\n                addLiability = accountProps.subTokenWithLiability(\n                    cache.position.marginToken,\n                    (-cache.recordPnlToken).toUint256()\n                );\n                VaultProcess.transferOut(\n                    portfolioVault,\n                    cache.position.marginToken,\n                    cache.stakeToken,\n                    (-cache.recordPnlToken).toUint256() - addLiability,\n                    true\n                );\n            }\n            if (!cache.isLiquidation) {\n                int256 changeToken = (\n                    cache.decreaseMarginInUsdFromBalance.mul(cache.position.initialMargin).div(\n                        cache.position.initialMarginInUsd\n                    )\n                ).toInt256() +\n                    cache.settledMargin -\n                    cache.decreaseMargin.toInt256();\n                updatePositionFromBalanceMargin(position, changeToken);\n            }\n        } else {\n            if (cache.isLiquidation) {\n                return 0;\n            }\n            if (cache.recordPnlToken < 0 || (cache.recordPnlToken >= 0 && cache.position.isLong)) {\n                VaultProcess.transferOut(\n                    cache.stakeToken,\n                    cache.position.marginToken,\n                    accountProps.owner,\n                    cache.settledMargin.toUint256(),\n                    true\n                );\n            } else {\n                VaultProcess.transferOut(\n                    CommonData.getStakeUsdToken(),\n                    cache.position.marginToken,\n                    cache.stakeToken,\n                    cache.recordPnlToken.toUint256() + cache.closeFee,\n                    true\n                );\n                VaultProcess.transferOut(\n                    cache.stakeToken,\n                    cache.position.marginToken,\n                    accountProps.owner,\n                    cache.settledMargin.toUint256(),\n                    true\n                );\n            }\n        }\n    }\n\n    function updatePositionFromBalanceMargin(\n        Position.Props storage position,\n        int256 amount\n    ) public returns (uint256 addAmount) {\n        if (position.initialMarginInUsd == position.initialMarginInUsdFromBalance || amount == 0) {\n            addAmount = 0;\n            return 0;\n        }\n        if (amount > 0) {\n            uint256 borrowMargin = (position.initialMarginInUsd - position.initialMarginInUsdFromBalance)\n                .mul(position.initialMargin)\n                .div(position.initialMarginInUsd);\n            addAmount = amount.toUint256().min(borrowMargin);\n            position.initialMarginInUsdFromBalance += addAmount.mul(position.initialMarginInUsd).div(\n                position.initialMargin\n            );\n        } else {\n            uint256 addBorrowMarginInUsd = (-amount).toUint256().mul(position.initialMarginInUsd).div(\n                position.initialMargin\n            );\n            position.initialMarginInUsdFromBalance = position.initialMarginInUsdFromBalance <= addBorrowMarginInUsd\n                ? 0\n                : position.initialMarginInUsdFromBalance - addBorrowMarginInUsd;\n        }\n    }\n\n    function _getPosFee(DecreasePositionCache memory cache) internal pure returns (int256) {\n        return\n            cache.closeFeeInUsd.toInt256() + cache.settledBorrowingFeeInUsd.toInt256() + cache.settledFundingFeeInUsd;\n    }\n}\n"
    },
    "contracts/process/FeeProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IFee.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/FeeRewards.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"./MarketProcess.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary FeeProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedMath for int256;\n    using SignedSafeMath for int256;\n    using SafeERC20 for IERC20;\n    using Config for Config.Props;\n    using Position for Position.Props;\n    using UsdPool for UsdPool.Props;\n    using LpPool for LpPool.Props;\n    using StakingAccount for StakingAccount.Props;\n    using FeeRewards for FeeRewards.MarketRewards;\n    using FeeRewards for FeeRewards.StakingRewards;\n\n    bytes32 public constant FEE_MINT = keccak256(abi.encode(\"FEE_MINT\"));\n\n    bytes32 public constant FEE_REDEEM = keccak256(abi.encode(\"FEE_REDEEM\"));\n\n    bytes32 public constant FEE_OPEN_POSITION = keccak256(abi.encode(\"FEE_OPEN_POSITION\"));\n\n    bytes32 public constant FEE_CLOSE_POSITION = keccak256(abi.encode(\"FEE_CLOSE_POSITION\"));\n\n    bytes32 public constant FEE_LIQUIDATION = keccak256(abi.encode(\"FEE_LIQUIDATION\"));\n\n    bytes32 public constant FEE_BORROWING = keccak256(abi.encode(\"FEE_BORROWING\"));\n\n    bytes32 public constant FEE_FUNDING = keccak256(abi.encode(\"FEE_FUNDING\"));\n\n    struct ChargeMintOrRedeemFeeEventParams {\n        address stakeToken;\n        address feeToken;\n        address account;\n        bytes32 feeType;\n        uint256 fee;\n    }\n\n    struct ChargeFeeCache {\n        uint256 ratioToStakingRewards;\n        uint256 ratioToPoolRewards;\n        uint256 feeToStakingRewards;\n        uint256 feeToMarketRewards;\n        uint256 feeToPoolRewards;\n        uint256 feeToDaoRewards;\n        address stakeToken;\n    }\n\n    event ChargeTradingFeeEvent(bytes32 positionKey, bytes32 symbol, bytes32 feeType, uint256 fee);\n\n    event ChargeMintOrRedeemFeeEvent(ChargeMintOrRedeemFeeEventParams params);\n\n    event ChargeBorrowingFeeEvent(\n        bool isCrossMargin,\n        address stakeToken,\n        address token,\n        address account,\n        bytes32 feeType,\n        uint256 fee\n    );\n\n    function updateBorrowingFee(Position.Props storage position, address stakeToken) public {\n        uint256 cumulativeBorrowingFeePerToken = MarketQueryProcess.getCumulativeBorrowingFeePerToken(\n            stakeToken,\n            position.isLong,\n            position.marginToken\n        );\n        uint256 realizedBorrowingFeeDelta = CalUtils.mulSmallRate(\n            CalUtils.mulRate(position.initialMargin, position.leverage - CalUtils.RATE_PRECISION),\n            cumulativeBorrowingFeePerToken - position.positionFee.openBorrowingFeePerToken\n        );\n        position.positionFee.realizedBorrowingFee += realizedBorrowingFeeDelta;\n        position.positionFee.realizedBorrowingFeeInUsd += CalUtils.tokenToUsd(\n            realizedBorrowingFeeDelta,\n            TokenUtils.decimals(position.marginToken),\n            OracleProcess.getLatestUsdUintPrice(position.marginToken, position.isLong)\n        );\n        position.positionFee.openBorrowingFeePerToken = cumulativeBorrowingFeePerToken;\n        MarketProcess.updateTotalBorrowingFee(\n            stakeToken,\n            position.isLong,\n            position.marginToken,\n            0,\n            realizedBorrowingFeeDelta.toInt256()\n        );\n    }\n\n    function updateFundingFee(Position.Props storage position) public {\n        int256 fundingFeePerQty = MarketQueryProcess.getFundingFeePerQty(position.symbol, position.isLong);\n        int256 realizedFundingFeeDelta = CalUtils.mulIntSmallRate(\n            position.qty.toInt256(),\n            (fundingFeePerQty - position.positionFee.openFundingFeePerQty)\n        );\n        if (position.isLong) {\n            position.positionFee.realizedFundingFee += realizedFundingFeeDelta;\n            position.positionFee.realizedFundingFeeInUsd += CalUtils.tokenToUsdInt(\n                realizedFundingFeeDelta,\n                TokenUtils.decimals(position.marginToken),\n                OracleProcess.getLatestUsdPrice(position.marginToken, position.isLong)\n            );\n        } else {\n            position.positionFee.realizedFundingFeeInUsd += realizedFundingFeeDelta;\n            position.positionFee.realizedFundingFee += CalUtils.usdToTokenInt(\n                realizedFundingFeeDelta,\n                TokenUtils.decimals(position.marginToken),\n                OracleProcess.getLatestUsdPrice(position.marginToken, position.isLong)\n            );\n        }\n        consoleInt(\"position.positionFee.realizedFundingFee\", position.positionFee.realizedFundingFee);\n        consoleInt(\"position.positionFee.realizedFundingFeeInUsd\", position.positionFee.realizedFundingFeeInUsd);\n        position.positionFee.openFundingFeePerQty = fundingFeePerQty;\n        MarketProcess.updateMarketFundingFee(\n            position.symbol,\n            realizedFundingFeeDelta,\n            position.isLong,\n            true,\n            position.marginToken\n        );\n    }\n\n    function consoleInt(string memory code, int256 value) internal pure {\n        if (value > 0) {\n            console.log(code, value.toUint256());\n        } else {\n            console.log(\"-\", code, (-value).toUint256());\n        }\n    }\n\n    function chargeTradingFee(\n        uint256 fee,\n        bytes32 symbol,\n        bytes32 feeType,\n        address feeToken,\n        Position.Props memory position\n    ) internal {\n        FeeRewards.StakingRewards storage stakingRewardsProps = FeeRewards.loadStakingRewards();\n        FeeRewards.MarketRewards storage marketTradingRewardsProps = FeeRewards.loadMarketTradingRewards(symbol);\n        FeeRewards.StakingRewards storage daoRewardsProps = FeeRewards.loadDaoRewards();\n        Config.Props storage configProps = Config.load();\n        ChargeFeeCache memory cache;\n        cache.stakeToken = Symbol.load(symbol).stakeToken;\n        cache.feeToStakingRewards = CalUtils.mulRate(fee, configProps.tradeConfig.tradingFeeStakingRewardsRatio);\n        cache.feeToMarketRewards = CalUtils.mulRate(fee, configProps.tradeConfig.tradingFeePoolRewardsRatio);\n        cache.feeToDaoRewards = fee.sub(cache.feeToStakingRewards).sub(cache.feeToMarketRewards);\n\n        marketTradingRewardsProps.addFeeAmount(feeToken, cache.feeToMarketRewards);\n        stakingRewardsProps.addFeeAmount(cache.stakeToken, feeToken, cache.feeToStakingRewards);\n        daoRewardsProps.addFeeAmount(cache.stakeToken, feeToken, cache.feeToDaoRewards);\n        if (position.isCrossMargin) {\n            marketTradingRewardsProps.addUnsettleFeeAmount(feeToken, cache.feeToPoolRewards);\n            stakingRewardsProps.addUnsettleFeeAmount(cache.stakeToken, feeToken, cache.feeToStakingRewards);\n            daoRewardsProps.addUnsettleFeeAmount(cache.stakeToken, feeToken, cache.feeToDaoRewards);\n        }\n        emit ChargeTradingFeeEvent(position.key, symbol, feeType, fee);\n    }\n\n    function chargeMintOrRedeemFee(\n        uint256 fee,\n        address stakeToken,\n        address feeToken,\n        address account,\n        bytes32 feeType,\n        bool isCollateral\n    ) public {\n        ChargeFeeCache memory cache;\n        Config.Props storage configProps = Config.load();\n        if (feeType == FEE_MINT) {\n            cache.ratioToStakingRewards = configProps.stakeConfig.mintFeeStakingRewardsRatio;\n            cache.ratioToPoolRewards = configProps.stakeConfig.mintFeePoolRewardsRatio;\n        } else if (feeType == FEE_REDEEM) {\n            cache.ratioToStakingRewards = configProps.stakeConfig.redeemFeeStakingRewardsRatio;\n            cache.ratioToPoolRewards = configProps.stakeConfig.redeemFeePoolRewardsRatio;\n        }\n        cache.feeToStakingRewards = CalUtils.mulRate(fee, cache.ratioToStakingRewards);\n        cache.feeToPoolRewards = CalUtils.mulRate(fee, cache.ratioToPoolRewards);\n        cache.feeToDaoRewards = fee.sub(cache.feeToStakingRewards).sub(cache.feeToPoolRewards);\n        FeeRewards.StakingRewards storage stakingRewardsProps = FeeRewards.loadStakingRewards();\n        FeeRewards.MarketRewards storage poolRewardsProps = FeeRewards.loadPoolRewards(stakeToken);\n        FeeRewards.StakingRewards storage daoRewardsProps = FeeRewards.loadDaoRewards();\n        if (isCollateral) {\n            stakingRewardsProps.addCollateralFeeAmount(stakeToken, feeToken, cache.feeToStakingRewards);\n            poolRewardsProps.addCollateralFeeAmount(feeToken, cache.feeToPoolRewards);\n            daoRewardsProps.addCollateralFeeAmount(stakeToken, feeToken, cache.feeToDaoRewards);\n        } else {\n            stakingRewardsProps.addFeeAmount(stakeToken, feeToken, cache.feeToStakingRewards);\n            poolRewardsProps.addFeeAmount(feeToken, cache.feeToPoolRewards);\n            daoRewardsProps.addFeeAmount(stakeToken, feeToken, cache.feeToDaoRewards);\n        }\n\n        ChargeMintOrRedeemFeeEventParams memory params = ChargeMintOrRedeemFeeEventParams({\n            stakeToken: stakeToken,\n            feeToken: feeToken,\n            account: account,\n            feeType: feeType,\n            fee: fee\n        });\n\n        emit ChargeMintOrRedeemFeeEvent(params);\n    }\n\n    function chargeBorrowingFee(\n        bool isCrossMargin,\n        uint256 fee,\n        address stakeToken,\n        address feeToken,\n        address account,\n        bytes32 feeType\n    ) public {\n        FeeRewards.StakingRewards storage stakingRewardsProps = FeeRewards.loadStakingRewards();\n        FeeRewards.MarketRewards storage poolRewardsProps = FeeRewards.loadPoolRewards(stakeToken);\n        FeeRewards.StakingRewards storage daoRewardsProps = FeeRewards.loadDaoRewards();\n\n        Config.Props storage configProps = Config.load();\n        ChargeFeeCache memory cache;\n        cache.feeToStakingRewards = CalUtils.mulRate(fee, configProps.tradeConfig.borrowingFeeStakingRewardsRatio);\n        cache.feeToPoolRewards = CalUtils.mulRate(fee, configProps.tradeConfig.borrowingFeePoolRewardsRatio);\n        cache.feeToDaoRewards = fee.sub(cache.feeToStakingRewards).sub(cache.feeToPoolRewards);\n\n        stakingRewardsProps.addFeeAmount(stakeToken, feeToken, cache.feeToStakingRewards);\n        poolRewardsProps.addFeeAmount(feeToken, cache.feeToPoolRewards);\n        daoRewardsProps.addFeeAmount(stakeToken, feeToken, cache.feeToDaoRewards);\n\n        if (isCrossMargin) {\n            stakingRewardsProps.addUnsettleFeeAmount(stakeToken, feeToken, cache.feeToStakingRewards);\n            poolRewardsProps.addUnsettleFeeAmount(feeToken, cache.feeToPoolRewards);\n            daoRewardsProps.addUnsettleFeeAmount(stakeToken, feeToken, cache.feeToDaoRewards);\n        }\n\n        emit ChargeBorrowingFeeEvent(isCrossMargin, stakeToken, feeToken, account, feeType, fee);\n    }\n}\n"
    },
    "contracts/process/FeeQueryProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IFee.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/FeeRewards.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../utils/CalUtils.sol\";\n\nlibrary FeeQueryProcess {\n    using SafeERC20 for IERC20;\n    using Config for Config.Props;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using FeeRewards for FeeRewards.MarketRewards;\n    using FeeRewards for FeeRewards.StakingRewards;\n    using StakingAccount for StakingAccount.Props;\n\n\n    function calcOpenFee(uint256 orderMargin, uint256 leverage, bytes32 symbol) public view returns (uint256) {\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(symbol);\n        uint256 leverageMargin = CalUtils.mulRate(orderMargin, leverage);\n        return CalUtils.mulRate(leverageMargin, symbolConfig.openFeeRate);\n    }\n\n    function calcCloseFee(uint8 tokenDecimals, uint256 feeInUsd, uint256 tokenPrice) public pure returns (uint256) {\n        return CalUtils.usdToToken(feeInUsd, tokenDecimals, tokenPrice);\n    }\n\n    function calcMintOrRedeemFee(uint256 tokenAmount, uint256 feeRate) public pure returns (uint256) {\n        return CalUtils.mulRate(tokenAmount, feeRate);\n    }\n\n    function calcBorrowingFee(\n        uint256 decreaseQty,\n        Position.Props memory position\n    ) public pure returns (uint256 fee, uint256 feeInUsd) {\n        if (decreaseQty == position.qty) {\n            return (position.positionFee.realizedBorrowingFee, position.positionFee.realizedBorrowingFeeInUsd);\n        }\n        return (\n            position.positionFee.realizedBorrowingFee.mul(decreaseQty).div(position.qty),\n            position.positionFee.realizedBorrowingFeeInUsd.mul(decreaseQty).div(position.qty)\n        );\n    }\n\n    function getPoolTokenFeeAmount(address stakeToken, address token) external view returns (uint256) {\n        FeeRewards.MarketRewards storage poolRewardsProps = FeeRewards.loadPoolRewards(stakeToken);\n        return poolRewardsProps.getFeeAmount(token);\n    }\n\n    function getCumulativeRewardsPerStakeToken(address stakeToken) external view returns (uint256) {\n        FeeRewards.MarketRewards storage poolRewardsProps = FeeRewards.loadPoolRewards(stakeToken);\n        return poolRewardsProps.getCumulativeRewardsPerStakeToken();\n    }\n\n    function getMarketTokenFeeAmount(bytes32 symbol, address token) external view returns (uint256) {\n        FeeRewards.MarketRewards storage marketTradingRewardsProps = FeeRewards.loadMarketTradingRewards(symbol);\n        return marketTradingRewardsProps.getFeeAmount(token);\n    }\n\n    function getStakingTokenFee(address stakeToken, address token) external view returns(uint256) {\n        FeeRewards.StakingRewards storage stakingRewards = FeeRewards.loadStakingRewards();\n        return stakingRewards.getFeeAmount(stakeToken, token);\n    }\n\n    function getDaoTokenFee(address stakeToken, address token) external view returns(uint256) {\n        FeeRewards.StakingRewards storage daoRewards = FeeRewards.loadDaoRewards();\n        return daoRewards.getFeeAmount(stakeToken, token);\n    }\n\n    function getAccountFeeRewards(address account) external view returns(IFee.AccountFeeRewards[] memory) {\n        StakingAccount.Props storage stakingAccount = StakingAccount.load(account);\n        address[] memory stakeTokens = stakingAccount.getStakeTokens();\n        IFee.AccountFeeRewards[] memory rewards = new IFee.AccountFeeRewards[](stakeTokens.length);\n        for (uint256 i; i < stakeTokens.length; i++) {\n            FeeRewards.MarketRewards storage feeProps = FeeRewards.loadPoolRewards(stakeTokens[i]);\n            StakingAccount.FeeRewards storage accountFeeRewards = stakingAccount.getFeeRewards(stakeTokens[i]);\n            rewards[i].stakeToken = stakeTokens[i];\n            if (CommonData.getStakeUsdToken() != stakeTokens[i]) {\n                LpPool.Props storage pool = LpPool.load(stakeTokens[i]);\n                rewards[i].token = pool.baseToken;\n            }\n            uint256 accountStakeTokens = IERC20(stakeTokens[i]).balanceOf(account);\n            if (\n                accountFeeRewards.openRewardsPerStakeToken > 0 &&\n                feeProps.getCumulativeRewardsPerStakeToken() - accountFeeRewards.openRewardsPerStakeToken >\n                feeProps.getPoolRewardsPerStakeTokenDeltaLimit()\n            ) {\n                rewards[i].rewards = CalUtils.mulSmallRate(\n                    feeProps.getCumulativeRewardsPerStakeToken() - accountFeeRewards.openRewardsPerStakeToken,\n                    accountStakeTokens\n                );\n            }\n        }\n        return rewards;\n    }\n}\n"
    },
    "contracts/process/FeeRewardsProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IFee.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/FeeRewards.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/ClaimRewards.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"./VaultProcess.sol\";\nimport \"./LpPoolQueryProcess.sol\";\nimport \"./GasProcess.sol\";\nimport \"./AssetsProcess.sol\";\n\nlibrary FeeRewardsProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeERC20 for IERC20;\n    using Config for Config.Props;\n    using UsdPool for UsdPool.Props;\n    using LpPool for LpPool.Props;\n    using LpPoolQueryProcess for LpPool.Props;\n    using LpPoolQueryProcess for UsdPool.Props;\n    using StakingAccount for StakingAccount.Props;\n    using FeeRewards for FeeRewards.MarketRewards;\n    using FeeRewards for FeeRewards.StakingRewards;\n\n    struct TidyTradingRewardsCache {\n        uint256 totalFeeValueInUsd;\n        uint256 usdPoolShouldTakeInUsd;\n        address maxAmountStableToken;\n        uint256 usdTokenNeedAmount;\n        uint256 baseTokenSwapAmount;\n    }\n\n    function distributeFeeRewards(uint256 interval) external {\n        bytes32[] memory symbols = CommonData.getAllSymbols();\n        address[] memory stakeTokens = new address[](symbols.length);\n        _updateStableTokenRewardsToUsdPool();\n        for (uint256 i; i < symbols.length; i++) {\n            stakeTokens[i] = Symbol.load(symbols[i]).stakeToken;\n            _tidyUnsettleRewards(FeeRewards.loadMarketTradingRewards(symbols[i]), stakeTokens[i]);\n            _tidyUnsettleRewards(FeeRewards.loadPoolRewards(stakeTokens[i]), stakeTokens[i]);\n            _updateBaseTokenRewardsToLpPool(LpPool.load(stakeTokens[i]));\n            _tidyTradingRewards(symbols[i], stakeTokens[i]);\n            _tidyMintAndRedeemRewards(stakeTokens[i]);\n            _updatePoolApr(stakeTokens[i], interval);\n        }\n        _tidyUnsettleRewards(FeeRewards.loadPoolRewards(CommonData.getStakeUsdToken()), CommonData.getStakeUsdToken());\n        _updatePoolApr(CommonData.getStakeUsdToken(), interval);\n        for (uint256 i; i < stakeTokens.length; i++) {\n            _distributePoolRewards(stakeTokens[i]);\n        }\n        _distributeUsdPoolRewards();\n    }\n\n    function updateAccountFeeRewards(address account, address stakeToken) public {\n        StakingAccount.FeeRewards storage accountFeeRewards = StakingAccount.load(account).getFeeRewards(stakeToken);\n        FeeRewards.MarketRewards storage feeProps = FeeRewards.loadPoolRewards(stakeToken);\n        uint256 stakeTokens = IERC20(stakeToken).balanceOf(account);\n        if (\n            stakeTokens > 0 &&\n            accountFeeRewards.openRewardsPerStakeToken >= 0 &&\n            feeProps.getCumulativeRewardsPerStakeToken() - accountFeeRewards.openRewardsPerStakeToken >\n            feeProps.getPoolRewardsPerStakeTokenDeltaLimit()\n        ) {\n            accountFeeRewards.realisedRewardsTokenAmount += CalUtils.mulSmallRate(\n                feeProps.getCumulativeRewardsPerStakeToken() - accountFeeRewards.openRewardsPerStakeToken,\n                stakeTokens\n            );\n        }\n        if (stakeTokens > 0) {\n            accountFeeRewards.openRewardsPerStakeToken = feeProps.getCumulativeRewardsPerStakeToken();\n        } else {\n            accountFeeRewards.openRewardsPerStakeToken = 0;\n        }\n    }\n\n    function _tidyUnsettleRewards(FeeRewards.MarketRewards storage marketRewards, address stakeToken) internal {\n        address[] memory tokens = marketRewards.getFeeTokens();\n        for (uint256 i; i < tokens.length; i++) {\n            uint256 unsettleAmount = marketRewards.getUnsettleFeeAmount(tokens[i]);\n            if (unsettleAmount == 0) {\n                continue;\n            }\n            bool transferSuccess = VaultProcess.transferOut(\n                IVault(address(this)).getPortfolioVaultAddress(),\n                tokens[i],\n                stakeToken,\n                unsettleAmount\n            );\n            if (transferSuccess) {\n                marketRewards.subUnsettleFeeAmount(tokens[i], unsettleAmount);\n            }\n        }\n    }\n\n    function _tidyTradingRewards(bytes32 symbol, address stakeToken) internal {\n        FeeRewards.MarketRewards storage marketTradingRewardsProps = FeeRewards.loadMarketTradingRewards(symbol);\n        TidyTradingRewardsCache memory tidyCache;\n        tidyCache.totalFeeValueInUsd = _getTotalFeeValueInUsd(marketTradingRewardsProps);\n        if (tidyCache.totalFeeValueInUsd == 0) {\n            return;\n        }\n        Config.Props storage config = Config.load();\n        tidyCache.usdPoolShouldTakeInUsd = CalUtils.mulRate(\n            tidyCache.totalFeeValueInUsd,\n            config.tradeConfig.tradingFeeUsdPoolRewardsRatio\n        );\n        UsdPool.Props storage usdPool = UsdPool.load();\n        address[] memory stableTokens = usdPool.getStableTokens();\n        FeeRewards.MarketRewards storage usdPoolRewards = FeeRewards.loadPoolRewards(CommonData.getStakeUsdToken());\n        for (uint256 i; i < stableTokens.length; i++) {\n            uint256 transferTokenAmount = marketTradingRewardsProps.getFeeAmount(stableTokens[i]);\n            if (transferTokenAmount == 0) {\n                continue;\n            }\n            uint256 usdToken = CalUtils.usdToToken(\n                tidyCache.usdPoolShouldTakeInUsd,\n                TokenUtils.decimals(stableTokens[i]),\n                OracleProcess.getLatestUsdUintPrice(stableTokens[i], true)\n            );\n            if (transferTokenAmount < usdToken) {\n                tidyCache.usdPoolShouldTakeInUsd -= CalUtils.tokenToUsd(\n                    transferTokenAmount,\n                    TokenUtils.decimals(stableTokens[i]),\n                    OracleProcess.getLatestUsdUintPrice(stableTokens[i], true)\n                );\n            } else {\n                transferTokenAmount = usdToken;\n                tidyCache.usdPoolShouldTakeInUsd = 0;\n            }\n            usdPool.addStableToken(stableTokens[i], transferTokenAmount);\n            usdPoolRewards.addFeeAmount(stableTokens[i], transferTokenAmount);\n            marketTradingRewardsProps.subFeeAmount(stableTokens[i], transferTokenAmount);\n\n            if (tidyCache.usdPoolShouldTakeInUsd == 0) {\n                break;\n            }\n        }\n        LpPool.Props storage lpPoolProps = LpPool.load(stakeToken);\n        if (tidyCache.usdPoolShouldTakeInUsd > 0) {\n            tidyCache.maxAmountStableToken = usdPool.getMaxAmountStableToken();\n            tidyCache.usdTokenNeedAmount = CalUtils.usdToToken(\n                tidyCache.usdPoolShouldTakeInUsd,\n                TokenUtils.decimals(tidyCache.maxAmountStableToken),\n                OracleProcess.getLatestUsdUintPrice(tidyCache.maxAmountStableToken, false)\n            );\n            tidyCache.baseTokenSwapAmount = CalUtils.usdToToken(\n                tidyCache.usdPoolShouldTakeInUsd,\n                TokenUtils.decimals(lpPoolProps.baseToken),\n                OracleProcess.getLatestUsdUintPrice(lpPoolProps.baseToken, true)\n            );\n            tidyCache.baseTokenSwapAmount += CalUtils.mulRate(\n                tidyCache.baseTokenSwapAmount,\n                config.tradeConfig.swapSlipperTokenFactor\n            );\n            usdPool.addUnsettleStableToken(tidyCache.maxAmountStableToken, tidyCache.usdTokenNeedAmount);\n            lpPoolProps.addLossStableToken(tidyCache.maxAmountStableToken, tidyCache.usdTokenNeedAmount);\n            lpPoolProps.addBaseToken(tidyCache.baseTokenSwapAmount);\n            marketTradingRewardsProps.subFeeAmount(lpPoolProps.baseToken, tidyCache.baseTokenSwapAmount);\n            usdPoolRewards.addFeeAmount(tidyCache.maxAmountStableToken, tidyCache.usdTokenNeedAmount);\n        }\n        _updateLpPoolTradingRewards(marketTradingRewardsProps, lpPoolProps, config, stableTokens);\n    }\n\n    function _tidyMintAndRedeemRewards(address stakeToken) internal {\n        LpPool.Props storage lpPoolProps = LpPool.load(stakeToken);\n        FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(lpPoolProps.stakeToken);\n        address[] memory collateralTokens = poolRewards.getCollateralFeeTokens();\n        for (uint256 i; i < collateralTokens.length; i++) {\n            uint256 collateralFeeAmount = poolRewards.getCollateralFeeAmount(collateralTokens[i]);\n            if (collateralFeeAmount == 0) {\n                continue;\n            }\n            Config.StakeCollateralConfig memory collateralConfig = lpPoolProps.getStakeCollateralConfig(\n                collateralTokens[i]\n            );\n            uint256 toBaseTokenAmount = CalUtils.mulRate(collateralFeeAmount, collateralConfig.discount);\n            lpPoolProps.addCollateralBaseToken(toBaseTokenAmount, collateralTokens[i], collateralFeeAmount);\n            lpPoolProps.subBaseToken(toBaseTokenAmount);\n            poolRewards.subCollateralFeeAmount(collateralTokens[i], collateralFeeAmount);\n            poolRewards.addFeeAmount(lpPoolProps.baseToken, toBaseTokenAmount);\n        }\n    }\n\n    function _updatePoolApr(address stakeToken, uint256 interval) internal {\n        if (stakeToken == CommonData.getStakeUsdToken()) {\n            UsdPool.Props storage pool = UsdPool.load();\n            uint256 poolValue = pool.getUsdPoolValue();\n            if (poolValue == 0) {\n                return;\n            }\n            FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(stakeToken);\n            uint256 feeValue = _getTotalFeeValueInUsd(poolRewards);\n            pool.apr = feeValue.mul(24 * 60 * 365 * CalUtils.RATE_PRECISION).div(poolValue).div(interval);\n        } else {\n            LpPool.Props storage pool = LpPool.load(stakeToken);\n            uint256 poolValue = pool.getPoolValue();\n            if (poolValue == 0) {\n                return;\n            }\n            FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(stakeToken);\n            uint256 feeValue = CalUtils.tokenToUsd(\n                poolRewards.getFeeAmount(pool.baseToken),\n                TokenUtils.decimals(pool.baseToken),\n                OracleProcess.getLatestUsdUintPrice(pool.baseToken, false)\n            );\n            pool.apr = feeValue.mul(24 * 60 * 365 * CalUtils.RATE_PRECISION).div(poolValue).div(interval);\n        }\n    }\n\n    function _distributePoolRewards(address stakeToken) internal {\n        FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(stakeToken);\n        LpPool.Props storage pool = LpPool.load(stakeToken);\n        uint256 feeAmount = poolRewards.getFeeAmount(pool.baseToken);\n        if (feeAmount == 0) {\n            return;\n        }\n        uint256 totalSupply = TokenUtils.totalSupply(stakeToken);\n        if (totalSupply == 0) {\n            return;\n        }\n        uint256 poolRewardsPerStakeTokenDelta = CalUtils.divSmallRate(feeAmount, totalSupply);\n        poolRewards.cumulativeRewardsPerStakeToken += poolRewardsPerStakeTokenDelta;\n        poolRewards.setFeeAmountZero(pool.baseToken);\n        poolRewards.addLastRewardsPerStakeTokenDelta(\n            poolRewardsPerStakeTokenDelta,\n            Config.load().getStakeConfig().poolRewardsIntervalLimit\n        );\n    }\n\n    function _distributeUsdPoolRewards() internal {\n        address stakeToken = CommonData.getStakeUsdToken();\n        FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(stakeToken);\n        address[] memory feeTokens = poolRewards.getFeeTokens();\n        if (feeTokens.length == 0) {\n            return;\n        }\n        uint256 totalSupply = TokenUtils.totalSupply(stakeToken);\n        if (totalSupply == 0) {\n            return;\n        }\n        uint256 totalValue = _getTotalFeeValueInUsd(poolRewards);\n        if (totalValue == 0) {\n            return;\n        }\n        uint256 poolRewardsPerStakeTokenDelta = CalUtils.divSmallRate(totalValue, totalSupply);\n        poolRewards.cumulativeRewardsPerStakeToken += poolRewardsPerStakeTokenDelta;\n        poolRewards.addLastRewardsPerStakeTokenDelta(\n            poolRewardsPerStakeTokenDelta,\n            Config.load().getStakeConfig().poolRewardsIntervalLimit\n        );\n        for (uint256 i; i < feeTokens.length; i++) {\n            poolRewards.setFeeAmountZero(feeTokens[i]);\n        }\n    }\n\n    function _updateLpPoolTradingRewards(\n        FeeRewards.MarketRewards storage marketTradingRewardsProps,\n        LpPool.Props storage lpPoolProps,\n        Config.Props storage config,\n        address[] memory stableTokens\n    ) internal {\n        FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(lpPoolProps.stakeToken);\n        uint256 feeAmount = marketTradingRewardsProps.getFeeAmount(lpPoolProps.baseToken);\n        if (feeAmount > 0) {\n            lpPoolProps.addBaseToken(feeAmount);\n            poolRewards.addFeeAmount(lpPoolProps.baseToken, feeAmount);\n            marketTradingRewardsProps.subFeeAmount(lpPoolProps.baseToken, feeAmount);\n        }\n        uint8 baseTokenDecimals = TokenUtils.decimals(lpPoolProps.baseToken);\n        uint256 baseTokenPrice = OracleProcess.getLatestUsdUintPrice(lpPoolProps.baseToken, false);\n        for (uint256 i; i < stableTokens.length; i++) {\n            feeAmount = marketTradingRewardsProps.getFeeAmount(stableTokens[i]);\n            if (feeAmount == 0) {\n                continue;\n            }\n            uint256 toBaseTokenAmount = CalUtils.tokenToToken(\n                feeAmount,\n                TokenUtils.decimals(stableTokens[i]),\n                baseTokenDecimals,\n                OracleProcess.getLatestUsdUintPrice(stableTokens[i], true),\n                baseTokenPrice\n            );\n            toBaseTokenAmount -= CalUtils.mulRate(toBaseTokenAmount, config.tradeConfig.swapSlipperTokenFactor);\n            lpPoolProps.addStableToken(stableTokens[i], feeAmount);\n            marketTradingRewardsProps.setFeeAmountZero(stableTokens[i]);\n            poolRewards.addFeeAmount(lpPoolProps.baseToken, toBaseTokenAmount);\n        }\n    }\n\n    function _updateBaseTokenRewardsToLpPool(LpPool.Props storage lpPoolProps) internal {\n        FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(lpPoolProps.stakeToken);\n        uint256 baseTokenUnsettleFeeAmount = poolRewards.getUnsettleFeeAmount(lpPoolProps.baseToken);\n        if (baseTokenUnsettleFeeAmount > 0) {\n            lpPoolProps.addUnsettleBaseToken(baseTokenUnsettleFeeAmount.toInt256());\n        }\n        uint256 baseTokenFeeAmount = poolRewards.getFeeAmount(lpPoolProps.baseToken);\n        if (baseTokenFeeAmount > 0) {\n            lpPoolProps.addBaseToken(baseTokenFeeAmount - baseTokenUnsettleFeeAmount);\n        }\n        address[] memory collateralTokens = poolRewards.getCollateralFeeTokens();\n        for (uint256 i; i < collateralTokens.length; i++) {\n            uint256 collateralFeeAmount = poolRewards.getCollateralFeeAmount(collateralTokens[i]);\n            if (collateralFeeAmount > 0) {\n                Config.StakeCollateralConfig memory collateralConfig = lpPoolProps.getStakeCollateralConfig(\n                    collateralTokens[i]\n                );\n                uint256 collateralToBaseTokenAmount = CalUtils.mulRate(collateralFeeAmount, collateralConfig.discount);\n                lpPoolProps.addCollateralBaseToken(\n                    collateralToBaseTokenAmount,\n                    collateralTokens[i],\n                    collateralFeeAmount\n                );\n            }\n        }\n    }\n\n    function _updateStableTokenRewardsToUsdPool() internal {\n        UsdPool.Props storage usdPool = UsdPool.load();\n        FeeRewards.MarketRewards storage poolRewards = FeeRewards.loadPoolRewards(CommonData.getStakeUsdToken());\n        address[] memory stableTokens = usdPool.getStableTokens();\n        for (uint256 i; i < stableTokens.length; i++) {\n            uint256 unsettleFeeAmount = poolRewards.getUnsettleFeeAmount(stableTokens[i]);\n            if (unsettleFeeAmount > 0) {\n                usdPool.addUnsettleStableToken(stableTokens[i], unsettleFeeAmount);\n            }\n            uint256 feeAmount = poolRewards.getFeeAmount(stableTokens[i]);\n            if (feeAmount > 0) {\n                usdPool.addStableToken(stableTokens[i], feeAmount - unsettleFeeAmount);\n            }\n        }\n    }\n\n    function _getTotalFeeValueInUsd(FeeRewards.MarketRewards storage feeProps) internal view returns (uint256) {\n        uint256 totalFeeValue;\n        address[] memory allTokens = feeProps.getFeeTokens();\n        for (uint256 i; i < allTokens.length; i++) {\n            uint256 tokenValue = CalUtils.tokenToUsd(\n                feeProps.getFeeAmount(allTokens[i]),\n                TokenUtils.decimals(allTokens[i]),\n                OracleProcess.getLatestUsdUintPrice(allTokens[i], true)\n            );\n            totalFeeValue += tokenValue;\n        }\n        return totalFeeValue;\n    }\n}\n"
    },
    "contracts/process/GasProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"./VaultProcess.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary GasProcess {\n    struct PayExecutionFeeParams {\n        address from;\n        uint256 userExecutionFee;\n        uint256 startGas;\n        address keeper;\n        address account;\n    }\n\n    function processExecutionFee(PayExecutionFeeParams memory cache) external {\n        uint256 usedGas = cache.startGas - gasleft() / 63 - gasleft();\n        uint256 executionFee = usedGas * tx.gasprice;\n        uint256 refundFee;\n        uint256 lossFee;\n        if (executionFee > cache.userExecutionFee) {\n            executionFee = cache.userExecutionFee;\n            lossFee = executionFee - cache.userExecutionFee;\n        } else {\n            refundFee = cache.userExecutionFee - executionFee;\n        }\n        VaultProcess.transferOut(cache.from, Config.getWrapperToken(), address(this), cache.userExecutionFee);\n        VaultProcess.withdrawEther(cache.keeper, executionFee);\n        if (refundFee > 0) {\n            VaultProcess.withdrawEther(cache.account, refundFee);\n        }\n        if (lossFee > 0) {\n            CommonData.addLossExecutionFee(lossFee);\n        }\n    }\n\n    function addLossExecutionFee(uint256 startGas) external {\n        uint256 usedGas = startGas - gasleft() / 63 - gasleft();\n        uint256 executionFee = usedGas * tx.gasprice;\n        if (executionFee > 0) {\n            CommonData.addLossExecutionFee(executionFee);\n        }\n    }\n\n    function validateExecutionFeeLimit(uint256 executionFee, uint256 gasLimit) external view {\n        if (executionFee < gasLimit * tx.gasprice) {\n            console.log(\"gasPrice\", tx.gasprice, \"executionFee\", executionFee);\n            revert Errors.ExecutionFeeNotEnough();\n        }\n    }\n}\n"
    },
    "contracts/process/IncreasePositionProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/Order.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/Account.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"./MarketProcess.sol\";\nimport \"./LpPoolProcess.sol\";\nimport \"./FeeProcess.sol\";\nimport \"./AccountProcess.sol\";\nimport \"./FeeQueryProcess.sol\";\n\nlibrary IncreasePositionProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using Math for uint256;\n    using Config for Config.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n\n    struct IncreasePositionParams {\n        uint256 requestId;\n        address marginToken;\n        uint256 increaseMargin;\n        uint256 increaseMarginFromBalance;\n        uint256 marginTokenPrice;\n        uint256 indexTokenPrice;\n        uint256 leverage;\n        bool isLong;\n        bool isCrossMargin;\n    }\n\n    function increasePosition(\n        Position.Props storage position,\n        Symbol.Props memory symbolProps,\n        IncreasePositionParams calldata params\n    ) external {\n        uint256 fee = FeeQueryProcess.calcOpenFee(params.increaseMargin, params.leverage, symbolProps.code);\n        FeeProcess.chargeTradingFee(fee, symbolProps.code, FeeProcess.FEE_OPEN_POSITION, params.marginToken, position);\n        if (params.isCrossMargin) {\n            Account.Props storage accountProps = Account.load(position.account);\n            accountProps.unUseToken(params.marginToken, fee);\n            accountProps.subTokenWithLiability(params.marginToken, fee);\n        }\n\n        uint256 increaseMargin = params.increaseMargin - fee;\n        uint256 increaseMarginFromBalance = params.increaseMarginFromBalance > fee\n            ? params.increaseMarginFromBalance - fee\n            : 0;\n\n        uint8 tokenDecimals = TokenUtils.decimals(params.marginToken);\n        uint256 increaseQty = CalUtils.tokenToUsd(\n            CalUtils.mulRate(increaseMargin, params.leverage),\n            tokenDecimals,\n            params.marginTokenPrice\n        );\n\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(symbolProps.code);\n        if (position.qty == 0) {\n            position.marginToken = params.marginToken;\n            position.entryPrice = params.indexTokenPrice;\n            position.initialMargin = increaseMargin;\n            position.initialMarginInUsd = CalUtils.tokenToUsd(increaseMargin, tokenDecimals, params.marginTokenPrice);\n            position.initialMarginInUsdFromBalance = CalUtils.tokenToUsd(\n                increaseMarginFromBalance,\n                tokenDecimals,\n                params.marginTokenPrice\n            );\n            position.positionFee.closeFeeInUsd = CalUtils.mulRate(increaseQty, symbolConfig.closeFeeRate);\n            position.qty = increaseQty;\n            position.leverage = params.leverage;\n            position.realizedPnl = -(CalUtils.tokenToUsd(fee, tokenDecimals, params.marginTokenPrice).toInt256());\n            position.positionFee.openBorrowingFeePerToken = MarketQueryProcess.getCumulativeBorrowingFeePerToken(\n                symbolProps.stakeToken,\n                params.isLong,\n                params.marginToken\n            );\n            position.positionFee.openFundingFeePerQty = MarketQueryProcess.getFundingFeePerQty(\n                symbolProps.code,\n                params.isLong\n            );\n        } else {\n            FeeProcess.updateBorrowingFee(position, symbolProps.stakeToken);\n            FeeProcess.updateFundingFee(position);\n            position.entryPrice = CalUtils.computeAvgEntryPrice(\n                position.qty,\n                position.entryPrice,\n                increaseQty,\n                params.indexTokenPrice,\n                symbolConfig.tickSize,\n                params.isLong\n            );\n            position.initialMargin += increaseMargin;\n            position.initialMarginInUsd += CalUtils.tokenToUsd(increaseMargin, tokenDecimals, params.marginTokenPrice);\n            position.initialMarginInUsdFromBalance += CalUtils.tokenToUsd(\n                increaseMarginFromBalance,\n                tokenDecimals,\n                params.marginTokenPrice\n            );\n            position.positionFee.closeFeeInUsd += CalUtils.mulRate(increaseQty, symbolConfig.closeFeeRate);\n            position.qty += increaseQty;\n            position.realizedPnl += -(CalUtils.tokenToUsd(fee, tokenDecimals, params.marginTokenPrice).toInt256());\n        }\n\n        position.lastUpdateTime = ChainUtils.currentTimestamp();\n        uint256 increaseHoldAmount = CalUtils.mulRate(increaseMargin, (params.leverage - 1 * CalUtils.RATE_PRECISION));\n        position.holdPoolAmount += increaseHoldAmount;\n\n        // update & verify OI\n        MarketProcess.updateMarketOI(\n            MarketProcess.UpdateOIParams(\n                true,\n                symbolProps.code,\n                params.marginToken,\n                increaseQty,\n                params.indexTokenPrice,\n                params.isLong\n            )\n        );\n\n        LpPoolProcess.holdPoolAmount(symbolProps.stakeToken, position.marginToken, increaseHoldAmount, params.isLong);\n\n        position.emitPositionUpdateEvent(\n            params.requestId,\n            Position.PositionUpdateFrom.ORDER_INCREASE,\n            params.indexTokenPrice\n        );\n    }\n}\n"
    },
    "contracts/process/LiquidationProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./PositionQueryProcess.sol\";\nimport \"./DecreasePositionProcess.sol\";\nimport \"./CancelOrderProcess.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/Order.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/LiabilityClean.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary LiquidationProcess {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    using Position for Position.Props;\n    using DecreasePositionProcess for Position.Props;\n    using PositionQueryProcess for Position.Props;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n    using Order for Order.Props;\n    using Config for Config.Props;\n\n    event LiquidationAccountIgnored(address account);\n    event LiquidationPositionIgnored(bytes32 positionKey);\n\n    bytes32 constant CLEAN_ID_KEY = keccak256(\"CLEAN_ID_KEY\");\n    bytes32 constant LIQUIDATION_ID_KEY = keccak256(\"LIQUIDATION_ID_KEY\");\n\n    function liquidationCrossPositions(address account) external {\n        Account.Props storage accountProps = Account.load(account);\n        Position.Props[] memory crossPositions = PositionQueryProcess.getAllPosition(accountProps, true);\n        if (crossPositions.length == 0) {\n            revert Errors.OnlyCrossSupported();\n        }\n\n        CancelOrderProcess.cancelAllCrossOrders(account, CancelOrderProcess.CANCEL_ORDER_LIQUIDATION);\n        for (uint256 i; i < crossPositions.length; i++) {\n            Symbol.Props memory symbolProps = Symbol.load(crossPositions[i].symbol);\n            MarketProcess.updateMarketFundingFeeRate(crossPositions[i].symbol);\n            MarketProcess.updatePoolBorrowingFeeRate(\n                symbolProps.stakeToken,\n                crossPositions[i].isLong,\n                crossPositions[i].marginToken\n            );\n        }\n        console.log(\"liquidation account\", account);\n        if (!accountProps.isCrossLiquidation()) {\n            emit LiquidationAccountIgnored(account);\n            return;\n        }\n\n        (uint256 crossNetValue, uint256 totalQty) = accountProps.getCrossNetValueAndTotalQty();\n        console.log(\"crossNetValue\", crossNetValue, \"totalQty\", totalQty);\n        // todo: crossNetValue < 0\n        uint256 bankruptcyMR = CalUtils.divToPrecision(crossNetValue, totalQty, CalUtils.SMALL_RATE_PRECISION);\n        console.log(\"bankruptcyMR\", bankruptcyMR);\n\n        uint256 requestId = UuidCreator.nextId(LIQUIDATION_ID_KEY);\n        for (uint256 i; i < crossPositions.length; i++) {\n            Position.Props memory position = crossPositions[i];\n            Symbol.Props memory symbolProps = Symbol.load(position.symbol);\n            uint256 indexPrice = OracleProcess.getLatestUsdUintPrice(position.indexToken, position.isLong);\n            Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(symbolProps.code);\n            console.log(\"i=\", i, \"indexPrice\", indexPrice);\n            uint256 bankruptcyPrice = CalUtils.formatToTickSize(\n                position.isLong\n                    ? CalUtils.mulSmallRate(indexPrice, (CalUtils.SMALL_RATE_PRECISION - bankruptcyMR))\n                    : CalUtils.mulSmallRate(indexPrice, (CalUtils.SMALL_RATE_PRECISION + bankruptcyMR)),\n                symbolConfig.tickSize,\n                position.isLong\n            );\n\n            console.log(\"bankruptcyPrice\", bankruptcyPrice, \"indexPrice\", indexPrice);\n\n            uint256 liquidationPrice = CalUtils.formatToTickSize(\n                position.isLong\n                    ? CalUtils.divRate(\n                        bankruptcyPrice,\n                        CalUtils.RATE_PRECISION - PositionQueryProcess.getPositionMMRate(position)\n                    )\n                    : CalUtils.divRate(\n                        bankruptcyPrice,\n                        CalUtils.RATE_PRECISION + PositionQueryProcess.getPositionMMRate(position)\n                    ),\n                symbolConfig.tickSize,\n                position.isLong\n            );\n\n            Position.load(position.key).decreasePosition(\n                DecreasePositionProcess.DecreasePositionParams(\n                    requestId,\n                    position.symbol,\n                    true,\n                    true,\n                    position.marginToken,\n                    position.qty,\n                    liquidationPrice\n                )\n            );\n        }\n\n        _updateClean(accountProps);\n    }\n\n    function liquidationIsolatePosition(bytes32 positionKey) external {\n        Position.Props storage position = Position.load(positionKey);\n        position.checkExists();\n        if (position.isCrossMargin) {\n            revert Errors.OnlyIsolateSupported();\n        }\n        MarketProcess.updateMarketFundingFeeRate(position.symbol);\n        MarketProcess.updatePoolBorrowingFeeRate(\n            Symbol.load(position.symbol).stakeToken,\n            position.isLong,\n            position.marginToken\n        );\n\n        uint256 indexPrice = OracleProcess.getLatestUsdUintPrice(position.indexToken, position.isLong);\n        uint256 liquidationPrice = position.getLiquidationPrice();\n        if ((position.isLong && indexPrice > liquidationPrice) || (!position.isLong && indexPrice < liquidationPrice)) {\n            emit LiquidationPositionIgnored(positionKey);\n            return;\n        }\n\n        CancelOrderProcess.cancelSymbolOrders(\n            position.account,\n            position.symbol,\n            position.marginToken,\n            CancelOrderProcess.CANCEL_ORDER_LIQUIDATION\n        );\n\n        position.decreasePosition(\n            DecreasePositionProcess.DecreasePositionParams(\n                UuidCreator.nextId(LIQUIDATION_ID_KEY),\n                position.symbol,\n                true,\n                false,\n                position.marginToken,\n                position.qty,\n                liquidationPrice\n            )\n        );\n    }\n\n    function _updateClean(Account.Props storage accountProps) internal {\n        uint256 cleanId = UuidCreator.nextId(CLEAN_ID_KEY);\n        LiabilityClean.LiabilityCleanInfo storage cleanInfo = LiabilityClean.newClean(cleanId);\n        cleanInfo.account = accountProps.owner;\n        cleanInfo.liquidationTime = ChainUtils.currentTimestamp();\n        address[] memory tokens = accountProps.getTokens();\n        for (uint256 i; i < tokens.length; i++) {\n            Account.TokenBalance memory temp = accountProps.getTokenBalance(tokens[i]);\n            if (temp.amount > 0) {\n                cleanInfo.collaterals.push(tokens[i]);\n                cleanInfo.collateralsAmount.push(temp.amount);\n            }\n            if (temp.liability > 0) {\n                cleanInfo.liabilityTokens.push(tokens[i]);\n                cleanInfo.liabilities.push(temp.liability);\n                accountProps.clearLiability(tokens[i]);\n            }\n        }\n        for (uint256 i; i < tokens.length; i++) {\n            Account.TokenBalance memory temp = accountProps.getTokenBalance(tokens[i]);\n            if (temp.amount > 0) {\n                accountProps.subToken(tokens[i], temp.amount);\n            }\n        }\n    }\n}\n"
    },
    "contracts/process/LpPoolProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../utils/Errors.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./MarketProcess.sol\";\nimport \"./LpPoolQueryProcess.sol\";\n\nlibrary LpPoolProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using LpPool for LpPool.Props;\n    using LpPoolQueryProcess for LpPool.Props;\n    using UsdPool for UsdPool.Props;\n\n    function holdPoolAmount(address stakeToken, address token, uint256 amount, bool isLong) external {\n        if (isLong) {\n            LpPool.Props storage pool = LpPool.load(stakeToken);\n            if (pool.getPoolAvailableLiquidity() < amount) {\n                revert Errors.PoolAmountNotEnough(stakeToken, token);\n            }\n            pool.holdBaseToken(amount);\n        } else {\n            UsdPool.Props storage pool = UsdPool.load();\n            if (!UsdPool.isHoldAmountAllowed(pool.stableTokenBalances[token], UsdPool.getPoolLiquidityLimit(), amount)) {\n                revert Errors.PoolAmountNotEnough(stakeToken, token);\n            }\n            pool.holdStableToken(token, amount);\n        }\n    }\n\n    function updatePnlAndUnHoldPoolAmount(\n        address stakeToken,\n        address token,\n        uint256 amount,\n        int256 tokenPnl,\n        uint256 addLiability\n    ) external {\n        LpPool.Props storage pool = LpPool.load(stakeToken);\n        if (pool.baseToken == token) {\n            pool.unHoldBaseToken(amount);\n            if (tokenPnl > 0) {\n                uint256 utokenPnl = tokenPnl.toUint256();\n                pool.addBaseToken(utokenPnl > addLiability ? utokenPnl - addLiability : 0);\n                pool.addUnsettleBaseToken(utokenPnl > addLiability ? addLiability.toInt256() : tokenPnl);\n            } else if (tokenPnl < 0) {\n                pool.subBaseToken((-tokenPnl).toUint256());\n            }\n        } else {\n            UsdPool.Props storage usdPool = UsdPool.load();\n            usdPool.unHoldStableToken(token, amount);\n            if (tokenPnl >= 0) {\n                uint256 utokenPnl = tokenPnl.toUint256();\n                pool.addStableToken(token, utokenPnl > addLiability ? utokenPnl - addLiability : 0);\n                pool.addUnsettleStableToken(token, utokenPnl > addLiability ? addLiability.toInt256() : tokenPnl);\n            } else {\n                uint256 utokenPnl = (-tokenPnl).toUint256();\n                pool.addLossStableToken(token, utokenPnl);\n                usdPool.subStableToken(token, utokenPnl);\n                usdPool.addUnsettleStableToken(token, utokenPnl);\n            }\n        }\n    }\n\n    function validate(LpPool.Props storage pool) public view {\n        if (LpPoolQueryProcess.getPoolIntValue(pool) < 0) {\n            revert Errors.PoolValueLessThanZero();\n        }\n    }\n\n    function subPoolAmount(LpPool.Props storage pool, address token, uint256 amount) external {\n        if (!pool.isSubAmountAllowed(token, amount)) {\n            revert Errors.PoolAmountNotEnough(pool.stakeToken, token);\n        }\n        if (pool.baseToken == token) {\n            pool.subBaseToken(amount);\n        } else {\n            pool.subStableToken(token, amount);\n        }\n        validate(pool);\n    }\n}\n"
    },
    "contracts/process/LpPoolQueryProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Market.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"./OracleProcess.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary LpPoolQueryProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using LpPool for LpPool.Props;\n    using UsdPool for UsdPool.Props;\n    using Config for Config.Props;\n\n    function getUsdPool() external view returns (IPool.UsdPoolInfo memory) {\n        UsdPool.Props storage pool = UsdPool.load();\n        if (pool.getStableTokens().length == 0) {\n            IPool.UsdPoolInfo memory poolInfo;\n            return poolInfo;\n        }\n        address stakeUsdToken = CommonData.getStakeUsdToken();\n        uint256 totalSupply = IERC20(stakeUsdToken).totalSupply();\n        address[] memory stableTokens = pool.getStableTokens();\n        uint256[] memory tokensAvailableLiquidity = new uint256[](stableTokens.length);\n        for (uint256 i; i < stableTokens.length; i++) {\n            tokensAvailableLiquidity[i] = getUsdPoolAvailableLiquidity(pool, stableTokens[i]);\n        }\n        return\n            IPool.UsdPoolInfo(\n                stableTokens,\n                pool.getStableTokenBalanceArray(),\n                pool.getMaxWithdrawArray(),\n                0,\n                totalSupply,\n                tokensAvailableLiquidity,\n                pool.getAllBorrowingFees(),\n                pool.apr\n            );\n    }\n\n    function getUsdPoolWithOracle(\n        OracleProcess.OracleParam[] calldata oracles\n    ) external view returns (IPool.UsdPoolInfo memory) {\n        UsdPool.Props storage pool = UsdPool.load();\n        if (pool.getStableTokens().length == 0) {\n            IPool.UsdPoolInfo memory poolInfo;\n            return poolInfo;\n        }\n        address stakeUsdToken = CommonData.getStakeUsdToken();\n        uint256 totalSupply = IERC20(stakeUsdToken).totalSupply();\n        address[] memory stableTokens = pool.getStableTokens();\n        uint256[] memory tokensAvailableLiquidity = new uint256[](stableTokens.length);\n        for (uint256 i; i < stableTokens.length; i++) {\n            tokensAvailableLiquidity[i] = getUsdPoolAvailableLiquidity(pool, stableTokens[i]);\n        }\n        return\n            IPool.UsdPoolInfo(\n                stableTokens,\n                pool.getStableTokenBalanceArray(),\n                pool.getMaxWithdrawArray(),\n                oracles.length > 0 ? getUsdPoolValue(pool, oracles) : 0,\n                totalSupply,\n                tokensAvailableLiquidity,\n                pool.getAllBorrowingFees(),\n                pool.apr\n            );\n    }\n\n    function getAllPools(OracleProcess.OracleParam[] calldata oracles) external view returns (IPool.PoolInfo[] memory) {\n        address[] memory stakeTokens = CommonData.getAllStakeTokens();\n        IPool.PoolInfo[] memory poolInfos = new IPool.PoolInfo[](stakeTokens.length);\n        for (uint256 i; i < stakeTokens.length; i++) {\n            poolInfos[i] = getPool(stakeTokens[i], oracles);\n        }\n        return poolInfos;\n    }\n\n    function getPoolValue(LpPool.Props storage pool) public view returns (uint256) {\n        int256 poolValue = getPoolIntValue(pool);\n        return poolValue <= 0 ? 0 : poolValue.toUint256();\n    }\n\n    function getPoolValue(\n        LpPool.Props storage pool,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (uint256) {\n        int256 poolValue = getPoolIntValue(pool, oracles);\n        return poolValue <= 0 ? 0 : poolValue.toUint256();\n    }\n\n    function getPoolIntValue(LpPool.Props storage pool) public view returns (int256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getPoolIntValue(pool, oracles);\n    }\n\n    function getPoolIntValue(\n        LpPool.Props storage pool,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (int256) {\n        int256 value = 0;\n        if (pool.baseTokenBalance.amount > 0 || pool.baseTokenBalance.unsettledAmount > 0) {\n            int256 unpnl = getMarketUnpnl(pool.symbol, oracles, true, pool.baseToken, true);\n            int256 baseTokenPrice = OracleProcess.getIntOraclePrices(oracles, pool.baseToken, true);\n            value = CalUtils.tokenToUsdInt(\n                (pool.baseTokenBalance.amount.toInt256() + pool.baseTokenBalance.unsettledAmount + unpnl),\n                TokenUtils.decimals(pool.baseToken),\n                baseTokenPrice\n            );\n        }\n        address[] memory stableTokens = pool.getStableTokens();\n        if (stableTokens.length > 0) {\n            for (uint256 i; i < stableTokens.length; i++) {\n                LpPool.TokenBalance storage tokenBalance = pool.stableTokenBalances[stableTokens[i]];\n                if (tokenBalance.amount > 0 || tokenBalance.unsettledAmount > 0) {\n                    int256 unpnl = getMarketUnpnl(pool.symbol, oracles, false, stableTokens[i], true);\n                    value = value.add(\n                        CalUtils.tokenToUsdInt(\n                            (tokenBalance.amount.toInt256() +\n                                tokenBalance.unsettledAmount -\n                                tokenBalance.lossAmount.toInt256() +\n                                unpnl),\n                            TokenUtils.decimals(stableTokens[i]),\n                            OracleProcess.getIntOraclePrices(oracles, stableTokens[i], true)\n                        )\n                    );\n                }\n            }\n        }\n        return value;\n    }\n\n    function getPoolAvailableLiquidity(LpPool.Props storage pool) external view returns (uint256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getPoolAvailableLiquidity(pool, oracles);\n    }\n\n    function getPoolAvailableLiquidity(\n        LpPool.Props storage pool,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (uint256) {\n        int256 baseTokenAmount = pool.baseTokenBalance.amount.toInt256() + pool.baseTokenBalance.unsettledAmount;\n        if (baseTokenAmount < 0) {\n            return 0;\n        }\n\n        address[] memory stableTokens = pool.getStableTokens();\n        if (stableTokens.length > 0) {\n            uint8 baseTokenDecimals = TokenUtils.decimals(pool.baseToken);\n            int256 baseTokenPrice = OracleProcess.getIntOraclePrices(oracles, pool.baseToken, true);\n            for (uint256 i; i < stableTokens.length; i++) {\n                LpPool.TokenBalance storage tokenBalance = pool.stableTokenBalances[stableTokens[i]];\n                if (\n                    tokenBalance.lossAmount > 0 &&\n                    tokenBalance.amount.toInt256() + tokenBalance.unsettledAmount < tokenBalance.lossAmount.toInt256()\n                ) {\n                    int256 tokenUsd = CalUtils.tokenToUsdInt(\n                        tokenBalance.lossAmount.toInt256() -\n                            tokenBalance.amount.toInt256() -\n                            tokenBalance.unsettledAmount,\n                        TokenUtils.decimals(stableTokens[i]),\n                        OracleProcess.getIntOraclePrices(oracles, stableTokens[i], true)\n                    );\n                    int256 stableToBaseToken = CalUtils.usdToTokenInt(tokenUsd, baseTokenDecimals, baseTokenPrice);\n                    if (baseTokenAmount > stableToBaseToken) {\n                        baseTokenAmount -= stableToBaseToken;\n                    } else {\n                        baseTokenAmount = 0;\n                    }\n                }\n            }\n        }\n        int256 availableTokenAmount = CalUtils.mulRate(baseTokenAmount, pool.getPoolLiquidityLimit().toInt256());\n        return\n            availableTokenAmount > pool.baseTokenBalance.holdAmount.toInt256()\n                ? (availableTokenAmount - pool.baseTokenBalance.holdAmount.toInt256()).toUint256()\n                : 0;\n    }\n\n    function getUsdPoolAvailableLiquidity(UsdPool.Props storage pool, address token) public view returns (uint256) {\n        UsdPool.TokenBalance memory tokenBalance = pool.getStableTokenBalance(token);\n        uint256 totalAmount = tokenBalance.amount + tokenBalance.unsettledAmount;\n        uint256 availableTokenAmount = CalUtils.mulRate(totalAmount, UsdPool.getPoolLiquidityLimit());\n        return availableTokenAmount > tokenBalance.holdAmount ? availableTokenAmount - tokenBalance.holdAmount : 0;\n    }\n\n    function getUsdPoolValue(UsdPool.Props storage pool) public view returns (uint256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getUsdPoolValue(pool, oracles);\n    }\n\n    function getUsdPoolValue(\n        UsdPool.Props storage pool,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (uint256) {\n        int256 poolValue = getUsdPoolIntValue(pool, oracles);\n        return poolValue <= 0 ? 0 : poolValue.toUint256();\n    }\n\n    function getUsdPoolIntValue(UsdPool.Props storage pool) public view returns (int256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getUsdPoolIntValue(pool, oracles);\n    }\n\n    function getUsdPoolIntValue(\n        UsdPool.Props storage pool,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (int256) {\n        int256 value = 0;\n        address[] memory stableTokens = pool.getStableTokens();\n        if (stableTokens.length > 0) {\n            for (uint256 i; i < stableTokens.length; i++) {\n                UsdPool.TokenBalance storage tokenBalance = pool.stableTokenBalances[stableTokens[i]];\n                if (tokenBalance.amount > 0 || tokenBalance.unsettledAmount > 0) {\n                    value = value.add(\n                        CalUtils.tokenToUsdInt(\n                            (tokenBalance.amount.toInt256() + tokenBalance.unsettledAmount.toInt256()),\n                            TokenUtils.decimals(stableTokens[i]),\n                            OracleProcess.getIntOraclePrices(oracles, stableTokens[i], true)\n                        )\n                    );\n                }\n            }\n        }\n        return value;\n    }\n\n    function getMarketUnpnl(\n        bytes32 symbol,\n        OracleProcess.OracleParam[] memory oracles,\n        bool isLong,\n        address marginToken,\n        bool pnlToken\n    ) public view returns (int256) {\n        Market.Props storage market = Market.load(symbol);\n        Market.MarketPosition storage position = isLong ? market.longPosition : market.shortPositionMap[marginToken];\n        if (position.openInterest == 0) {\n            return 0;\n        }\n        int256 markPrice = OracleProcess.getIntOraclePrices(oracles, marginToken, true);\n        if (position.entryPrice == markPrice.toUint256()) {\n            return 0;\n        }\n        if (isLong) {\n            int pnlInUsd = position.openInterest.toInt256().mul(markPrice.sub(position.entryPrice.toInt256())).div(\n                position.entryPrice.toInt256()\n            );\n            return\n                pnlToken\n                    ? -CalUtils.usdToTokenInt(\n                        pnlInUsd,\n                        TokenUtils.decimals(marginToken),\n                        position.entryPrice.toInt256()\n                    )\n                    : -pnlInUsd;\n        } else {\n            int pnlInUsd = position.openInterest.toInt256().mul(position.entryPrice.toInt256().sub(markPrice)).div(\n                position.entryPrice.toInt256()\n            );\n            if (pnlToken) {\n                int256 marginTokenPrice = OracleProcess.getIntOraclePrices(oracles, marginToken, false);\n                return -CalUtils.usdToTokenInt(pnlInUsd, TokenUtils.decimals(marginToken), marginTokenPrice);\n            } else {\n                return -pnlInUsd;\n            }\n        }\n    }\n\n    function getPool(\n        address stakeToken,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (IPool.PoolInfo memory) {\n        LpPool.Props storage pool = LpPool.load(stakeToken);\n        address[] memory stableTokens = pool.getStableTokens();\n        uint256 totalSupply = IERC20(stakeToken).totalSupply();\n        return\n            IPool.PoolInfo(\n                stakeToken,\n                pool.stakeTokenName,\n                pool.baseToken,\n                pool.symbol,\n                _convertPoolBalance(pool.baseTokenBalance),\n                stableTokens,\n                _convertPoolStableBalance(stableTokens, pool.stableTokenBalances),\n                oracles.length > 0 ? getPoolValue(pool, oracles) : 0,\n                oracles.length > 0 ? getPoolAvailableLiquidity(pool, oracles) : 0,\n                0,\n                totalSupply,\n                pool.borrowingFee,\n                pool.apr\n            );\n    }\n\n    function _convertPoolBalance(\n        LpPool.TokenBalance storage balance\n    ) internal view returns (IPool.MintTokenBalance memory) {\n        (address[] memory collateralTokens, uint256[] memory amounts) = LpPool.getCollateralTokenAmounts(\n            balance.collateralTokenAmounts\n        );\n        return\n            IPool.MintTokenBalance(\n                balance.amount,\n                balance.liability,\n                balance.holdAmount,\n                balance.unsettledAmount,\n                balance.lossAmount,\n                collateralTokens,\n                amounts\n            );\n    }\n\n    function _convertPoolStableBalance(\n        address[] memory stableTokens,\n        mapping(address => LpPool.TokenBalance) storage stableTokenBalances\n    ) internal view returns (IPool.MintTokenBalance[] memory) {\n        IPool.MintTokenBalance[] memory stableTokenBalanceArray = new IPool.MintTokenBalance[](stableTokens.length);\n        for (uint256 i; i < stableTokens.length; i++) {\n            stableTokenBalanceArray[i] = _convertPoolBalance(stableTokenBalances[stableTokens[i]]);\n        }\n        return stableTokenBalanceArray;\n    }\n\n    function _convertPoolCollateralConfig(\n        address[] memory collaterals,\n        mapping(address => Config.StakeCollateralConfig) storage collateralConfigs\n    ) internal view returns (Config.StakeCollateralConfig[] memory) {\n        Config.StakeCollateralConfig[] memory collateralConfigsArray = new Config.StakeCollateralConfig[](\n            collaterals.length\n        );\n        for (uint256 i; i < collaterals.length; i++) {\n            collateralConfigsArray[i] = collateralConfigs[collaterals[i]];\n        }\n        return collateralConfigsArray;\n    }\n}\n"
    },
    "contracts/process/MarketFactoryProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"../storage/Symbol.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/Market.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../vault/StakeToken.sol\";\n\nlibrary MarketFactoryProcess {\n    using Market for Market.Props;\n\n    event MarketCreated(bytes32 code, string stakeTokenName, address indexToken, address baseToken, address stakeToken);\n\n    event PoolCreated(string name, address stakeToken);\n\n    event MarketOIUpdateEvent(bytes32 symbol, bool isLong, uint256 openInterest);\n\n    struct CreateMarketParams {\n        bytes32 code;\n        string stakeTokenName;\n        address indexToken;\n        address baseToken;\n    }\n\n    function createMarket(CreateMarketParams memory params) external returns (address stakeTokenAddr) {\n        Symbol.Props storage symbolProps = Symbol.create(params.code);\n        if (symbolProps.indexToken != address(0)) {\n            revert Errors.CreateSymbolExists(params.code);\n        }\n        symbolProps.indexToken = params.indexToken;\n        symbolProps.baseToken = params.baseToken;\n        symbolProps.status = Symbol.Status.OPEN;\n        ERC20 baseTokenERC20 = ERC20(params.baseToken);\n        bytes32 stakeTokenSalt = keccak256(abi.encode(\"STAKE_TOKEN\", params.stakeTokenName));\n        StakeToken stakeToken = new StakeToken{ salt: stakeTokenSalt }(\n            params.stakeTokenName,\n            baseTokenERC20.decimals()\n        );\n        stakeTokenAddr = address(stakeToken);\n        symbolProps.stakeToken = stakeTokenAddr;\n\n        LpPool.Props storage pool = LpPool.load(stakeTokenAddr);\n        if (pool.stakeToken != address(0)) {\n            revert Errors.CreateStakePoolExists(stakeTokenAddr);\n        }\n        pool.stakeToken = stakeTokenAddr;\n        pool.stakeTokenName = params.stakeTokenName;\n        pool.baseToken = params.baseToken;\n        pool.symbol = params.code;\n        CommonData.addSymbol(params.code);\n        CommonData.addStakeTokens(stakeTokenAddr);\n\n        Market.Props storage marketProps = Market.load(params.code);\n        marketProps.symbol = params.code;\n        marketProps.stakeToken = stakeTokenAddr;\n\n        emit MarketCreated(params.code, params.stakeTokenName, params.indexToken, params.baseToken, stakeTokenAddr);\n    }\n\n    function createStakeUsdPool(string memory stakeTokenName) external returns (address stakeTokenAddr) {\n        if (CommonData.getStakeUsdToken() != address(0)) {\n            revert Errors.CreateStakePoolExists(CommonData.getStakeUsdToken());\n        }\n        bytes32 stakeTokenSalt = keccak256(abi.encode(\"STAKE_USD_TOKEN\", stakeTokenName));\n        StakeToken stakeToken = new StakeToken{ salt: stakeTokenSalt }(stakeTokenName, 6);\n        stakeTokenAddr = address(stakeToken);\n\n        LpPool.Props storage pool = LpPool.load(stakeTokenAddr);\n        pool.stakeToken = stakeTokenAddr;\n\n        CommonData.setStakeUsdToken(stakeTokenAddr);\n        emit PoolCreated(stakeTokenName, stakeTokenAddr);\n    }\n}\n"
    },
    "contracts/process/MarketProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"./MarketQueryProcess.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/Market.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"../utils/ChainUtils.sol\";\n\nlibrary MarketProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using Math for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for int256;\n    using Market for Market.Props;\n    using MarketQueryProcess for Market.Props;\n    using UsdPool for UsdPool.Props;\n    using LpPool for LpPool.Props;\n    using Config for Config.Props;\n\n    event MarketOIUpdateEvent(bytes32 symbol, bool isLong, uint256 openInterest);\n\n    struct UpdateOIParams {\n        bool isAdd;\n        bytes32 symbol;\n        address token;\n        uint256 qty;\n        uint256 entryPrice;\n        bool isLong;\n    }\n\n    struct UpdateFundingCache {\n        uint256 totalLongOpenInterest;\n        uint256 totalShortOpenInterest;\n        uint256 fundingFeeDurationInSecond;\n        uint256 fundingRatePerSecond;\n        uint256 totalFundingFee;\n        int256 longFundingFeePerQtyDelta;\n        int256 shortFundingFeePerQtyDelta;\n    }\n\n    function updateMarketFundingFeeRate(bytes32 symbol) external {\n        UpdateFundingCache memory cache;\n        Market.Props storage market = Market.load(symbol);\n        Symbol.Props storage symbolProps = Symbol.load(symbol);\n        cache.totalLongOpenInterest = market.getLongOpenInterest();\n        cache.totalShortOpenInterest = market.getAllShortOpenInterest();\n        if (cache.totalLongOpenInterest == 0 || cache.totalShortOpenInterest == 0) {\n            market.fundingFee.lastUpdateTime = ChainUtils.currentTimestamp();\n            return;\n        }\n        cache.fundingFeeDurationInSecond = _getFundingFeeDurations(market);\n        cache.fundingRatePerSecond = market.getFundingRatePerSecond();\n        cache.totalFundingFee = Math\n            .max(cache.totalLongOpenInterest, cache.totalShortOpenInterest)\n            .mul(cache.fundingFeeDurationInSecond)\n            .mul(cache.fundingRatePerSecond);\n        cache.longFundingFeePerQtyDelta = CalUtils\n            .usdToToken(\n                cache.totalFundingFee.div(cache.totalLongOpenInterest),\n                TokenUtils.decimals(symbolProps.baseToken),\n                OracleProcess.getLatestUsdUintPrice(symbolProps.baseToken, true)\n            )\n            .toInt256();\n        cache.shortFundingFeePerQtyDelta = cache.totalFundingFee.div(cache.totalShortOpenInterest).toInt256();\n        if (cache.totalLongOpenInterest < cache.totalShortOpenInterest) {\n            cache.shortFundingFeePerQtyDelta = -cache.shortFundingFeePerQtyDelta;\n        } else {\n            cache.longFundingFeePerQtyDelta = -cache.longFundingFeePerQtyDelta;\n        }\n\n        market.fundingFee.longFundingFeePerQty += cache.longFundingFeePerQtyDelta;\n        market.fundingFee.shortFundingFeePerQty += cache.shortFundingFeePerQtyDelta;\n        market.fundingFee.lastUpdateTime = ChainUtils.currentTimestamp();\n    }\n\n    function updatePoolBorrowingFeeRate(address stakeToken, bool isLong, address marginToken) external {\n        if (isLong) {\n            LpPool.Props storage pool = LpPool.load(stakeToken);\n            uint256 borrowingFeeDurationInSecond = _getFeeDurations(pool.borrowingFee.lastUpdateTime);\n            pool.borrowingFee.cumulativeBorrowingFeePerToken += MarketQueryProcess\n                .getLongBorrowingRatePerSecond(pool)\n                .mul(borrowingFeeDurationInSecond);\n            pool.borrowingFee.lastUpdateTime = ChainUtils.currentTimestamp();\n        } else {\n            UsdPool.Props storage usdPool = UsdPool.load();\n            UsdPool.BorrowingFee storage borrowingFees = usdPool.getBorrowingFees(marginToken);\n            uint256 borrowingFeeDurationInSecond = _getFeeDurations(borrowingFees.lastUpdateTime);\n            borrowingFees.cumulativeBorrowingFeePerToken += MarketQueryProcess\n                .getShortBorrowingRatePerSecond(usdPool, marginToken)\n                .mul(borrowingFeeDurationInSecond);\n            borrowingFees.lastUpdateTime = ChainUtils.currentTimestamp();\n        }\n    }\n\n    function updateTotalBorrowingFee(\n        address stakeToken,\n        bool isLong,\n        address marginToken,\n        int256 borrowingFee,\n        int256 realizedBorrowingFee\n    ) external {\n        if (isLong) {\n            LpPool.Props storage pool = LpPool.load(stakeToken);\n            pool.borrowingFee.totalBorrowingFee = borrowingFee > 0\n                ? (pool.borrowingFee.totalBorrowingFee + borrowingFee.toUint256())\n                : (pool.borrowingFee.totalBorrowingFee - (-borrowingFee).toUint256());\n            pool.borrowingFee.totalRealizedBorrowingFee = realizedBorrowingFee > 0\n                ? (pool.borrowingFee.totalRealizedBorrowingFee + realizedBorrowingFee.toUint256())\n                : (pool.borrowingFee.totalRealizedBorrowingFee - (-realizedBorrowingFee).toUint256());\n        } else {\n            UsdPool.Props storage usdPool = UsdPool.load();\n            UsdPool.BorrowingFee storage borrowingFees = usdPool.getBorrowingFees(marginToken);\n            borrowingFees.totalBorrowingFee = borrowingFee > 0\n                ? (borrowingFees.totalBorrowingFee + borrowingFee.toUint256())\n                : (borrowingFees.totalBorrowingFee - (-borrowingFee).toUint256());\n            borrowingFees.totalRealizedBorrowingFee = realizedBorrowingFee > 0\n                ? (borrowingFees.totalRealizedBorrowingFee + realizedBorrowingFee.toUint256())\n                : (borrowingFees.totalRealizedBorrowingFee - (-realizedBorrowingFee).toUint256());\n        }\n    }\n\n    function updateMarketFundingFee(\n        bytes32 symbol,\n        int256 realizedFundingFeeDelta,\n        bool isLong,\n        bool needUpdateUnsettle,\n        address marginToken\n    ) external {\n        Market.Props storage market = Market.load(symbol);\n        if (isLong) {\n            market.fundingFee.totalLongFundingFee += realizedFundingFeeDelta;\n        } else {\n            market.fundingFee.totalShortFundingFee += realizedFundingFeeDelta;\n        }\n        if (needUpdateUnsettle) {\n            Symbol.Props storage symbolProps = Symbol.load(symbol);\n            LpPool.Props storage pool = LpPool.load(symbolProps.stakeToken);\n            if (isLong) {\n                pool.addUnsettleBaseToken(realizedFundingFeeDelta);\n            } else {\n                pool.addUnsettleStableToken(marginToken, realizedFundingFeeDelta);\n            }\n        }\n    }\n\n    function updateMarketOI(UpdateOIParams memory params) external {\n        Market.Props storage market = Market.load(params.symbol);\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(params.symbol);\n        if (params.isAdd && params.isLong) {\n            _addOI(market.longPosition, params, symbolConfig.tickSize);\n        } else if (params.isAdd && !params.isLong) {\n            market.addShortToken(params.token);\n            _addOI(market.shortPositionMap[params.token], params, symbolConfig.tickSize);\n        } else if (!params.isAdd) {\n            _subOI(params.isLong ? market.longPosition : market.shortPositionMap[params.token], params);\n        }\n\n        if (params.isAdd) {\n            uint256 longOpenInterest = market.getLongOpenInterest();\n            uint256 shortOpenInterest = market.getAllShortOpenInterest();\n            if (params.isLong && longOpenInterest > symbolConfig.maxLongOpenInterestCap) {\n                revert Errors.MaxOILimited(params.symbol, params.isLong);\n            }\n            if (!params.isLong && shortOpenInterest > symbolConfig.maxShortOpenInterestCap) {\n                revert Errors.MaxOILimited(params.symbol, params.isLong);\n            }\n            uint256 minOpenInterest = longOpenInterest.min(shortOpenInterest);\n            if (minOpenInterest < symbolConfig.longShortOiBottomLimit) {\n                return;\n            }\n            if (\n                longOpenInterest.max(shortOpenInterest) - minOpenInterest >\n                CalUtils.mulRate(longOpenInterest + shortOpenInterest, symbolConfig.longShortRatioLimit)\n            ) {\n                revert Errors.OIRatioLimited();\n            }\n        }\n    }\n\n    function _getFundingFeeDurations(Market.Props storage market) internal view returns (uint256) {\n        if (market.fundingFee.lastUpdateTime == 0) {\n            return 0;\n        }\n        return ChainUtils.currentTimestamp() - market.fundingFee.lastUpdateTime;\n    }\n\n    function _getFeeDurations(uint256 lastUpdateTime) internal view returns (uint256) {\n        if (lastUpdateTime == 0) {\n            return 0;\n        }\n        return ChainUtils.currentTimestamp() - lastUpdateTime;\n    }\n\n    function _addOI(Market.MarketPosition storage position, UpdateOIParams memory params, uint256 tickSize) internal {\n        if (position.openInterest == 0) {\n            position.entryPrice = params.entryPrice;\n            position.openInterest = params.qty;\n        } else {\n            position.entryPrice = CalUtils.computeAvgEntryPrice(\n                position.openInterest,\n                position.entryPrice,\n                params.qty,\n                params.entryPrice,\n                tickSize,\n                params.isLong\n            );\n            position.openInterest += params.qty;\n        }\n        emit MarketOIUpdateEvent(params.symbol, params.isLong, position.openInterest);\n    }\n\n    function _subOI(Market.MarketPosition storage position, UpdateOIParams memory params) internal {\n        if (position.openInterest <= params.qty) {\n            position.entryPrice = 0;\n            position.openInterest = 0;\n        } else {\n            position.openInterest -= params.qty;\n        }\n        emit MarketOIUpdateEvent(params.symbol, params.isLong, position.openInterest);\n    }\n}\n"
    },
    "contracts/process/MarketQueryProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Market.sol\";\nimport \"../storage/Config.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./LpPoolQueryProcess.sol\";\n\nlibrary MarketQueryProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for int256;\n    using LpPoolQueryProcess for LpPool.Props;\n    using LpPoolQueryProcess for UsdPool.Props;\n    using UsdPool for UsdPool.Props;\n    using Market for Market.Props;\n    using Config for Config.Props;\n\n    function getMarketInfo(bytes32 symbol, OracleProcess.OracleParam[] calldata oracles) external view returns (IMarket.MarketInfo memory) {\n        Symbol.Props memory symbolProps = Symbol.load(symbol);\n        LpPool.Props storage pool = LpPool.load(symbolProps.stakeToken);\n        uint256 availableLiquidity = pool.getPoolAvailableLiquidity(oracles);\n        Market.Props storage market = Market.load(symbol);\n        uint256 longPositionInterest = market.longPosition.openInterest;\n        uint256 totalShortPositionInterest = market.getAllShortOpenInterest();\n        return\n            IMarket.MarketInfo(\n                symbolProps,\n                longPositionInterest,\n                market.longPosition.entryPrice,\n                totalShortPositionInterest,\n                market.getAllShortPositions(),\n                availableLiquidity,\n                market.fundingFee\n            );\n    }\n\n    function getCumulativeBorrowingFeePerToken(\n        address stakeToken,\n        bool isLong,\n        address marginToken\n    ) external view returns (uint256) {\n        if (isLong) {\n            LpPool.Props storage pool = LpPool.load(stakeToken);\n            return pool.borrowingFee.cumulativeBorrowingFeePerToken;\n        } else {\n            UsdPool.Props storage usdPool = UsdPool.load();\n            return usdPool.getBorrowingFees(marginToken).cumulativeBorrowingFeePerToken;\n        }\n    }\n\n    function getLongBorrowingRatePerSecond(LpPool.Props storage pool) external view returns (uint256) {\n        if (pool.baseTokenBalance.amount == 0 && pool.baseTokenBalance.unsettledAmount == 0) {\n            return 0;\n        }\n        int256 totalAmount = pool.baseTokenBalance.amount.toInt256() + pool.baseTokenBalance.unsettledAmount;\n        if (totalAmount <= 0) {\n            return 0;\n        }\n        uint256 holdRate = CalUtils.divToPrecision(\n            pool.baseTokenBalance.holdAmount,\n            totalAmount.toUint256(),\n            CalUtils.SMALL_RATE_PRECISION\n        );\n        return CalUtils.mulSmallRate(holdRate, Config.load().lpPoolConfigs[pool.stakeToken].baseInterestRate);\n    }\n\n    function getShortBorrowingRatePerSecond(UsdPool.Props storage pool, address token) external view returns (uint256) {\n        Config.UsdPoolConfig storage usdPoolConfig = Config.load().getUsdPoolConfig();\n        if (pool.getStableTokenBalance(token).amount == 0 && pool.getStableTokenBalance(token).unsettledAmount == 0) {\n            return 0;\n        }\n        uint256 holdRate = CalUtils.divToPrecision(\n            pool.getStableTokenBalance(token).holdAmount,\n            (pool.getStableTokenBalance(token).amount + pool.getStableTokenBalance(token).unsettledAmount),\n            CalUtils.SMALL_RATE_PRECISION\n        );\n        return CalUtils.mulSmallRate(holdRate, usdPoolConfig.baseInterestRates[token]);\n    }\n\n    function getFundingFeePerQty(bytes32 symbol, bool isLong) external view returns (int256) {\n        Market.Props storage market = Market.load(symbol);\n        return isLong ? market.fundingFee.longFundingFeePerQty : market.fundingFee.shortFundingFeePerQty;\n    }\n\n    function getFundingRatePerSecond(Market.Props storage market) external view returns (uint256) {\n        uint256 longPositionInterest = market.longPosition.openInterest;\n        uint256 totalShortPositionInterest = market.getAllShortOpenInterest();\n        uint256 diffOpenInterest = CalUtils.diff(longPositionInterest, totalShortPositionInterest);\n        uint256 totalOpenInterest = longPositionInterest + totalShortPositionInterest;\n        if (diffOpenInterest == 0 || totalOpenInterest == 0) {\n            return 0;\n        }\n        return Math.mulDiv(diffOpenInterest, Config.load().tradeConfig.fundingFeeBaseRate, totalOpenInterest);\n    }\n}\n"
    },
    "contracts/process/MintProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/IStake.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../vault/Vault.sol\";\nimport \"../vault/LpVault.sol\";\nimport \"../vault/StakeToken.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Mint.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"./GasProcess.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./LpPoolQueryProcess.sol\";\nimport \"./FeeProcess.sol\";\nimport \"./FeeRewardsProcess.sol\";\nimport \"./AccountProcess.sol\";\nimport \"./AssetsProcess.sol\";\nimport \"./FeeQueryProcess.sol\";\n\nlibrary MintProcess {\n    using LpPool for LpPool.Props;\n    using LpPoolQueryProcess for LpPool.Props;\n    using UsdPool for UsdPool.Props;\n    using LpPoolQueryProcess for UsdPool.Props;\n    using StakingAccount for StakingAccount.Props;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n    using Config for Config.Props;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    bytes32 constant MINT_ID_KEY = keccak256(\"MINT_ID_KEY\");\n\n    struct ExecuteMintCache {\n        address mintToken;\n        uint256 mintFee;\n        uint8 mintTokenDecimals;\n        uint256 mintTokenAmount;\n        uint256 mintStakeAmount;\n    }\n\n    event CancelMintEvent(uint256 indexed requestId, Mint.Request data, bytes32 reasonCode);\n    event MintSuccessEvent(uint256 indexed requestId, uint256 mintStakeAmount, Mint.Request data);\n    event CreateMintEvent(uint256 indexed requestId, Mint.Request data);\n\n    function createMintStakeTokenRequest(\n        IStake.MintStakeTokenParams memory params,\n        address account,\n        address token,\n        uint256 walletRequestTokenAmount,\n        bool isExecutionFeeFromLpVault\n    ) external {\n        uint256 requestId = UuidCreator.nextId(MINT_ID_KEY);\n\n        Mint.Request storage mintRequest = Mint.create(requestId);\n        mintRequest.account = account;\n        mintRequest.receiver = params.receiver;\n        mintRequest.stakeToken = params.stakeToken;\n        mintRequest.requestToken = token;\n        mintRequest.minStakeAmount = params.minStakeAmount;\n        mintRequest.requestTokenAmount = params.requestTokenAmount;\n        mintRequest.walletRequestTokenAmount = walletRequestTokenAmount;\n        mintRequest.executionFee = params.executionFee;\n        mintRequest.isCollateral = params.isCollateral;\n        mintRequest.isExecutionFeeFromLpVault = isExecutionFeeFromLpVault;\n\n        emit CreateMintEvent(requestId, mintRequest);\n    }\n\n    function executeMintStakeToken(\n        uint256 requestId,\n        Mint.Request memory mintRequest\n    ) external returns (uint256 stakeAmount) {\n        if (mintRequest.account == address(0)) {\n            revert Errors.MintRequestNotExists();\n        }\n        if (CommonData.getStakeUsdToken() == mintRequest.stakeToken) {\n            stakeAmount = _mintStakeUsd(mintRequest);\n        } else if (CommonData.isStakeTokenSupport(mintRequest.stakeToken)) {\n            stakeAmount = _mintStakeToken(mintRequest);\n        } else {\n            revert Errors.StakeTokenInvalid(mintRequest.stakeToken);\n        }\n        if (!mintRequest.isCollateral && mintRequest.walletRequestTokenAmount > 0) {\n            IVault(address(this)).getLpVault().transferOut(\n                mintRequest.requestToken,\n                mintRequest.stakeToken,\n                mintRequest.walletRequestTokenAmount\n            );\n        }\n\n        FeeRewardsProcess.updateAccountFeeRewards(mintRequest.account, mintRequest.stakeToken);\n        \n        Mint.remove(requestId);\n\n        emit MintSuccessEvent(requestId, stakeAmount, mintRequest);\n    }\n\n    function cancelMintStakeToken(uint256 requestId, Mint.Request memory mintRequest, bytes32 reasonCode) external {\n        if (mintRequest.walletRequestTokenAmount > 0) {\n            VaultProcess.transferOut(\n                mintRequest.isCollateral\n                    ? IVault(address(this)).getPortfolioVaultAddress()\n                    : IVault(address(this)).getLpVaultAddress(),\n                mintRequest.requestToken,\n                mintRequest.account,\n                mintRequest.walletRequestTokenAmount\n            );\n        }\n        Mint.remove(requestId);\n        emit CancelMintEvent(requestId, mintRequest, reasonCode);\n    }\n\n    function validateAndDepositMintExecutionFee(\n        address account,\n        IStake.MintStakeTokenParams calldata params\n    ) external returns (uint256, bool) {\n        Config.Props storage config = Config.load();\n        GasProcess.validateExecutionFeeLimit(params.executionFee, config.chainConfig.mintGasFeeLimit);\n        if (params.isNativeToken && params.walletRequestTokenAmount >= params.executionFee) {\n            return (params.walletRequestTokenAmount - params.executionFee, true);\n        }\n        require(msg.value == params.executionFee, \"mint with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                account,\n                config.chainConfig.wrapperToken,\n                params.executionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n        return (params.walletRequestTokenAmount, false);\n    }\n\n    function _mintStakeToken(Mint.Request memory mintRequest) internal returns (uint256 stakeAmount) {\n        if (mintRequest.requestTokenAmount > mintRequest.walletRequestTokenAmount) {\n            _transferFromAccount(\n                mintRequest.account,\n                mintRequest.requestToken,\n                mintRequest.requestTokenAmount - mintRequest.walletRequestTokenAmount\n            );\n        }\n\n        StakingAccount.Props storage accountProps = StakingAccount.load(mintRequest.account);\n        LpPool.Props storage pool = LpPool.load(mintRequest.stakeToken);\n        Config.Props storage config = Config.load();\n        Config.LpPoolConfig storage poolConfig = config.getPoolConfig(mintRequest.stakeToken);\n        ExecuteMintCache memory cache;\n        if (mintRequest.isCollateral) {\n            if (!pool.isStakeCollateralSupport(mintRequest.requestToken)) {\n                revert Errors.MintTokenInvalid(mintRequest.stakeToken, mintRequest.requestToken);\n            }\n            cache.mintToken = pool.baseToken;\n            uint256 collateralPrice = OracleProcess.getLatestUsdUintPrice(\n                mintRequest.requestToken,\n                cache.mintToken,\n                true\n            );\n            Config.StakeCollateralConfig memory collateralConfig = pool.getStakeCollateralConfig(\n                mintRequest.requestToken\n            );\n            if (\n                (collateralConfig.discount + config.getStakeConfig().collateralProtectFactor).mul(10 ** 3) >\n                collateralPrice\n            ) {\n                revert Errors.MintCollateralFailedWithPriceCloseToDiscount();\n            }\n\n            cache.mintFee = FeeQueryProcess.calcMintOrRedeemFee(\n                mintRequest.requestTokenAmount,\n                poolConfig.mintFeeRate\n            );\n            FeeProcess.chargeMintOrRedeemFee(\n                cache.mintFee,\n                mintRequest.stakeToken, \n                mintRequest.requestToken, \n                mintRequest.receiver, \n                FeeProcess.FEE_MINT,\n                true\n            );\n\n            uint256 baseMintTokenAmount = mintRequest.requestTokenAmount - cache.mintFee;\n            if (\n                pool.getCollateralTokenAmount(mintRequest.requestToken) + baseMintTokenAmount >\n                collateralConfig.collateralTotalCap\n            ) {\n                revert Errors.MintCollateralOverflow();\n            }\n            cache.mintTokenAmount = CalUtils.mulRate(baseMintTokenAmount, collateralConfig.discount);\n            cache.mintTokenDecimals = TokenUtils.decimals(cache.mintToken);\n            uint256 minMintStakeAmount = config.getStakeConfig().minPrecisionMultiple.mul(\n                10 ** (cache.mintTokenDecimals - config.getTradeTokenConfig(cache.mintToken).precision)\n            );\n            if (cache.mintTokenAmount < minMintStakeAmount) {\n                revert Errors.MintStakeTokenTooSmall(minMintStakeAmount, cache.mintTokenAmount);\n            }\n            cache.mintStakeAmount = _executeMintStakeToken(mintRequest, pool, cache.mintTokenAmount);\n\n            accountProps.addStakeAmount(mintRequest.stakeToken, cache.mintStakeAmount);\n            accountProps.addStakeLiability(mintRequest.stakeToken, mintRequest.requestToken, cache.mintTokenAmount);\n            accountProps.addCollateralToken(mintRequest.stakeToken, mintRequest.requestToken, baseMintTokenAmount);\n            pool.addCollateralBaseToken(cache.mintTokenAmount, mintRequest.requestToken, baseMintTokenAmount);\n            stakeAmount = cache.mintStakeAmount;\n        } else {\n            cache.mintToken = mintRequest.requestToken;\n            if (pool.baseToken != cache.mintToken) {\n                revert Errors.MintTokenInvalid(mintRequest.stakeToken, mintRequest.requestToken);\n            }\n            cache.mintTokenDecimals = TokenUtils.decimals(cache.mintToken);\n            uint256 minMintStakeAmount = config.getStakeConfig().minPrecisionMultiple.mul(\n                10 ** (cache.mintTokenDecimals - config.getTradeTokenConfig(cache.mintToken).precision)\n            );\n            if (mintRequest.requestTokenAmount < minMintStakeAmount) {\n                revert Errors.MintStakeTokenTooSmall(minMintStakeAmount, mintRequest.requestTokenAmount);\n            }\n\n            cache.mintFee = FeeQueryProcess.calcMintOrRedeemFee(\n                mintRequest.requestTokenAmount,\n                poolConfig.mintFeeRate\n            );\n            FeeProcess.chargeMintOrRedeemFee(\n                cache.mintFee, \n                mintRequest.stakeToken, \n                mintRequest.requestToken, \n                mintRequest.receiver, \n                FeeProcess.FEE_MINT,\n                false\n            );\n\n            cache.mintTokenAmount = mintRequest.requestTokenAmount - cache.mintFee;\n            cache.mintStakeAmount = _executeMintStakeToken(mintRequest, pool, cache.mintTokenAmount);\n            accountProps.addStakeAmount(mintRequest.stakeToken, cache.mintStakeAmount);\n            pool.addBaseToken(cache.mintTokenAmount);\n            stakeAmount = cache.mintStakeAmount;\n        }\n    }\n\n    function _mintStakeUsd(Mint.Request memory mintRequest) internal returns (uint256 mintStakeAmount) {\n        if (!UsdPool.isSupportStableToken(mintRequest.requestToken)) {\n            revert Errors.MintTokenInvalid(mintRequest.stakeToken, mintRequest.requestToken);\n        }\n        Config.Props storage config = Config.load();\n        uint8 mintTokenDecimals = TokenUtils.decimals(mintRequest.requestToken);\n        uint256 minMintStakeAmount = config.getStakeConfig().minPrecisionMultiple.mul(\n            10 ** (mintTokenDecimals - config.getTradeTokenConfig(mintRequest.requestToken).precision)\n        );\n        if (mintRequest.requestTokenAmount < minMintStakeAmount) {\n            revert Errors.MintStakeTokenTooSmall(minMintStakeAmount, mintRequest.requestTokenAmount);\n        }\n        if (mintRequest.walletRequestTokenAmount < mintRequest.requestTokenAmount) {\n            _transferFromAccount(\n                mintRequest.account,\n                mintRequest.requestToken,\n                mintRequest.requestTokenAmount - mintRequest.walletRequestTokenAmount\n            );\n        }\n\n        uint256 mintFees = FeeQueryProcess.calcMintOrRedeemFee(\n            mintRequest.requestTokenAmount,\n            config.getUsdPoolConfig().mintFeeRate\n        );\n        FeeProcess.chargeMintOrRedeemFee(\n            mintFees, \n            mintRequest.stakeToken, \n            mintRequest.requestToken, \n            mintRequest.receiver, \n            FeeProcess.FEE_MINT,\n            false\n        );\n\n        uint256 baseMintAmount = mintRequest.requestTokenAmount - mintFees;\n\n        UsdPool.Props storage pool = UsdPool.load();\n        mintStakeAmount = _executeMintStakeUsd(mintRequest, pool, baseMintAmount);\n\n        StakingAccount.Props storage accountProps = StakingAccount.load(mintRequest.account);\n        accountProps.addStakeUsdAmount(mintStakeAmount);\n        pool.addStableToken(mintRequest.requestToken, baseMintAmount);\n    }\n\n    function _executeMintStakeToken(\n        Mint.Request memory params,\n        LpPool.Props storage pool,\n        uint256 baseMintAmount\n    ) internal returns (uint256) {\n        uint256 mintStakeTokenAmount = computeStakeAmountFromMintToken(pool, baseMintAmount);\n        if (params.minStakeAmount > 0 && mintStakeTokenAmount < params.minStakeAmount) {\n            revert Errors.MintStakeTokenTooSmall(params.minStakeAmount, mintStakeTokenAmount);\n        }\n        StakeToken(params.stakeToken).mint(params.receiver, mintStakeTokenAmount);\n        return mintStakeTokenAmount;\n    }\n\n    function _executeMintStakeUsd(\n        Mint.Request memory params,\n        UsdPool.Props storage pool,\n        uint256 baseMintAmount\n    ) internal returns (uint256) {\n        address stableToken = params.requestToken;\n        uint256 totalSupply = TokenUtils.totalSupply(params.stakeToken);\n        uint8 tokenDecimals = TokenUtils.decimals(stableToken);\n        uint8 stakeTokenDecimals = TokenUtils.decimals(params.stakeToken);\n        uint256 poolValue = pool.getUsdPoolValue();\n        uint256 mintStakeTokenAmount;\n        if (totalSupply == 0 && poolValue == 0) {\n            mintStakeTokenAmount = CalUtils.decimalsToDecimals(baseMintAmount, tokenDecimals, stakeTokenDecimals);\n        } else if (totalSupply == 0 && poolValue > 0) {\n            uint256 totalBaseMintAmount = baseMintAmount +\n                CalUtils.usdToToken(poolValue, tokenDecimals, OracleProcess.getLatestUsdUintPrice(stableToken, true));\n            mintStakeTokenAmount = CalUtils.decimalsToDecimals(totalBaseMintAmount, tokenDecimals, stakeTokenDecimals);\n        } else if (poolValue == 0) {\n            revert Errors.PoolValueIsZero();\n        } else {\n            uint256 baseMintAmountInUsd = CalUtils.tokenToUsd(\n                baseMintAmount,\n                tokenDecimals,\n                OracleProcess.getLatestUsdUintPrice(stableToken, true)\n            );\n            mintStakeTokenAmount = totalSupply.mul(baseMintAmountInUsd).div(poolValue);\n        }\n        if (params.minStakeAmount > 0 && mintStakeTokenAmount < params.minStakeAmount) {\n            revert Errors.MintStakeTokenTooSmall(params.minStakeAmount, mintStakeTokenAmount);\n        }\n\n        StakeToken(params.stakeToken).mint(params.receiver, mintStakeTokenAmount);\n\n        return mintStakeTokenAmount; \n    }\n\n    function _transferFromAccount(address account, address token, uint256 needAmount) internal {\n        Account.Props storage tradeAccount = Account.load(account);\n        if (tradeAccount.getTokenAmount(token) < needAmount) {\n            revert Errors.MintFailedWithBalanceNotEnough(account, token);\n        }\n        tradeAccount.subTokenIgnoreUsedAmount(token, needAmount);\n        int256 availableValue = tradeAccount.getCrossAvailableValue();\n        if (\n            availableValue < 0\n        ) {\n            revert Errors.MintFailedWithBalanceNotEnough(account, token);\n        }\n    }\n\n    function computeStakeAmountFromMintToken(\n        LpPool.Props storage pool,\n        uint256 mintAmount\n    ) public view returns (uint256) {\n        uint256 totalSupply = TokenUtils.totalSupply(pool.stakeToken);\n        uint8 tokenDecimals = TokenUtils.decimals(pool.baseToken);\n        uint256 poolValue = pool.getPoolValue();\n        uint256 mintStakeTokenAmount;\n        if (totalSupply == 0 && poolValue == 0) {\n            mintStakeTokenAmount = mintAmount;\n        } else if (totalSupply == 0 && poolValue > 0) {\n            mintStakeTokenAmount =\n                mintAmount +\n                CalUtils.usdToToken(\n                    poolValue,\n                    tokenDecimals,\n                    OracleProcess.getLatestUsdUintPrice(pool.baseToken, true)\n                );\n        } else if (poolValue == 0) {\n            revert Errors.PoolValueIsZero();\n        } else {\n            uint256 baseMintAmountInUsd = CalUtils.tokenToUsd(\n                mintAmount,\n                tokenDecimals,\n                OracleProcess.getLatestUsdUintPrice(pool.baseToken, true)\n            );\n            mintStakeTokenAmount = totalSupply.mul(baseMintAmountInUsd).div(poolValue);\n        }\n        return mintStakeTokenAmount;\n    }\n}\n"
    },
    "contracts/process/OracleProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../storage/OracleFeed.sol\";\nimport \"../storage/OraclePrice.sol\";\nimport \"../utils/AddressUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary OracleProcess {\n    using OraclePrice for OraclePrice.Props;\n    using SafeCast for int256;\n\n    struct OracleParam {\n        address token;\n        address targetToken;\n        int256 minPrice;\n        int256 maxPrice;\n    }\n\n    function setOraclePrice(OracleParam[] calldata params) external {\n        OraclePrice.Props storage oracle = OraclePrice.load();\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].targetToken == address(0)) {\n                oracle.setPrice(params[i].token, OraclePrice.Data(params[i].minPrice, params[i].maxPrice));\n            } else {\n                oracle.setPrice(\n                    params[i].token,\n                    params[i].targetToken,\n                    OraclePrice.Data(params[i].minPrice, params[i].maxPrice)\n                );\n            }\n        }\n    }\n\n    function getIntOraclePrices(OracleParam[] memory params, address token, bool isMin) external view returns (int256) {\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].token == token) {\n                return isMin ? params[i].minPrice : params[i].maxPrice;\n            }\n        }\n        return getLatestUsdPrice(token, isMin);\n    }\n\n    function getIntOraclePrices(\n        OracleParam[] memory params,\n        address token,\n        address targetToken,\n        bool isMin\n    ) external view returns (int256) {\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].token == token && params[i].targetToken == targetToken) {\n                return isMin ? params[i].minPrice : params[i].maxPrice;\n            }\n        }\n        return getLatestUsdPrice(token, targetToken, isMin);\n    }\n\n    function getOraclePrices(OracleParam[] memory params, address token, bool isMin) external view returns (uint256) {\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].token == token) {\n                return isMin ? uint256(params[i].minPrice) : uint256(params[i].maxPrice);\n            }\n        }\n        return getLatestUsdUintPrice(token, isMin);\n    }\n\n    function getOraclePrices(\n        OracleParam[] memory params,\n        address token,\n        address targetToken,\n        bool isMin\n    ) external view returns (uint256) {\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].token == token) {\n                return isMin ? uint256(params[i].minPrice) : uint256(params[i].maxPrice);\n            }\n        }\n        return getLatestUsdUintPrice(token, targetToken, isMin);\n    }\n\n    function clearOraclePrice() external {\n        OraclePrice.load().clearAllPrice();\n    }\n\n    function getLatestUsdUintPrice(address token, address targetToken, bool min) public view returns (uint256) {\n        return getLatestUsdPrice(token, targetToken, min).toUint256();\n    }\n\n    function getLatestUsdPrice(address token, address targetToken, bool min) public view returns (int256) {\n        OraclePrice.Props storage oracle = OraclePrice.load();\n        OraclePrice.Data memory tokenPrice = oracle.getPrice(token, targetToken);\n        if (tokenPrice.min == 0 || tokenPrice.max == 0) {\n            revert Errors.PriceIsZero();\n        }\n        return min ? tokenPrice.min : tokenPrice.max;\n    }\n\n    function getLatestUsdPrice(address token, bool min) public view returns (int256) {\n        OraclePrice.Data memory data = _getLatestUsdPriceWithOracle(token);\n        return min ? data.min : data.max;\n    }\n\n    function getLatestUsdUintPrice(address token, bool min) public view returns (uint256) {\n        OraclePrice.Data memory data = _getLatestUsdPriceWithOracle(token);\n        return min ? uint256(data.min) : uint256(data.max);\n    }\n\n    function getLatestUsdPrice(address token) public view returns (OraclePrice.Data memory) {\n        return _getLatestUsdPriceWithOracle(token);\n    }\n\n    function getLatestUsdUintPrice(address token) public view returns (uint256 min, uint256 max) {\n        OraclePrice.Data memory data = _getLatestUsdPriceWithOracle(token);\n        return (uint256(data.min), uint256(data.max));\n    }\n\n    function _getLatestUsdPriceWithOracle(address token) internal view returns (OraclePrice.Data memory) {\n        OraclePrice.Props storage oracle = OraclePrice.load();\n        OraclePrice.Data memory tokenPrice = oracle.getPrice(token);\n        if (tokenPrice.min == 0 || tokenPrice.max == 0) {\n            revert Errors.PriceIsZero();\n        }\n        return tokenPrice;\n    }\n}\n"
    },
    "contracts/process/OrderProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IOrder.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/Order.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../vault/TradeVault.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/AddressUtils.sol\";\nimport \"../utils/CommonUtils.sol\";\nimport \"./DecreasePositionProcess.sol\";\nimport \"./IncreasePositionProcess.sol\";\nimport \"./AccountProcess.sol\";\nimport \"./AssetsProcess.sol\";\nimport \"./GasProcess.sol\";\nimport \"./LpPoolProcess.sol\";\nimport \"./FeeProcess.sol\";\nimport \"./VaultProcess.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary OrderProcess {\n    using Config for Config.Props;\n    using Order for Order.Props;\n    using Position for Position.Props;\n    using IncreasePositionProcess for Position.Props;\n    using DecreasePositionProcess for Position.Props;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n    using Symbol for Symbol.Props;\n    using SafeMath for uint256;\n\n    bytes32 constant ORDER_ID_KEY = keccak256(\"ORDER_ID_KEY\");\n\n    event PlaceOrderEvent(uint256 indexed orderId, Order.OrderInfo data);\n    event OrderFilledEvent(uint256 indexed orderId, Order.OrderInfo data, uint256 fillTime, uint256 fillPrice);\n    event CancelOrderEvent(uint256 indexed orderId, Order.OrderInfo data, bytes32 reasonCode);\n\n    struct ExecuteOrderParams {\n        uint256 orderId;\n        address keeper;\n    }\n\n    struct ExecuteIncreaseOrderCache {\n        uint256 executionPrice;\n        uint256 orderMargin;\n        uint256 orderMarginFromBalance;\n        address marginToken;\n        uint256 marginTokenPrice;\n        bool isLong;\n    }\n\n    event ExecuteOrderStartEvent(\n        uint256 orderId,\n        bytes32 symbol,\n        address marginToken,\n        bool updateLongOrShortPosition,\n        uint256 marginTokenPrice,\n        uint256 updateTimestamp\n    );\n\n    function createOrderRequest(\n        Account.Props storage accountProps,\n        IOrder.PlaceOrderParams calldata params,\n        bool validateExecutionFee\n    ) external {\n        _validatePlaceOrder(params);\n        if (\n            params.posSide == Order.PositionSide.INCREASE &&\n            params.orderSide == Order.Side.SHORT &&\n            (PositionQueryProcess.hasOtherShortPosition(\n                accountProps.owner,\n                params.symbol,\n                params.marginToken,\n                params.isCrossMargin\n            ) ||\n                Order.hasOtherShortOrders(\n                    accountProps.getAllOrders(),\n                    params.symbol,\n                    params.marginToken,\n                    params.isCrossMargin\n                ))\n        ) {\n            revert Errors.OnlyOneShortPositionSupport(params.symbol);\n        }\n\n        (uint256 orderMargin, bool isExecutionFeeFromTradeVault) = validateExecutionFee\n            ? _validateGasFeeLimitAndInitialMargin(accountProps, params)\n            : (params.orderMargin, false);\n\n        uint256 orderId = UuidCreator.nextId(ORDER_ID_KEY);\n        Order.OrderInfo storage order = Order.create(orderId);\n        order.account = accountProps.owner;\n        order.symbol = params.symbol;\n        order.orderSide = params.orderSide;\n        order.posSide = params.posSide;\n        order.orderType = params.orderType;\n        order.marginToken = params.marginToken;\n        order.orderMargin = orderMargin;\n        order.qty = params.qty;\n        order.triggerPrice = params.triggerPrice;\n        order.acceptablePrice = params.acceptablePrice;\n        order.stopType = params.stopType;\n        order.isCrossMargin = params.isCrossMargin;\n        order.isExecutionFeeFromTradeVault = isExecutionFeeFromTradeVault;\n        order.executionFee = params.executionFee;\n        order.leverage = params.leverage;\n        order.placeTime = params.placeTime;\n        order.lastBlock = ChainUtils.currentBlock();\n        if (Order.PositionSide.INCREASE == params.posSide && order.isCrossMargin) {\n            accountProps.addOrderHoldInUsd(orderMargin);\n        }\n        accountProps.addOrder(orderId);\n        emit PlaceOrderEvent(orderId, order);\n    }\n\n    function executeOrder(uint256 orderId, Order.OrderInfo memory order) external {\n        Config.Props storage config = Config.load();\n\n        // verify block no\n        if (Order.Type.MARKET == order.orderType) {\n            CommonUtils.validBlockNumber(\n                order.lastBlock,\n                config.tradeConfig.executeOrderMinBlockGap,\n                config.tradeConfig.executeOrderMaxBlockGap\n            );\n        } else if (Order.Type.LIMIT == order.orderType) {\n            CommonUtils.validMinBlockNumber(order.lastBlock, config.tradeConfig.executeOrderMinBlockGap);\n        }\n\n        Symbol.Props memory symbolProps = Symbol.load(order.symbol);\n\n        _validExecuteOrder(order, symbolProps);\n        if (Order.PositionSide.INCREASE == order.posSide) {\n            _executeIncreaseOrder(orderId, order, symbolProps);\n        } else if (Order.PositionSide.DECREASE == order.posSide) {\n            _executeDecreaseOrder(orderId, order, symbolProps);\n        }\n        Order.remove(orderId);\n    }\n\n    function _executeIncreaseOrder(\n        uint256 orderId,\n        Order.OrderInfo memory order,\n        Symbol.Props memory symbolProps\n    ) internal {\n        if (\n            order.posSide == Order.PositionSide.INCREASE &&\n            order.orderSide == Order.Side.SHORT &&\n            PositionQueryProcess.hasOtherShortPosition(\n                order.account,\n                order.symbol,\n                order.marginToken,\n                order.isCrossMargin\n            )\n        ) {\n            revert Errors.OnlyOneShortPositionSupport(order.symbol);\n        }\n        Account.Props storage accountProps = Account.load(order.account);\n\n        ExecuteIncreaseOrderCache memory cache;\n        cache.isLong = Order.Side.LONG == order.orderSide;\n\n        emit ExecuteOrderStartEvent(\n            orderId,\n            symbolProps.code,\n            order.marginToken,\n            cache.isLong,\n            OracleProcess.getLatestUsdUintPrice(order.marginToken, !cache.isLong),\n            ChainUtils.currentTimestamp()\n        );\n\n        MarketProcess.updateMarketFundingFeeRate(symbolProps.code);\n        MarketProcess.updatePoolBorrowingFeeRate(symbolProps.stakeToken, cache.isLong, order.marginToken);\n\n        cache.executionPrice = _getExecutionPrice(order, symbolProps.indexToken);\n        if (symbolProps.indexToken == order.marginToken) {\n            cache.marginTokenPrice = cache.executionPrice;\n        } else {\n            cache.marginTokenPrice = OracleProcess.getLatestUsdUintPrice(order.marginToken, !cache.isLong);\n        }\n\n        (cache.orderMargin, cache.orderMarginFromBalance) = _executeIncreaseOrderMargin(\n            order,\n            accountProps,\n            cache.marginTokenPrice\n        );\n\n        if (!order.isCrossMargin) {\n            VaultProcess.transferOut(\n                IVault(address(this)).getTradeVaultAddress(),\n                order.marginToken,\n                symbolProps.stakeToken,\n                cache.orderMargin\n            );\n        }\n\n        Position.Props storage positionProps = Position.load(\n            order.account,\n            symbolProps.code,\n            order.marginToken,\n            order.isCrossMargin\n        );\n        if (positionProps.qty == 0) {\n            if (\n                accountProps.hasOtherOrder(orderId) &&\n                getOrderLeverage(\n                    accountProps,\n                    symbolProps.code,\n                    order.orderSide,\n                    order.isCrossMargin,\n                    order.leverage\n                ) !=\n                order.leverage\n            ) {\n                revert Errors.UpdateLeverageError(\n                    order.account,\n                    symbolProps.code,\n                    Order.Side.LONG == order.orderSide,\n                    getOrderLeverage(\n                        accountProps,\n                        symbolProps.code,\n                        order.orderSide,\n                        order.isCrossMargin,\n                        order.leverage\n                    ),\n                    order.leverage\n                );\n            }\n            bytes32 key = Position.getPositionKey(\n                order.account,\n                symbolProps.code,\n                order.marginToken,\n                order.isCrossMargin\n            );\n            positionProps.key = key;\n            positionProps.account = order.account;\n            positionProps.indexToken = symbolProps.indexToken;\n            positionProps.symbol = symbolProps.code;\n            positionProps.marginToken = order.marginToken;\n            positionProps.leverage = order.leverage;\n            positionProps.isLong = cache.isLong;\n            positionProps.isCrossMargin = order.isCrossMargin;\n            accountProps.addPosition(key);\n        } else if (positionProps.leverage != order.leverage) {\n            revert Errors.UpdateLeverageError(\n                order.account,\n                symbolProps.code,\n                Order.Side.LONG == order.orderSide,\n                positionProps.leverage,\n                order.leverage\n            );\n        }\n        positionProps.increasePosition(\n            symbolProps,\n            IncreasePositionProcess.IncreasePositionParams(\n                orderId,\n                order.marginToken,\n                cache.orderMargin,\n                cache.orderMarginFromBalance,\n                cache.marginTokenPrice,\n                cache.executionPrice,\n                order.leverage,\n                cache.isLong,\n                order.isCrossMargin\n            )\n        );\n        accountProps.delOrder(orderId);\n\n        emit OrderFilledEvent(orderId, order, block.timestamp, cache.executionPrice);\n    }\n\n    function _getExecutionPrice(Order.OrderInfo memory order, address indexToken) internal view returns (uint256) {\n        bool isMinPrice;\n        if (Order.PositionSide.INCREASE == order.posSide) {\n            isMinPrice = Order.Side.SHORT == order.orderSide;\n        } else {\n            isMinPrice = Order.Side.LONG == order.orderSide;\n        }\n        if (Order.Type.MARKET == order.orderType) {\n            uint256 indexPrice = OracleProcess.getLatestUsdUintPrice(indexToken, isMinPrice);\n            if (\n                (isMinPrice && order.acceptablePrice > 0 && indexPrice < order.acceptablePrice) ||\n                (!isMinPrice && order.acceptablePrice > 0 && indexPrice > order.acceptablePrice)\n            ) {\n                revert Errors.ExecutionPriceInvalid();\n            }\n            return indexPrice;\n        }\n        uint256 currentPrice = OracleProcess.getLatestUsdUintPrice(indexToken, isMinPrice);\n        bool isLong = Order.Side.LONG == order.orderSide;\n        if (\n            Order.Type.LIMIT == order.orderType ||\n            (Order.Type.STOP == order.orderType && Order.StopType.TAKE_PROFIT == order.stopType)\n        ) {\n            if ((isLong && order.triggerPrice >= currentPrice) || (!isLong && order.triggerPrice <= currentPrice)) {\n                return currentPrice;\n            }\n            revert Errors.ExecutionPriceInvalid();\n        }\n        if (Order.Type.STOP == order.orderType && Order.StopType.STOP_LOSS == order.stopType) {\n            if ((isLong && order.triggerPrice <= currentPrice) || (!isLong && order.triggerPrice >= currentPrice)) {\n                return currentPrice;\n            }\n            revert Errors.ExecutionPriceInvalid();\n        }\n        revert Errors.ExecutionPriceInvalid();\n    }\n\n    function _executeIncreaseOrderMargin(\n        Order.OrderInfo memory order,\n        Account.Props storage accountProps,\n        uint256 marginTokenPrice\n    ) internal returns (uint256 orderMargin, uint256 orderMarginFromBalance) {\n        address marginToken = order.marginToken;\n        address account = accountProps.owner;\n        if (order.isCrossMargin) {\n            if (accountProps.getCrossAvailableValue() < 0) {\n                revert Errors.BalanceNotEnough(account, marginToken);\n            }\n            if (order.orderMargin < Config.load().getTradeConfig().minOrderMarginUSD) {\n                revert Errors.OrderMarginTooSmall();\n            }\n            orderMargin = CalUtils.usdToToken(order.orderMargin, TokenUtils.decimals(marginToken), marginTokenPrice);\n            accountProps.subOrderHoldInUsd(order.orderMargin);\n            orderMarginFromBalance = accountProps.useToken(marginToken, orderMargin);\n        } else {\n            uint256 orderMarginInUsd = CalUtils.tokenToUsd(\n                order.orderMargin,\n                TokenUtils.decimals(marginToken),\n                marginTokenPrice\n            );\n            if (orderMarginInUsd < Config.load().getTradeConfig().minOrderMarginUSD) {\n                revert Errors.OrderMarginTooSmall();\n            }\n            orderMargin = order.orderMargin;\n            orderMarginFromBalance = order.orderMargin;\n        }\n    }\n\n    function _isUserPlaceOrder(Order.Type orderType) internal pure returns (bool) {\n        return Order.Type.LIMIT == orderType || Order.Type.MARKET == orderType || Order.Type.STOP == orderType;\n    }\n\n    function _validExecuteOrder(Order.OrderInfo memory order, Symbol.Props memory symbolProps) internal view {\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(symbolProps.code);\n        bool isIncrease = Order.PositionSide.INCREASE == order.posSide;\n        bool isLong = Order.Side.LONG == order.orderSide;\n        if (_isUserPlaceOrder(order.orderType) && isIncrease && Symbol.Status.OPEN != symbolProps.status) {\n            revert Errors.SymbolStatusInvalid(order.symbol);\n        }\n\n        // token verify\n        if (isIncrease) {\n            if (isLong && order.marginToken != symbolProps.baseToken) {\n                revert Errors.TokenInvalid(order.symbol, order.marginToken);\n            }\n            if (!isLong && !UsdPool.isSupportStableToken(order.marginToken)) {\n                revert Errors.TokenInvalid(order.symbol, order.marginToken);\n            }\n        }\n\n        if (order.leverage > symbolConfig.maxLeverage || order.leverage < 1 * CalUtils.RATE_PRECISION) {\n            revert Errors.LeverageInvalid(order.symbol, order.leverage);\n        }\n    }\n\n    function getOrderLeverage(\n        Account.Props storage accountProps,\n        bytes32 symbol,\n        Order.Side orderSide,\n        bool isCrossMargin,\n        uint256 defaultLeverage\n    ) internal view returns (uint256) {\n        uint256[] memory orders = accountProps.getAllOrders();\n        Order.Props storage orderProps = Order.load();\n        for (uint256 i; i < orders.length; i++) {\n            Order.OrderInfo memory orderInfo = orderProps.get(orders[i]);\n            if (\n                orderInfo.symbol == symbol &&\n                orderInfo.orderSide == orderSide &&\n                orderInfo.isCrossMargin == isCrossMargin\n            ) {\n                return orderInfo.leverage;\n            }\n        }\n        return defaultLeverage;\n    }\n\n    function _validatePlaceOrder(IOrder.PlaceOrderParams calldata params) internal view {\n        if (\n            Order.Type.MARKET != params.orderType &&\n            Order.Type.LIMIT != params.orderType &&\n            Order.Type.STOP != params.orderType\n        ) {\n            revert Errors.PlaceOrderWithParamsError();\n        }\n\n        if (Order.PositionSide.DECREASE == params.posSide && params.qty == 0) {\n            revert Errors.PlaceOrderWithParamsError();\n        }\n\n        if (Order.Side.NONE == params.orderSide) {\n            revert Errors.PlaceOrderWithParamsError();\n        }\n\n        if (Order.Type.LIMIT == params.orderType && params.triggerPrice == 0) {\n            revert Errors.PlaceOrderWithParamsError();\n        }\n\n        if (Order.Type.LIMIT == params.orderType && Order.PositionSide.DECREASE == params.posSide) {\n            revert Errors.PlaceOrderWithParamsError();\n        }\n\n        if (\n            Order.Type.STOP == params.orderType && (Order.StopType.NONE == params.stopType || params.triggerPrice == 0)\n        ) {\n            revert Errors.PlaceOrderWithParamsError();\n        }\n\n        if (Order.PositionSide.INCREASE == params.posSide) {\n            if (params.orderMargin == 0) {\n                console.log(\"params.orderMargin\", params.orderMargin);\n                revert Errors.PlaceOrderWithParamsError();\n            }\n            Symbol.Props storage symbolProps = Symbol.load(params.symbol);\n            if (!symbolProps.isSupportIncreaseOrder()) {\n                revert Errors.SymbolStatusInvalid(params.symbol);\n            }\n            if (Order.Side.LONG == params.orderSide && params.marginToken != symbolProps.baseToken) {\n                revert Errors.PlaceOrderWithParamsError();\n            }\n            if (Order.Side.SHORT == params.orderSide && !UsdPool.isSupportStableToken(params.marginToken)) {\n                revert Errors.PlaceOrderWithParamsError();\n            }\n        }\n    }\n\n    function _executeDecreaseOrder(\n        uint256 orderId,\n        Order.OrderInfo memory order,\n        Symbol.Props memory symbolProps\n    ) internal {\n        address account = order.account;\n        bool isLong = Order.Side.LONG == order.orderSide;\n\n        Position.Props storage position = Position.load(account, order.symbol, order.marginToken, order.isCrossMargin);\n        position.checkExists();\n\n        if (Order.Type.MARKET == order.orderType && position.qty < order.qty) {\n            revert Errors.DecreaseQtyTooBig(symbolProps.code, position.account);\n        }\n        if (position.qty > order.qty && position.qty - order.qty < Config.load().getTradeConfig().minOrderMarginUSD) {\n            revert Errors.ReducePositionTooSmall(symbolProps.code, position.account);\n        }\n        if (position.isLong == isLong) {\n            revert Errors.DecreaseOrderSideInvalid();\n        }\n\n        if (Order.Type.STOP == order.orderType && position.qty < order.qty) {\n            order.qty = position.qty;\n        }\n\n        emit ExecuteOrderStartEvent(\n            orderId,\n            symbolProps.code,\n            order.marginToken,\n            position.isLong,\n            OracleProcess.getLatestUsdUintPrice(order.marginToken, position.isLong),\n            ChainUtils.currentTimestamp()\n        );\n\n        MarketProcess.updateMarketFundingFeeRate(symbolProps.code);\n        MarketProcess.updatePoolBorrowingFeeRate(symbolProps.stakeToken, position.isLong, order.marginToken);\n\n        uint256 executionPrice = _getExecutionPrice(order, symbolProps.indexToken);\n\n        position.decreasePosition(\n            DecreasePositionProcess.DecreasePositionParams(\n                orderId,\n                order.symbol,\n                false,\n                false,\n                order.marginToken,\n                order.qty,\n                executionPrice\n            )\n        );\n        Account.load(order.account).delOrder(orderId);\n        emit OrderFilledEvent(orderId, order, block.timestamp, executionPrice);\n    }\n\n    function _validateGasFeeLimitAndInitialMargin(\n        Account.Props storage accountProps,\n        IOrder.PlaceOrderParams calldata params\n    ) internal returns (uint256, bool) {\n        Config.ChainConfig memory chainConfig = Config.getChainConfig();\n        uint256 configGasFeeLimit = Order.PositionSide.INCREASE == params.posSide\n            ? chainConfig.placeIncreaseOrderGasFeeLimit\n            : chainConfig.placeDecreaseOrderGasFeeLimit;\n        GasProcess.validateExecutionFeeLimit(params.executionFee, configGasFeeLimit);\n        if (\n            params.isNativeToken &&\n            params.posSide == Order.PositionSide.INCREASE &&\n            !params.isCrossMargin &&\n            params.orderMargin >= params.executionFee\n        ) {\n            return (params.orderMargin - params.executionFee, true);\n        }\n        require(msg.value == params.executionFee, \"place order with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                accountProps.owner,\n                chainConfig.wrapperToken,\n                params.executionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n        return (params.orderMargin, false);\n    }\n\n    function _validateBatchGasFeeLimit(\n        Account.Props storage accountProps,\n        IOrder.PlaceOrderParams calldata params\n    ) internal returns (uint256, bool) {\n        Config.ChainConfig memory chainConfig = Config.getChainConfig();\n        uint256 configGasFeeLimit = Order.PositionSide.INCREASE == params.posSide\n            ? chainConfig.placeIncreaseOrderGasFeeLimit\n            : chainConfig.placeDecreaseOrderGasFeeLimit;\n        GasProcess.validateExecutionFeeLimit(params.executionFee, configGasFeeLimit);\n        if (\n            params.isNativeToken &&\n            params.posSide == Order.PositionSide.INCREASE &&\n            !params.isCrossMargin &&\n            params.orderMargin >= params.executionFee\n        ) {\n            accountProps.subTokenIgnoreUsedAmount(chainConfig.wrapperToken, params.executionFee);\n            return (params.orderMargin - params.executionFee, true);\n        }\n        require(msg.value == params.executionFee, \"place order with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                accountProps.owner,\n                chainConfig.wrapperToken,\n                params.executionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n        return (params.orderMargin, false);\n    }\n}\n"
    },
    "contracts/process/PositionMarginProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport \"../storage/Position.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/UpdatePositionMargin.sol\";\nimport \"../storage/UpdateLeverage.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../storage/Order.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"../utils/CommonUtils.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./LpPoolProcess.sol\";\nimport \"./FeeProcess.sol\";\nimport \"./VaultProcess.sol\";\nimport \"./AccountProcess.sol\";\n\nlibrary PositionMarginProcess {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedSafeMath for int256;\n    using Math for uint256;\n    using Config for Config.Props;\n    using Position for Position.Props;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n\n    bytes32 constant UPDATE_MARGIN_ID_KEY = keccak256(\"UPDATE_MARGIN_ID_KEY\");\n    bytes32 constant UPDATE_LEVERAGE_ID_KEY = keccak256(\"UPDATE_LEVERAGE_ID_KEY\");\n\n    event CreateUpdateLeverageEvent(uint256 indexed requestId, UpdateLeverage.Request data);\n    event CreateUpdatePositionMarginEvent(uint256 indexed requestId, UpdatePositionMargin.Request data);\n    event UpdatePositionMarginSuccessEvent(uint256 indexed requestId, UpdatePositionMargin.Request data);\n    event UpdateLeverageSuccessEvent(uint256 indexed requestId, UpdateLeverage.Request data);\n    event CancelUpdateLeverageEvent(uint256 indexed requestId, UpdateLeverage.Request data, bytes32 reasonCode);\n    event CancelUpdatePositionMarginEvent(\n        uint256 indexed requestId,\n        UpdatePositionMargin.Request data,\n        bytes32 reasonCode\n    );\n\n    struct AddPositionMarginCache {\n        address stakeToken;\n        uint256 addMarginAmount;\n        uint256 marginTokenPrice;\n        uint8 marginTokenDecimals;\n        bool isCrossMargin;\n        uint256 addInitialMarginFromBalance;\n    }\n\n    function createUpdatePositionMarginRequest(\n        address account,\n        IPosition.UpdatePositionMarginParams memory params,\n        uint256 updateMarginAmount,\n        bool isExecutionFeeFromTradeVault\n    ) external {\n        uint256 requestId = UuidCreator.nextId(UPDATE_MARGIN_ID_KEY);\n        UpdatePositionMargin.Request storage request = UpdatePositionMargin.create(requestId);\n        request.account = account;\n        request.positionKey = params.positionKey;\n        request.marginToken = params.marginToken;\n        request.updateMarginAmount = updateMarginAmount;\n        request.isAdd = params.isAdd;\n        request.isExecutionFeeFromTradeVault = isExecutionFeeFromTradeVault;\n        request.executionFee = params.executionFee;\n        request.lastBlock = ChainUtils.currentBlock();\n        emit CreateUpdatePositionMarginEvent(requestId, request);\n    }\n\n    function createUpdateLeverageRequest(\n        address account,\n        IPosition.UpdateLeverageParams memory params,\n        uint256 addMarginAmount,\n        bool isExecutionFeeFromTradeVault\n    ) external {\n        uint256 requestId = UuidCreator.nextId(UPDATE_LEVERAGE_ID_KEY);\n        UpdateLeverage.Request storage request = UpdateLeverage.create(requestId);\n        request.account = account;\n        request.symbol = params.symbol;\n        request.marginToken = params.marginToken;\n        request.addMarginAmount = addMarginAmount;\n        request.leverage = params.leverage;\n        request.isLong = params.isLong;\n        request.isExecutionFeeFromTradeVault = isExecutionFeeFromTradeVault;\n        request.executionFee = params.executionFee;\n        request.lastBlock = ChainUtils.currentBlock();\n        request.isCrossMargin = params.isCrossMargin;\n\n        emit CreateUpdateLeverageEvent(requestId, request);\n    }\n\n    function updatePositionMargin(uint256 requestId, UpdatePositionMargin.Request memory request) external {\n        Config.Props storage config = Config.load();\n        CommonUtils.validBlockNumber(\n            request.lastBlock,\n            config.tradeConfig.executePositionMarginMinBlockGap,\n            config.tradeConfig.executePositionMarginMaxBlockGap\n        );\n        Position.Props storage position = Position.load(request.positionKey);\n        position.checkExists();\n        if (position.isCrossMargin) {\n            revert Errors.OnlyIsolateSupported();\n        }\n        Symbol.Props memory symbolProps = Symbol.load(position.symbol);\n        Account.Props storage accountProps = Account.load(request.account);\n        if (request.isAdd) {\n            AddPositionMarginCache memory cache;\n            cache.stakeToken = symbolProps.stakeToken;\n            cache.addMarginAmount = request.updateMarginAmount;\n            cache.marginTokenDecimals = TokenUtils.decimals(position.marginToken);\n            cache.marginTokenPrice = OracleProcess.getLatestUsdUintPrice(position.marginToken, !position.isLong);\n            cache.isCrossMargin = false;\n            _executeAddMargin(position, cache);\n            VaultProcess.transferOut(\n                IVault(address(this)).getTradeVaultAddress(),\n                request.marginToken,\n                symbolProps.stakeToken,\n                cache.addMarginAmount\n            );\n            position.emitPositionUpdateEvent(requestId, Position.PositionUpdateFrom.ADD_MARGIN, 0);\n        } else {\n            uint256 reduceMarginAmount = _executeReduceMargin(\n                position,\n                symbolProps,\n                config,\n                request.updateMarginAmount,\n                true\n            );\n            VaultProcess.transferOut(symbolProps.stakeToken, request.marginToken, request.account, reduceMarginAmount);\n            position.emitPositionUpdateEvent(requestId, Position.PositionUpdateFrom.DECREASE_MARGIN, 0);\n        }\n        Order.updateAllOrderLeverage(\n            accountProps.getAllOrders(),\n            position.symbol,\n            position.marginToken,\n            position.leverage,\n            position.isLong,\n            position.isCrossMargin\n        );\n\n        emit UpdatePositionMarginSuccessEvent(requestId, request);\n    }\n\n    function updatePositionLeverage(uint256 requestId, UpdateLeverage.Request memory request) external {\n        Config.Props storage config = Config.load();\n        CommonUtils.validBlockNumber(\n            request.lastBlock,\n            config.tradeConfig.executeLeverageMinBlockGap,\n            config.tradeConfig.executeLeverageMaxBlockGap\n        );\n        bytes32 positionKey = Position.getPositionKey(\n            request.account,\n            request.symbol,\n            request.marginToken,\n            request.isCrossMargin\n        );\n\n        Position.Props storage position = Position.load(positionKey);\n        if (position.leverage == request.leverage) {\n            revert Errors.UpdateLeverageWithNoChange();\n        }\n\n        Symbol.Props memory symbolProps = Symbol.load(request.symbol);\n        Account.Props storage accountProps = Account.load(request.account);\n\n        if (position.qty != 0) {\n            if (position.leverage > request.leverage) {\n                AddPositionMarginCache memory cache;\n                cache.stakeToken = symbolProps.stakeToken;\n                cache.marginTokenDecimals = TokenUtils.decimals(request.marginToken);\n                cache.marginTokenPrice = OracleProcess.getLatestUsdUintPrice(position.marginToken, !position.isLong);\n                cache.isCrossMargin = position.isCrossMargin;\n                if (cache.isCrossMargin) {\n                    position.leverage = request.leverage;\n                    uint256 newInitialMarginInUsd = CalUtils.divRate(position.qty, position.leverage);\n                    uint256 addMarginInUsd = newInitialMarginInUsd > position.initialMarginInUsd\n                        ? newInitialMarginInUsd - position.initialMarginInUsd\n                        : 0;\n                    if (addMarginInUsd.toInt256() > accountProps.getCrossAvailableValue()) {\n                        revert Errors.BalanceNotEnough(request.account, position.marginToken);\n                    }\n                    cache.addMarginAmount = CalUtils.usdToToken(\n                        addMarginInUsd,\n                        cache.marginTokenDecimals,\n                        cache.marginTokenPrice\n                    );\n                    cache.addInitialMarginFromBalance = CalUtils.tokenToUsd(\n                        cache.addMarginAmount.min(accountProps.getAvailableTokenAmount(position.marginToken)),\n                        cache.marginTokenDecimals,\n                        cache.marginTokenPrice\n                    );\n                    accountProps.useToken(position.marginToken, cache.addMarginAmount);\n                } else {\n                    cache.addMarginAmount = request.addMarginAmount;\n                }\n                _executeAddMargin(position, cache);\n                if (!cache.isCrossMargin) {\n                    VaultProcess.transferOut(\n                        IVault(address(this)).getTradeVaultAddress(),\n                        position.marginToken,\n                        symbolProps.stakeToken,\n                        cache.addMarginAmount\n                    );\n                }\n                position.emitPositionUpdateEvent(requestId, Position.PositionUpdateFrom.DECREASE_LEVERAGE, 0);\n            } else {\n                position.leverage = request.leverage;\n                uint256 reduceMargin = position.initialMarginInUsd - CalUtils.divRate(position.qty, position.leverage);\n                uint256 reduceMarginAmount = _executeReduceMargin(position, symbolProps, config, reduceMargin, false);\n                if (position.isCrossMargin) {\n                    accountProps.unUseToken(position.marginToken, reduceMarginAmount);\n                } else {\n                    VaultProcess.transferOut(\n                        symbolProps.stakeToken,\n                        request.marginToken,\n                        request.account,\n                        reduceMarginAmount\n                    );\n                }\n                position.emitPositionUpdateEvent(requestId, Position.PositionUpdateFrom.INCREASE_LEVERAGE, 0);\n            }\n        }\n\n        Order.updateAllOrderLeverage(\n            accountProps.getAllOrders(),\n            request.symbol,\n            request.marginToken,\n            request.leverage,\n            request.isLong,\n            request.isCrossMargin\n        );\n\n        emit UpdateLeverageSuccessEvent(requestId, request);\n    }\n\n    function cancelUpdatePositionMarginRequest(\n        uint256 requestId,\n        UpdatePositionMargin.Request memory request,\n        bytes32 reasonCode\n    ) external {\n        if (request.isAdd) {\n            VaultProcess.transferOut(\n                IVault(address(this)).getTradeVaultAddress(),\n                request.marginToken,\n                request.account,\n                request.updateMarginAmount\n            );\n        }\n        UpdatePositionMargin.remove(requestId);\n\n        emit CancelUpdatePositionMarginEvent(requestId, request, reasonCode);\n    }\n\n    function cancelUpdateLeverageRequest(\n        uint256 requestId,\n        UpdateLeverage.Request memory request,\n        bytes32 reasonCode\n    ) external {\n        bytes32 positionKey = Position.getPositionKey(\n            request.account,\n            request.symbol,\n            request.marginToken,\n            request.isCrossMargin\n        );\n        Position.Props storage position = Position.load(positionKey);\n        if (request.addMarginAmount > 0 && !position.isCrossMargin) {\n            VaultProcess.transferOut(\n                IVault(address(this)).getTradeVaultAddress(),\n                request.marginToken,\n                request.account,\n                request.addMarginAmount\n            );\n        }\n        UpdateLeverage.remove(requestId);\n\n        emit CancelUpdateLeverageEvent(requestId, request, reasonCode);\n    }\n\n    function _executeAddMargin(Position.Props storage position, AddPositionMarginCache memory cache) internal {\n        if (\n            cache.addMarginAmount >\n            CalUtils.usdToToken(\n                position.qty - position.initialMarginInUsd,\n                cache.marginTokenDecimals,\n                cache.marginTokenPrice\n            )\n        ) {\n            revert Errors.AddMarginTooBig();\n        }\n        position.initialMargin += cache.addMarginAmount;\n        if (cache.isCrossMargin) {\n            position.initialMarginInUsd = CalUtils.divRate(position.qty, position.leverage);\n            position.initialMarginInUsdFromBalance += cache.addInitialMarginFromBalance;\n        } else {\n            position.initialMarginInUsd += CalUtils.tokenToUsd(\n                cache.addMarginAmount,\n                cache.marginTokenDecimals,\n                cache.marginTokenPrice\n            );\n            position.leverage = CalUtils.divRate(position.qty, position.initialMarginInUsd);\n            position.initialMarginInUsdFromBalance = position.initialMarginInUsd;\n        }\n\n        uint256 subHoldAmount = cache.addMarginAmount.min(position.holdPoolAmount);\n        position.holdPoolAmount -= subHoldAmount;\n        LpPoolProcess.updatePnlAndUnHoldPoolAmount(cache.stakeToken, position.marginToken, subHoldAmount, 0, 0);\n    }\n\n    function _executeReduceMargin(\n        Position.Props storage position,\n        Symbol.Props memory symbolProps,\n        Config.Props storage config,\n        uint256 reduceMargin,\n        bool needUpdateLeverage\n    ) internal returns (uint256) {\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(symbolProps.code);\n        uint256 maxReduceMarginInUsd = position.initialMarginInUsd -\n            CalUtils.divRate(position.qty, symbolConfig.maxLeverage).max(config.tradeConfig.minOrderMarginUSD);\n        if (reduceMargin > maxReduceMarginInUsd) {\n            revert Errors.ReduceMarginTooBig();\n        }\n        uint8 decimals = TokenUtils.decimals(position.marginToken);\n        uint256 marginTokenPrice = OracleProcess.getLatestUsdUintPrice(position.marginToken, !position.isLong);\n        uint256 reduceMarginAmount = CalUtils.usdToToken(reduceMargin, decimals, marginTokenPrice);\n        position.initialMargin -= reduceMarginAmount;\n        position.initialMarginInUsd -= reduceMargin;\n        if (needUpdateLeverage) {\n            position.leverage = CalUtils.divRate(position.qty, position.initialMarginInUsd);\n        }\n        position.initialMarginInUsdFromBalance = position.initialMarginInUsd;\n        position.holdPoolAmount += reduceMarginAmount;\n        LpPoolProcess.holdPoolAmount(symbolProps.stakeToken, position.marginToken, reduceMarginAmount, position.isLong);\n        return reduceMarginAmount;\n    }\n}\n"
    },
    "contracts/process/PositionQueryProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nimport \"../storage/Position.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Symbol.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./MarketQueryProcess.sol\";\n\nlibrary PositionQueryProcess {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SignedSafeMath for int256;\n    using SafeCast for int256;\n    using Config for Config.Props;\n    using Account for Account.Props;\n\n    struct ComputePositionFeeCache {\n        int256 posFundingFeeInUsd;\n        uint256 posBorrowingFeeInUsd;\n        uint8 tokenDecimal;\n        int256 fundingFeePerQty;\n        int256 unRealizedFundingFeeDelta;\n        uint256 cumulativeBorrowingFeePerToken;\n        uint256 unRealizedBorrowingFeeDelta;\n    }\n\n    struct PositionStaticsCache {\n        int256 totalPnl;\n        uint256 totalIMUsd;\n        uint256 totalIMUsdFromBalance;\n        uint256 totalMM;\n        int256 totalPosFee;\n        uint256 totalQty;\n    }\n\n    function hasOtherShortPosition(\n        address account,\n        bytes32 symbol,\n        address marginToken,\n        bool isCrossMargin\n    ) external view returns (bool) {\n        address[] memory stableTokens = UsdPool.getSupportedStableTokens();\n        for (uint256 i; i < stableTokens.length; i++) {\n            if (stableTokens[i] == marginToken) {\n                continue;\n            }\n            Position.Props storage position = Position.load(account, symbol, stableTokens[i], isCrossMargin);\n            if (position.qty > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getPositionUnPnl(\n        Position.Props memory position,\n        int256 computeIndexPrice,\n        bool pnlToken\n    ) public view returns (int256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getPositionUnPnl(position, oracles, computeIndexPrice, pnlToken);\n    }\n\n    function getPositionUnPnl(\n        Position.Props memory position,\n        OracleProcess.OracleParam[] memory oracles,\n        int256 computeIndexPrice,\n        bool pnlToken\n    ) public view returns (int256) {\n        (int256 pnlInToken, int256 pnlInUsd) = getPositionUnPnl(position, oracles, computeIndexPrice);\n        return pnlToken ? pnlInToken : pnlInUsd;\n    }\n\n    function getPositionUnPnl(\n        Position.Props memory position,\n        OracleProcess.OracleParam[] memory oracles,\n        int256 computeIndexPrice\n    ) public view returns (int256, int256) {\n        if (position.qty == 0) {\n            return (0, 0);\n        }\n        if (position.isLong) {\n            int pnlInUsd = position.qty.toInt256().mul(computeIndexPrice.sub(position.entryPrice.toInt256())).div(\n                position.entryPrice.toInt256()\n            );\n            return (\n                CalUtils.usdToTokenInt(pnlInUsd, TokenUtils.decimals(position.marginToken), computeIndexPrice),\n                pnlInUsd\n            );\n        } else {\n            int pnlInUsd = position.qty.toInt256().mul(position.entryPrice.toInt256().sub(computeIndexPrice)).div(\n                position.entryPrice.toInt256()\n            );\n            int256 marginTokenPrice = OracleProcess.getIntOraclePrices(oracles, position.marginToken, false);\n            return (\n                CalUtils.usdToTokenInt(pnlInUsd, TokenUtils.decimals(position.marginToken), marginTokenPrice),\n                pnlInUsd\n            );\n        }\n    }\n\n    function getLiquidationPrice(Position.Props storage position) external view returns (uint256) {\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(position.symbol);\n        uint256 mmInUsd = getMM(position.qty, symbolConfig.maxLeverage, Config.getTradeMaxMaintenanceMarginRate());\n        int256 posFee = getPositionFee(position);\n        int256 positionValue = position.isLong\n            ? (position.qty - position.initialMarginInUsd + mmInUsd).toInt256() + posFee\n            : (position.qty + position.initialMarginInUsd - mmInUsd).toInt256() - posFee;\n        if (positionValue < 0) {\n            return 0;\n        }\n        uint256 liquidationPrice = positionValue.toUint256().mul(position.entryPrice).div(position.qty);\n        return CalUtils.formatToTickSize(liquidationPrice, symbolConfig.tickSize, position.isLong);\n    }\n\n    function getPositionMMRate(Position.Props memory position) public view returns (uint256) {\n        uint256 maxMaintenanceMarginRate = Config.getTradeMaxMaintenanceMarginRate();\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(position.symbol);\n        return CalUtils.divRate(CalUtils.RATE_PRECISION, symbolConfig.maxLeverage.mul(2)).min(maxMaintenanceMarginRate);\n    }\n\n    function getMM(uint256 qty, uint256 leverage, uint256 maxMMRate) public pure returns (uint256) {\n        return CalUtils.divRate(qty, leverage.mul(2)).min(CalUtils.mulRate(qty, maxMMRate));\n    }\n\n    function getPositionMM(Position.Props memory position) public view returns (uint256) {\n        Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(position.symbol);\n        uint256 maxMaintenanceMarginRate = Config.getTradeMaxMaintenanceMarginRate();\n        return getMM(position.qty, symbolConfig.maxLeverage, maxMaintenanceMarginRate);\n    }\n\n    function getAllPosition(\n        Account.Props storage accountProps,\n        bool isCrossMargin\n    ) public view returns (Position.Props[] memory) {\n        bytes32[] memory positionKeys = accountProps.getAllPosition();\n        Position.Props[] memory positions = new Position.Props[](_getPositionIndex(positionKeys, isCrossMargin));\n        uint256 positionIndex;\n        for (uint256 i; i < positionKeys.length; i++) {\n            Position.Props memory position = Position.load(positionKeys[i]);\n            if (position.isCrossMargin == isCrossMargin) {\n                positions[positionIndex] = position;\n                positionIndex += 1;\n            }\n        }\n\n        return positions;\n    }\n\n    function getPositionFee(Position.Props memory position) public view returns (int256) {\n        OracleProcess.OracleParam[] memory oracles;\n        return getPositionFee(position, oracles);\n    }\n\n    function getPositionFee(\n        Position.Props memory position,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (int256) {\n        ComputePositionFeeCache memory cache;\n        cache.fundingFeePerQty = MarketQueryProcess.getFundingFeePerQty(position.symbol, position.isLong);\n        cache.unRealizedFundingFeeDelta = CalUtils.mulIntSmallRate(\n            position.qty.toInt256(),\n            (cache.fundingFeePerQty - position.positionFee.openFundingFeePerQty)\n        );\n        cache.tokenDecimal = TokenUtils.decimals(position.marginToken);\n        if (position.isLong) {\n            cache.posFundingFeeInUsd =\n                position.positionFee.realizedFundingFeeInUsd +\n                CalUtils.tokenToUsdInt(\n                    cache.unRealizedFundingFeeDelta,\n                    cache.tokenDecimal,\n                    OracleProcess.getIntOraclePrices(oracles, position.marginToken, position.isLong)\n                );\n        } else {\n            cache.posFundingFeeInUsd = position.positionFee.realizedFundingFeeInUsd + cache.unRealizedFundingFeeDelta;\n        }\n\n        Symbol.Props memory symbolProps = Symbol.load(position.symbol);\n        cache.cumulativeBorrowingFeePerToken = MarketQueryProcess.getCumulativeBorrowingFeePerToken(\n            symbolProps.stakeToken,\n            position.isLong,\n            position.marginToken\n        );\n        cache.unRealizedBorrowingFeeDelta = CalUtils.mulSmallRate(\n            CalUtils.mulRate(position.initialMargin, position.leverage - CalUtils.RATE_PRECISION),\n            cache.cumulativeBorrowingFeePerToken - position.positionFee.openBorrowingFeePerToken\n        );\n\n        cache.posBorrowingFeeInUsd =\n            position.positionFee.realizedBorrowingFeeInUsd +\n            CalUtils.tokenToUsd(\n                cache.unRealizedBorrowingFeeDelta,\n                cache.tokenDecimal,\n                OracleProcess.getOraclePrices(oracles, position.marginToken, position.isLong)\n            );\n        consoleInt(\"cache.fundingFeePerQty\", cache.fundingFeePerQty);\n        consoleInt(\"realizedFundingFeeInUsd\", position.positionFee.realizedFundingFeeInUsd);\n        consoleInt(\"unRealizedFundingFeeDelta\", cache.unRealizedFundingFeeDelta);\n        consoleInt(\"posFundingFeeInUsd\", cache.posFundingFeeInUsd);\n        console.log(\"cumulativeBorrowingFeePerToken\", cache.cumulativeBorrowingFeePerToken);\n        console.log(\"realizedBorrowingFeeInUsd\", position.positionFee.realizedBorrowingFeeInUsd);\n        console.log(\"unRealizedBorrowingFeeDelta\", cache.unRealizedBorrowingFeeDelta);\n        console.log(\"posBorrowingFeeInUsd\", cache.posBorrowingFeeInUsd);\n        console.log(\"closeFeeInUsd\", position.positionFee.closeFeeInUsd);\n        return\n            position.positionFee.closeFeeInUsd.toInt256() +\n            cache.posFundingFeeInUsd +\n            cache.posBorrowingFeeInUsd.toInt256();\n    }\n\n    function consoleInt(string memory code, int256 value) internal pure {\n        if (value >= 0) {\n            console.log(code, value.toUint256());\n        } else {\n            console.log(\"-\", code, (-value).toUint256());\n        }\n    }\n\n    function getAccountAllCrossPositionValue(\n        Account.Props storage accountProps\n    ) public view returns (PositionStaticsCache memory) {\n        OracleProcess.OracleParam[] memory cache;\n        return getAccountAllCrossPositionValue(accountProps, cache);\n    }\n\n    function getAccountAllCrossPositionValue(\n        Account.Props storage accountProps,\n        OracleProcess.OracleParam[] memory oracles\n    ) public view returns (PositionStaticsCache memory cache) {\n        accountProps.checkExists();\n        Position.Props[] memory allCrossPositions = getAllPosition(accountProps, true);\n\n        Config.Props storage config = Config.load();\n        uint256 maxMaintenanceMarginRate = config.tradeConfig.maxMaintenanceMarginRate;\n        for (uint256 i; i < allCrossPositions.length; i++) {\n            Position.Props memory position = allCrossPositions[i];\n            int256 indexTokenPrice = OracleProcess.getIntOraclePrices(oracles, position.indexToken, position.isLong);\n            Config.SymbolConfig memory symbolConfig = Config.load().getSymbolConfig(position.symbol);\n            int256 unPnl = getPositionUnPnl(position, oracles, indexTokenPrice, false);\n            if (unPnl > 0) {\n                cache.totalPnl = cache.totalPnl.add(\n                    CalUtils.mulRate(unPnl, config.getTradeCollateralDiscount(position.marginToken).toInt256())\n                );\n            } else {\n                cache.totalPnl = cache.totalPnl.add(\n                    CalUtils.mulRate(\n                        unPnl,\n                        (CalUtils.RATE_PRECISION + config.getTradeCollateralLiquidationFactor(position.marginToken))\n                            .toInt256()\n                    )\n                );\n            }\n\n            cache.totalMM = cache.totalMM.add(getMM(position.qty, symbolConfig.maxLeverage, maxMaintenanceMarginRate));\n            cache.totalIMUsd = cache.totalIMUsd.add(position.initialMarginInUsd);\n            cache.totalIMUsdFromBalance = cache.totalIMUsdFromBalance.add(position.initialMarginInUsdFromBalance);\n            cache.totalQty = cache.totalQty.add(position.qty);\n            cache.totalPosFee = cache.totalPosFee.add(getPositionFee(position, oracles));\n        }\n    }\n\n    function _getPositionIndex(bytes32[] memory positionKeys, bool isCrossMargin) internal pure returns (uint256) {\n        uint256 positionIndex;\n        Position.Props memory position;\n        for (uint256 i; i < positionKeys.length; i++) {\n            position = Position.load(positionKeys[i]);\n            if (position.isCrossMargin == isCrossMargin) {\n                positionIndex += 1;\n            }\n        }\n\n        return positionIndex;\n    }\n}\n"
    },
    "contracts/process/RebalanceProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"../interfaces/IRebalance.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"./VaultProcess.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./SwapProcess.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/CommonData.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary RebalanceProcess {\n    using LpPool for LpPool.Props;\n    using UsdPool for UsdPool.Props;\n    using CommonData for CommonData.Props;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    struct RebalanceUnsettleCache {\n        int256[] poolUnsettledAmount;\n        int256 totalUnsettledAmount;\n        uint256[] settledAmount;\n        int256 tokenLiability;\n        uint256 reduceTransferAmount;\n    }\n\n    function autoRebalance() external {\n        address[] memory stakeTokens = CommonData.getAllStakeTokens();\n        for (uint256 i; i < stakeTokens.length; i++) {\n            LpPool.Props storage pool = LpPool.load(stakeTokens[i]);\n            console.log(i, \"_rebalanceUnsettle baseToken\", pool.baseToken);\n            _rebalanceUnsettle(pool.baseToken, false, stakeTokens);\n        }\n        address[] memory stableTokens = UsdPool.getSupportedStableTokens();\n        for (uint256 i; i < stableTokens.length; i++) {\n            console.log(i, \"_rebalanceUnsettle stableTokens\", stableTokens[i]);\n            _rebalanceUnsettle(stableTokens[i], true, stakeTokens);\n        }\n        for (uint256 i; i < stakeTokens.length; i++) {\n            console.log(i, \"_rebalanceStableTokens stakeTokens[i]\", stakeTokens[i]);\n            _rebalanceStableTokens(stakeTokens[i]);\n        }\n    }\n\n    function _rebalanceStableTokens(address stakeToken) internal {\n        LpPool.Props storage pool = LpPool.load(stakeToken);\n        address[] memory tokens = pool.getStableTokens();\n        int256[] memory netStableTokenAmount = new int256[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            LpPool.TokenBalance storage tokenBalance = pool.getStableTokenBalance(tokens[i]);\n            netStableTokenAmount[i] = tokenBalance.amount >= tokenBalance.lossAmount\n                ? (tokenBalance.amount - tokenBalance.lossAmount).toInt256()\n                : -(tokenBalance.lossAmount - tokenBalance.amount).toInt256();\n        }\n        for (uint256 i; i < netStableTokenAmount.length; i++) {\n            if (netStableTokenAmount[i] == 0) {\n                continue;\n            }\n            if (netStableTokenAmount[i] < 0) {\n                uint256 tokenNetStableTokenAmount = (-netStableTokenAmount[i]).toUint256();\n                for (uint8 j = 0; j < netStableTokenAmount.length; j++) {\n                    if (netStableTokenAmount[j] <= 0) {\n                        continue;\n                    }\n                    uint256 reduceProfitTokenAmount = netStableTokenAmount[j].toUint256();\n                    uint256 offsetLossStableTokenAmount = CalUtils.tokenToToken(\n                        reduceProfitTokenAmount,\n                        TokenUtils.decimals(tokens[j]),\n                        TokenUtils.decimals(tokens[i]),\n                        OracleProcess.getLatestUsdUintPrice(tokens[j], true),\n                        OracleProcess.getLatestUsdUintPrice(tokens[i], false)\n                    );\n                     \n                    if (offsetLossStableTokenAmount > tokenNetStableTokenAmount) {\n                        offsetLossStableTokenAmount = tokenNetStableTokenAmount;\n                        reduceProfitTokenAmount = CalUtils.tokenToToken(\n                            tokenNetStableTokenAmount,\n                            TokenUtils.decimals(tokens[i]),\n                            TokenUtils.decimals(tokens[j]),\n                            OracleProcess.getLatestUsdUintPrice(tokens[i], false),\n                            OracleProcess.getLatestUsdUintPrice(tokens[j], true)\n                        );\n                    }\n                    netStableTokenAmount[i] = netStableTokenAmount[i] + offsetLossStableTokenAmount.toInt256();\n                    netStableTokenAmount[j] = netStableTokenAmount[j] - reduceProfitTokenAmount.toInt256();\n                    if (netStableTokenAmount[i] >= 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        UsdPool.Props storage usdPool = UsdPool.load();\n        address stakeUsd = CommonData.getStakeUsdToken();\n        for (uint256 i; i < netStableTokenAmount.length; i++) {\n            LpPool.TokenBalance storage tokenBalance = pool.getStableTokenBalance(tokens[i]);\n            if (netStableTokenAmount[i] == 0) {\n                usdPool.settleStableToken(tokens[i], tokenBalance.lossAmount, true);\n                usdPool.addStableToken(\n                    tokens[i],\n                    tokenBalance.amount > tokenBalance.lossAmount ? tokenBalance.amount - tokenBalance.lossAmount : 0\n                );\n                VaultProcess.transferOut(stakeToken, tokens[i], stakeUsd, tokenBalance.amount);\n                tokenBalance.amount = 0;\n                tokenBalance.lossAmount = 0;\n            } else if (netStableTokenAmount[i] > 0) {\n                usdPool.settleStableToken(tokens[i], tokenBalance.lossAmount, true);\n                usdPool.addStableToken(\n                    tokens[i],\n                    tokenBalance.amount - netStableTokenAmount[i].toUint256() > tokenBalance.lossAmount\n                        ? tokenBalance.amount - netStableTokenAmount[i].toUint256() - tokenBalance.lossAmount\n                        : 0\n                );\n                VaultProcess.transferOut(\n                    stakeToken,\n                    tokens[i],\n                    stakeUsd,\n                    tokenBalance.amount > netStableTokenAmount[i].toUint256() ? tokenBalance.amount - netStableTokenAmount[i].toUint256() : 0\n                );\n                ISwap.SwapSingleResult memory swapResult = _swapToBaseToken(\n                    stakeToken,\n                    tokens[i],\n                    netStableTokenAmount[i].toUint256(),\n                    pool.baseToken\n                );\n                pool.subStableToken(tokens[i], swapResult.reduceFromAmount);\n                pool.addBaseToken(swapResult.toTokenAmount);\n\n                tokenBalance.amount = netStableTokenAmount[i].toUint256() - swapResult.reduceFromAmount;\n                tokenBalance.lossAmount = 0;\n            } else {\n                ISwap.SwapSingleResult memory swapResult = _swapToStableTokens(\n                    stakeToken,\n                    pool.baseToken,\n                    tokens[i],\n                    (-netStableTokenAmount[i]).toUint256()\n                );\n                pool.subBaseToken(swapResult.reduceFromAmount);\n                pool.addStableToken(tokens[i], swapResult.toTokenAmount);\n\n                usdPool.settleStableToken(\n                    tokens[i],\n                    tokenBalance.lossAmount + swapResult.toTokenAmount - (-netStableTokenAmount[i]).toUint256(),\n                    true\n                );\n                VaultProcess.transferOut(\n                    stakeToken,\n                    tokens[i],\n                    stakeUsd,\n                    tokenBalance.amount + swapResult.toTokenAmount\n                );\n                tokenBalance.amount = 0;\n                tokenBalance.lossAmount = (-netStableTokenAmount[i]).toUint256() - swapResult.toTokenAmount;\n            }\n        }\n    }\n\n    function _swapToBaseToken(\n        address stakeToken,\n        address fromToken,\n        uint256 fromAmount,\n        address toToken\n    ) internal returns (ISwap.SwapSingleResult memory) {\n        uint256 toTokenAmount = CalUtils.tokenToToken(\n            fromAmount,\n            TokenUtils.decimals(fromToken),\n            TokenUtils.decimals(toToken),\n            OracleProcess.getLatestUsdUintPrice(fromToken, true),\n            OracleProcess.getLatestUsdUintPrice(toToken, false)\n        );\n        toTokenAmount -= CalUtils.mulRate(toTokenAmount, Config.load().tradeConfig.swapSlipperTokenFactor);\n        return\n            SwapProcess.singleSwap(\n                ISwap.SwapSingleParam(stakeToken, fromToken, fromAmount, toTokenAmount, toToken, stakeToken)\n            );\n    }\n\n    function _swapToStableTokens(\n        address stakeToken,\n        address fromToken,\n        address toToken,\n        uint256 toAmount\n    ) internal returns (ISwap.SwapSingleResult memory) {\n        uint256 needTokenAmount = CalUtils.tokenToToken(\n            toAmount,\n            TokenUtils.decimals(toToken),\n            TokenUtils.decimals(fromToken),\n            OracleProcess.getLatestUsdUintPrice(toToken, true),\n            OracleProcess.getLatestUsdUintPrice(fromToken, false)\n        );\n        needTokenAmount += CalUtils.mulRate(needTokenAmount, Config.load().tradeConfig.swapSlipperTokenFactor);\n        return\n            SwapProcess.singleSwap(\n                ISwap.SwapSingleParam(stakeToken, fromToken, needTokenAmount, toAmount, toToken, stakeToken)\n            );\n    }\n\n    function _rebalanceUnsettle(address token, bool isStableToken, address[] memory stakeTokens) internal {\n        if (\n            (isStableToken && !UsdPool.isSupportStableToken(token)) ||\n            (!isStableToken && UsdPool.isSupportStableToken(token))\n        ) {\n            return;\n        }\n        RebalanceUnsettleCache memory cache;\n        cache.poolUnsettledAmount = new int256[](stakeTokens.length);\n        for (uint256 i; i < stakeTokens.length; i++) {\n            LpPool.Props storage pool = LpPool.load(stakeTokens[i]);\n            if (isStableToken) {\n                cache.poolUnsettledAmount[i] = pool.getStableTokenBalance(token).unsettledAmount;\n            } else {\n                cache.poolUnsettledAmount[i] = token == pool.baseToken\n                    ? pool.baseTokenBalance.unsettledAmount\n                    : int256(0);\n            }\n\n            if (cache.poolUnsettledAmount[i] <= 0) {\n                continue;\n            }\n            cache.totalUnsettledAmount += cache.poolUnsettledAmount[i];\n        }\n        if (cache.totalUnsettledAmount <= 0) {\n            return;\n        }\n        cache.settledAmount = new uint256[](stakeTokens.length);\n        cache.tokenLiability = CommonData.load().getTokenLiability(token).toInt256();\n        if (cache.totalUnsettledAmount > cache.tokenLiability) {\n            uint256 totalTransferAmount = cache.totalUnsettledAmount.toUint256() - cache.tokenLiability.toUint256();\n            cache.reduceTransferAmount = totalTransferAmount;\n            address portfolioVaultAddress = IVault(address(this)).getPortfolioVaultAddress();\n\n            for (uint256 i; i < stakeTokens.length; i++) {\n                if (cache.poolUnsettledAmount[i] == 0) {\n                    continue;\n                }\n                LpPool.Props storage pool = LpPool.load(stakeTokens[i]);\n                if (i == stakeTokens.length - 1) {\n                    cache.settledAmount[i] = cache.reduceTransferAmount;\n                    cache.reduceTransferAmount = 0;\n                } else {\n                    cache.settledAmount[i] = CalUtils.divToPrecision(\n                        totalTransferAmount,\n                        cache.totalUnsettledAmount.toUint256(),\n                        cache.poolUnsettledAmount[i].toUint256()\n                    );\n                    cache.reduceTransferAmount -= cache.settledAmount[i];\n                }\n                if (isStableToken) {\n                    pool.settleStableToken(token, cache.settledAmount[i]);\n                } else {\n                    pool.settleBaseToken(cache.settledAmount[i]);\n                }\n                VaultProcess.transferOut(portfolioVaultAddress, token, stakeTokens[i], cache.settledAmount[i]);\n            }\n        }\n    }\n}\n"
    },
    "contracts/process/RedeemProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IStake.sol\";\nimport \"../vault/Vault.sol\";\nimport \"../vault/LpVault.sol\";\nimport \"../vault/StakeToken.sol\";\nimport \"../storage/Config.sol\";\nimport \"../storage/StakingAccount.sol\";\nimport \"../storage/Account.sol\";\nimport \"../storage/LpPool.sol\";\nimport \"../storage/UsdPool.sol\";\nimport \"../storage/Redeem.sol\";\nimport \"../storage/UuidCreator.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/TokenUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"./OracleProcess.sol\";\nimport \"./GasProcess.sol\";\nimport \"./LpPoolProcess.sol\";\nimport \"./LpPoolQueryProcess.sol\";\nimport \"./FeeRewardsProcess.sol\";\nimport \"./VaultProcess.sol\";\nimport \"./AccountProcess.sol\";\nimport \"./AssetsProcess.sol\";\nimport \"./MintProcess.sol\";\nimport \"./FeeQueryProcess.sol\";\n\nlibrary RedeemProcess {\n    using LpPool for LpPool.Props;\n    using LpPoolProcess for LpPool.Props;\n    using LpPoolQueryProcess for LpPool.Props;\n    using UsdPool for UsdPool.Props;\n    using LpPoolProcess for UsdPool.Props;\n    using LpPoolQueryProcess for UsdPool.Props;\n    using StakingAccount for StakingAccount.Props;\n    using Account for Account.Props;\n    using AccountProcess for Account.Props;\n    using Config for Config.Props;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    bytes32 constant REDEEM_ID_KEY = keccak256(\"REDEEM_ID_KEY\");\n\n    struct ExecuteRedeemCache {\n        uint256 poolValue;\n        uint256 totalSupply;\n        uint8 tokenDecimals;\n        uint256 unStakeUsd;\n        uint256 redeemTokenAmount;\n        uint256 redeemFee;\n    }\n\n    event CreateRedeemEvent(uint256 indexed requestId, Redeem.Request data);\n    event RedeemSuccessEvent(uint256 indexed requestId, uint256 redeemTokenAmount, Redeem.Request data);\n    event CancelRedeemEvent(uint256 indexed requestId, Redeem.Request data, bytes32 reasonCode);\n\n    function createRedeemStakeTokenRequest(\n        IStake.RedeemStakeTokenParams memory params,\n        address account,\n        uint256 unStakeAmount\n    ) external {\n        uint256 requestId = UuidCreator.nextId(REDEEM_ID_KEY);\n\n        Redeem.Request storage redeemRequest = Redeem.create(requestId);\n        redeemRequest.account = account;\n        redeemRequest.receiver = params.receiver;\n        redeemRequest.stakeToken = params.stakeToken;\n        redeemRequest.redeemToken = params.redeemToken;\n        redeemRequest.unStakeAmount = unStakeAmount;\n        redeemRequest.minRedeemAmount = params.minRedeemAmount;\n        redeemRequest.executionFee = params.executionFee;\n\n        emit CreateRedeemEvent(requestId, redeemRequest);\n    }\n\n    function executeRedeemStakeToken(uint256 requestId, Redeem.Request memory redeemRequest) external {\n        uint256 redeemAmount;\n        if (redeemRequest.receiver == address(0)) {\n            revert Errors.RedeemRequestNotExists();\n        }\n        if (CommonData.getStakeUsdToken() == redeemRequest.stakeToken) {\n            redeemAmount = _redeemStakeUsd(redeemRequest);\n        } else if (CommonData.isStakeTokenSupport(redeemRequest.stakeToken)) {\n            redeemAmount = _redeemStakeToken(redeemRequest);\n        } else {\n            revert Errors.StakeTokenInvalid(redeemRequest.stakeToken);\n        }\n\n        FeeRewardsProcess.updateAccountFeeRewards(redeemRequest.account, redeemRequest.stakeToken);\n\n        Redeem.remove(requestId);\n\n        emit RedeemSuccessEvent(requestId, redeemAmount, redeemRequest);\n    }\n\n    function autoRedeemStakeCollateral(\n        LpPool.Props storage pool,\n        StakingAccount.Props storage stakingAccountProps,\n        address collateral\n    ) external {\n        address account = stakingAccountProps.owner;\n        StakingAccount.CollateralData memory data = stakingAccountProps.getCollateralToken(pool.stakeToken, collateral);\n        Account.Props storage accountProps = Account.load(account);\n        _updateRedeemCollateral(stakingAccountProps, accountProps, pool, collateral, data.amount, data.stakeLiability);\n        uint256 unStakeAmount = MintProcess.computeStakeAmountFromMintToken(pool, data.stakeLiability);\n        StakeToken(pool.stakeToken).burn(account, unStakeAmount);\n        stakingAccountProps.subStakeAmount(pool.stakeToken, unStakeAmount);\n    }\n\n    function cancelRedeemStakeToken(\n        uint256 requestId,\n        Redeem.Request memory redeemRequest,\n        bytes32 reasonCode\n    ) external {\n        Redeem.remove(requestId);\n        emit CancelRedeemEvent(requestId, redeemRequest, reasonCode);\n    }\n\n    function validateAndDepositRedeemExecutionFee(address account, uint256 executionFee) external {\n        Config.Props storage config = Config.load();\n        GasProcess.validateExecutionFeeLimit(executionFee, config.chainConfig.redeemGasFeeLimit);\n        require(msg.value == executionFee, \"redeem with execution fee error!\");\n        AssetsProcess.depositToVault(\n            AssetsProcess.DepositParams(\n                account,\n                config.chainConfig.wrapperToken,\n                executionFee,\n                AssetsProcess.DepositFrom.MANUAL,\n                true\n            )\n        );\n    }\n\n    function _redeemStakeToken(Redeem.Request memory params) internal returns (uint256 redeemTokenAmount) {\n        LpPool.Props storage pool = LpPool.load(params.stakeToken);\n        if (pool.baseToken != params.redeemToken) {\n            revert Errors.RedeemTokenInvalid(params.stakeToken, params.redeemToken);\n        }\n        redeemTokenAmount = _executeRedeemStakeToken(pool, params, params.redeemToken);\n    }\n\n    function _redeemStakeUsd(Redeem.Request memory params) internal returns (uint256 redeemTokenAmount) {\n        address stakeUsdToken = params.stakeToken;\n        address account = params.account;\n        uint256 stakeTokenAmount = StakeToken(stakeUsdToken).balanceOf(account);\n        if (stakeTokenAmount < params.unStakeAmount) {\n            revert Errors.RedeemWithAmountNotEnough(account, stakeUsdToken);\n        }\n\n        UsdPool.Props storage pool = UsdPool.load();\n        redeemTokenAmount = _executeRedeemStakeUsd(pool, stakeUsdToken, params);\n\n        StakingAccount.Props storage accountProps = StakingAccount.load(account);\n        accountProps.subStakeUsdAmount(params.unStakeAmount);\n        pool.subStableToken(params.redeemToken, redeemTokenAmount);\n    }\n\n    function _executeRedeemStakeToken(\n        LpPool.Props storage pool,\n        Redeem.Request memory params,\n        address baseToken\n    ) internal returns (uint256) {\n        ExecuteRedeemCache memory cache;\n        cache.poolValue = pool.getPoolValue();\n        cache.totalSupply = TokenUtils.totalSupply(pool.stakeToken);\n        cache.tokenDecimals = TokenUtils.decimals(baseToken);\n        if (cache.poolValue == 0 || cache.totalSupply == 0) {\n            revert Errors.RedeemWithAmountNotEnough(params.account, baseToken);\n        }\n\n        cache.unStakeUsd = params.unStakeAmount.mul(cache.poolValue).div(cache.totalSupply);\n        cache.redeemTokenAmount = CalUtils.usdToToken(\n            cache.unStakeUsd,\n            cache.tokenDecimals,\n            OracleProcess.getLatestUsdUintPrice(baseToken, false)\n        );\n\n        if (pool.getPoolAvailableLiquidity() < cache.redeemTokenAmount) {\n            revert Errors.RedeemWithAmountNotEnough(params.account, params.redeemToken);\n        }\n\n        if (params.minRedeemAmount > 0 && cache.redeemTokenAmount < params.minRedeemAmount) {\n            revert Errors.RedeemStakeTokenTooSmall(cache.redeemTokenAmount);\n        }\n\n        Account.Props storage accountProps = Account.load(params.account);\n        StakingAccount.Props storage stakingAccountProps = StakingAccount.load(params.account);\n        Config.LpPoolConfig storage poolConfig = Config.load().getPoolConfig(pool.stakeToken);\n        if (stakingAccountProps.hasCollateralToken(params.stakeToken)) {\n            address[] memory collateralTokens = stakingAccountProps.getSortedCollateralToken(params.stakeToken);\n            uint256 reduceRedeemTokenAmount = cache.redeemTokenAmount;\n            for (uint256 i; i < collateralTokens.length; i++) {\n                StakingAccount.CollateralData memory data = stakingAccountProps.getCollateralToken(\n                    params.stakeToken,\n                    collateralTokens[i]\n                );\n                if (reduceRedeemTokenAmount >= data.stakeLiability) {\n                    _updateRedeemCollateral(\n                        stakingAccountProps,\n                        accountProps,\n                        pool,\n                        collateralTokens[i],\n                        data.amount,\n                        data.stakeLiability\n                    );\n                    reduceRedeemTokenAmount -= data.stakeLiability;\n                } else {\n                    uint256 transferCollateralAmount = data.amount.mul(reduceRedeemTokenAmount).div(\n                        data.stakeLiability\n                    );\n                    _updateRedeemCollateral(\n                        stakingAccountProps,\n                        accountProps,\n                        pool,\n                        collateralTokens[i],\n                        transferCollateralAmount,\n                        reduceRedeemTokenAmount\n                    );\n                    reduceRedeemTokenAmount = 0;\n                }\n\n                if (reduceRedeemTokenAmount == 0) {\n                    break;\n                }\n            }\n            if (reduceRedeemTokenAmount > 0) {\n                pool.subPoolAmount(pool.baseToken, reduceRedeemTokenAmount);\n\n                uint256 redeemFee = FeeQueryProcess.calcMintOrRedeemFee(\n                    reduceRedeemTokenAmount,\n                    poolConfig.redeemFeeRate\n                );\n                FeeProcess.chargeMintOrRedeemFee(\n                    redeemFee,\n                    params.stakeToken,\n                    params.redeemToken,\n                    params.account,\n                    FeeProcess.FEE_REDEEM,\n                    false\n                );\n                if (Config.load().isTradeCollateralSupport(params.redeemToken)) {\n                    accountProps.addToken(params.redeemToken, reduceRedeemTokenAmount - redeemFee);\n                    VaultProcess.transferOut(\n                        params.stakeToken,\n                        params.redeemToken,\n                        address(IVault(address(this)).getPortfolioVault()),\n                        reduceRedeemTokenAmount - redeemFee\n                    );\n                } else {\n                    VaultProcess.transferOut(\n                        params.stakeToken,\n                        params.redeemToken,\n                        params.receiver,\n                        reduceRedeemTokenAmount - redeemFee\n                    );\n                }\n            }\n        } else {\n            uint256 redeemFee = FeeQueryProcess.calcMintOrRedeemFee(cache.redeemTokenAmount, poolConfig.redeemFeeRate);\n            FeeProcess.chargeMintOrRedeemFee(\n                redeemFee,\n                params.stakeToken,\n                params.redeemToken,\n                params.account,\n                FeeProcess.FEE_REDEEM,\n                false\n            );\n            if (Config.load().isTradeCollateralSupport(params.redeemToken)) {\n                accountProps.addToken(params.redeemToken, cache.redeemTokenAmount - cache.redeemFee);\n                VaultProcess.transferOut(\n                    params.stakeToken,\n                    params.redeemToken,\n                    address(IVault(address(this)).getPortfolioVault()),\n                    cache.redeemTokenAmount - cache.redeemFee\n                );\n            } else {\n                VaultProcess.transferOut(\n                    params.stakeToken,\n                    params.redeemToken,\n                    params.receiver,\n                    cache.redeemTokenAmount - cache.redeemFee\n                );\n            }\n            pool.subPoolAmount(pool.baseToken, cache.redeemTokenAmount);\n        }\n        StakeToken(params.stakeToken).burn(params.account, params.unStakeAmount);\n        stakingAccountProps.subStakeAmount(params.stakeToken, params.unStakeAmount);\n\n        return cache.redeemTokenAmount;\n    }\n\n    function _executeRedeemStakeUsd(\n        UsdPool.Props storage pool,\n        address stakeUsdToken,\n        Redeem.Request memory params\n    ) internal returns (uint256) {\n        address account = params.account;\n        uint256 poolValue = pool.getUsdPoolValue();\n        uint256 totalSupply = TokenUtils.totalSupply(stakeUsdToken);\n        if (poolValue == 0 || totalSupply == 0) {\n            revert Errors.RedeemWithAmountNotEnough(account, params.redeemToken);\n        }\n        uint8 tokenDecimals = TokenUtils.decimals(params.redeemToken);\n        uint256 unStakeUsd = params.unStakeAmount.mul(poolValue).div(totalSupply);\n        uint256 redeemTokenAmount = CalUtils.usdToToken(\n            unStakeUsd,\n            tokenDecimals,\n            OracleProcess.getLatestUsdUintPrice(params.redeemToken, false)\n        );\n        if (params.minRedeemAmount > 0 && redeemTokenAmount < params.minRedeemAmount) {\n            revert Errors.RedeemStakeTokenTooSmall(redeemTokenAmount);\n        }\n        if (pool.getMaxWithdraw(params.redeemToken) < redeemTokenAmount) {\n            revert Errors.RedeemWithAmountNotEnough(params.account, params.redeemToken);\n        }\n\n        uint256 redeemFee = FeeQueryProcess.calcMintOrRedeemFee(\n            redeemTokenAmount,\n            Config.load().getUsdPoolConfig().redeemFeeRate\n        );\n        FeeProcess.chargeMintOrRedeemFee(\n            redeemFee,\n            params.stakeToken,\n            params.redeemToken,\n            params.account,\n            FeeProcess.FEE_REDEEM,\n            false\n        );\n\n        StakeToken(params.stakeToken).burn(account, params.unStakeAmount);\n        StakeToken(params.stakeToken).transferOut(params.redeemToken, params.receiver, redeemTokenAmount - redeemFee);\n        return redeemTokenAmount;\n    }\n\n    function _updateRedeemCollateral(\n        StakingAccount.Props storage stakingAccountProps,\n        Account.Props storage accountProps,\n        LpPool.Props storage pool,\n        address token,\n        uint256 amount,\n        uint256 stakeLiability\n    ) internal {\n        stakingAccountProps.subCollateralToken(pool.stakeToken, token, amount);\n        stakingAccountProps.subStakeLiability(pool.stakeToken, token, stakeLiability);\n        pool.subCollateralBaseToken(stakeLiability, token, amount);\n        uint256 redeemFee = FeeQueryProcess.calcMintOrRedeemFee(\n            amount,\n            Config.load().getPoolConfig(pool.stakeToken).redeemFeeRate\n        );\n        FeeProcess.chargeMintOrRedeemFee(redeemFee, pool.stakeToken, token, accountProps.owner, FeeProcess.FEE_REDEEM, true);\n\n        accountProps.addToken(token, amount - redeemFee);\n    }\n}\n"
    },
    "contracts/process/SwapProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\nimport \"../interfaces/ISwap.sol\";\nimport \"../storage/Config.sol\";\nimport \"./VaultProcess.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary SwapProcess {\n    function swap(ISwap.SwapParams calldata params) external returns (ISwap.SwapResult memory result) {\n        result.fromTokens = params.fromTokens;\n        result.toToken = params.toToken;\n        result.expectToTokenAmount = params.toTokenAmount;\n        address uniswapRouter = Config.getUniswapRouter();\n        for (uint256 i; i < params.fromTokens.length; i++) {\n            VaultProcess.transferOut(\n                params.fromTokenAddress,\n                params.fromTokens[i],\n                address(this),\n                params.fromAmounts[i],\n                false\n            );\n            TransferHelper.safeApprove(params.fromTokens[i], uniswapRouter, params.fromAmounts[i]);\n            console.log(\"start swap\");\n            ISwapRouter.ExactInputSingleParams memory callSwapParams = ISwapRouter.ExactInputSingleParams({\n                tokenIn: params.fromTokens[i],\n                tokenOut: params.toToken,\n                fee: 3000,\n                recipient: params.toTokenAddress,\n                deadline: block.timestamp,\n                amountIn: params.fromAmounts[i],\n                amountOutMinimum: params.minToTokenAmounts[i],\n                sqrtPriceLimitX96: 0\n            });\n            uint256 amountOut = ISwapRouter(uniswapRouter).exactInputSingle(callSwapParams);\n            console.log(\"end swap\");\n            result.toTokenAmount += amountOut;\n            result.reduceFromAmounts[i] = params.fromAmounts[i];\n            if (result.toTokenAmount >= params.toTokenAmount) {\n                break;\n            }\n        }\n    }\n\n    function singleSwap(ISwap.SwapSingleParam calldata params) external returns (ISwap.SwapSingleResult memory result) {\n        result.fromToken = params.fromToken;\n        result.toToken = params.toToken;\n        address uniswapRouter = Config.getUniswapRouter();\n        VaultProcess.transferOut(params.fromTokenAddress, params.fromToken, address(this), params.fromAmount, false);\n        TransferHelper.safeApprove(params.fromToken, uniswapRouter, params.fromAmount);\n        ISwapRouter.ExactInputSingleParams memory callSwapParams = ISwapRouter.ExactInputSingleParams({\n            tokenIn: params.fromToken,\n            tokenOut: params.toToken,\n            fee: 3000,\n            recipient: params.toTokenAddress,\n            deadline: block.timestamp,\n            amountIn: params.fromAmount,\n            amountOutMinimum: params.minToTokenAmount,\n            sqrtPriceLimitX96: 0\n        });\n        uint256 amountOut = ISwapRouter(uniswapRouter).exactInputSingle(callSwapParams);\n        result.toTokenAmount = amountOut;\n        result.reduceFromAmount = params.fromAmount;\n    }\n}\n"
    },
    "contracts/process/VaultProcess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"../interfaces/IWETH.sol\";\nimport \"../vault/Vault.sol\";\nimport \"../storage/Config.sol\";\nimport \"../utils/Errors.sol\";\n\nlibrary VaultProcess {\n    using Config for Config.Props;\n\n    function transferOut(address vault, address token, address receiver, uint256 amount) external returns(bool) {\n        return transferOut(vault, token, receiver, amount, false);\n    }\n\n    function transferOut(address vault, address token, address receiver, uint256 amount, bool skipBalanceNotEnough) public returns(bool) {\n        if (amount == 0) {\n            return false;\n        }\n        uint256 tokenBalance = IERC20(token).balanceOf(vault);\n        if (tokenBalance >= amount) {\n            Vault(vault).transferOut(token, receiver, amount);\n            return true;\n        } else if (!skipBalanceNotEnough) {\n            revert Errors.TransferErrorWithVaultBalanceNotEnough(vault, token, receiver, amount);\n        }\n        return false;\n    }\n\n    function withdrawEther(address receiver, uint256 amount) internal {\n        address wrapperToken = Config.getWrapperToken();\n        IWETH(wrapperToken).withdraw(amount);\n        safeTransferETH(receiver, amount);\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"STE\");\n    }\n}\n"
    },
    "contracts/router/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { LibDiamond } from \"../storage/LibDiamond.sol\";\nimport { IDiamond } from \"../interfaces/IDiamond.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport \"../storage/RoleAccessControl.sol\";\nimport \"hardhat/console.sol\";\n\n// When no function exists for function called\nerror FunctionNotFound(bytes4 _functionSelector);\n\ncontract Diamond {\n    constructor(address _diamondCutFacet, address _diamondLoupeFacet, address _init, address owner) payable {\n        RoleAccessControl.grantRole(msg.sender, RoleAccessControl.ROLE_ADMIN);\n\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](2);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamond.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        bytes4[] memory loupeFunctionSelectors = new bytes4[](4);\n        loupeFunctionSelectors[0] = IDiamondLoupe.facets.selector;\n        loupeFunctionSelectors[1] = IDiamondLoupe.facetAddresses.selector;\n        loupeFunctionSelectors[2] = IDiamondLoupe.facetAddress.selector;\n        loupeFunctionSelectors[3] = IDiamondLoupe.facetFunctionSelectors.selector;\n        cut[1] = IDiamond.FacetCut({\n            facetAddress: _diamondLoupeFacet,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: loupeFunctionSelectors\n        });\n        LibDiamond.setContractOwner(owner);\n        LibDiamond.diamondCut(cut, _init, abi.encodeWithSignature(\"init()\"));\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        // get facet from function selector\n        address facet = ds.facetAddressAndSelectorPosition[msg.sig].facetAddress;\n        if (facet == address(0)) {\n            revert FunctionNotFound(msg.sig);\n        }\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/router/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { LibDiamond } from \"../storage/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\ncontract DiamondInit {    \n\n    function init() external {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        \n    }\n}\n"
    },
    "contracts/storage/Account.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./CommonData.sol\";\nimport \"./Config.sol\";\nimport \"../utils/Errors.sol\";\n\nlibrary Account {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using CommonData for CommonData.Props;\n    using Config for Config.Props;\n\n    struct Props {\n        address owner;\n        uint256 orderHoldInUsd;\n        EnumerableSet.AddressSet tokens;\n        mapping(address => Account.TokenBalance) tokenBalances;\n        EnumerableSet.Bytes32Set positions;\n        EnumerableSet.UintSet orders;\n    }\n\n    struct TokenBalance {\n        uint256 amount;\n        uint256 usedAmount;\n        uint256 interest;\n        uint256 liability;\n    }\n\n    event AccountTokenUpdateEvent(address account, address token, TokenBalance preBalance, TokenBalance balance);\n\n    event AccountOrderHoldInUsdUpdateEvent(address account, uint256 preOrderHoldInUsd, uint256 orderHoldInUsd);\n\n    event AccountCrossModeUpdateEvent(address account, bool isCrossMargin);\n\n    function load(address owner) public pure returns (Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profile.storage.Account\", owner));\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function loadOrCreate(address owner) public returns (Props storage) {\n        Props storage self = load(owner);\n        if (self.owner == address(0)) {\n            self.owner = owner;\n        }\n        return self;\n    }\n\n    function addOrderHoldInUsd(Props storage self, uint256 holdInUsd) external {\n        uint256 preOrderHoldInUsd = self.orderHoldInUsd;\n        self.orderHoldInUsd += holdInUsd;\n        emit AccountOrderHoldInUsdUpdateEvent(self.owner, preOrderHoldInUsd, self.orderHoldInUsd);\n    }\n\n    function subOrderHoldInUsd(Props storage self, uint256 holdInUsd) external {\n        require(self.orderHoldInUsd >= holdInUsd, \"orderHoldInUsd is smaller than holdInUsd\");\n        uint256 preOrderHoldInUsd = self.orderHoldInUsd;\n        self.orderHoldInUsd -= holdInUsd;\n        emit AccountOrderHoldInUsdUpdateEvent(self.owner, preOrderHoldInUsd, self.orderHoldInUsd);\n    }\n\n    function addToken(Props storage self, address token, uint256 amount, bool updateBorrow) external {\n        if (!self.tokens.contains(token)) {\n            self.tokens.add(token);\n        }\n        TokenBalance storage balance = self.tokenBalances[token];\n        TokenBalance memory preBalance = balance;\n        if (!updateBorrow) {\n            balance.amount += amount;\n            emit AccountTokenUpdateEvent(self.owner, token, preBalance, balance);\n            return;\n        }\n        balance.amount += amount;\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, balance);\n    }\n\n    function addToken(Props storage self, address token, uint256 amount) external {\n        if (!self.tokens.contains(token)) {\n            self.tokens.add(token);\n        }\n        TokenBalance storage balance = self.tokenBalances[token];\n        TokenBalance memory preBalance = balance;\n        balance.amount += amount;\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, balance);\n    }\n\n    function subToken(Props storage self, address token, uint256 amount) external {\n        require(self.tokens.contains(token), \"token not exists!\");\n        require(self.tokenBalances[token].amount >= amount, \"token amount not enough!\");\n        require(\n            self.tokenBalances[token].amount >= self.tokenBalances[token].usedAmount + amount,\n            \"token amount exclude used amount not enough!\"\n        );\n        TokenBalance memory preBalance = self.tokenBalances[token];\n        self.tokenBalances[token].amount -= amount;\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, self.tokenBalances[token]);\n    }\n\n    function subTokenIgnoreUsedAmount(Props storage self, address token, uint256 amount) external {\n        require(self.tokens.contains(token), \"token not exists!\");\n        require(self.tokenBalances[token].amount >= amount, \"token amount not enough!\");\n        TokenBalance memory preBalance = self.tokenBalances[token];\n        self.tokenBalances[token].amount -= amount;\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, self.tokenBalances[token]);\n    }\n\n    function subTokenWithLiability(\n        Props storage self,\n        address token,\n        uint256 amount\n    ) external returns (uint256 liability) {\n        TokenBalance storage balance = self.tokenBalances[token];\n        TokenBalance memory preBalance = balance;\n        if (balance.amount >= amount) {\n            balance.amount -= amount;\n            liability = 0;\n        } else if (balance.amount > 0) {\n            liability = amount - balance.amount;\n            balance.liability += liability;\n            balance.usedAmount += liability;\n            balance.amount = 0;\n        } else {\n            balance.liability += amount;\n            balance.usedAmount += amount;\n            liability = amount;\n        }\n        CommonData.load().addTokenLiability(token, liability);\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, balance);\n    }\n\n    function useToken(Props storage self, address token, uint256 amount) external returns (uint256 useFromBalance) {\n        return useToken(self, token, amount, false);\n    }\n\n    function useToken(\n        Props storage self,\n        address token,\n        uint256 amount,\n        bool isCheck\n    ) public returns (uint256 useFromBalance) {\n        if (!self.tokens.contains(token)) {\n            self.tokens.add(token);\n        }\n        TokenBalance storage balance = self.tokenBalances[token];\n        require(!isCheck || balance.amount >= balance.usedAmount + amount, \"use token failed with amount not enough\");\n        TokenBalance memory preBalance = balance;\n        if (balance.amount >= balance.usedAmount + amount) {\n            balance.usedAmount += amount;\n            useFromBalance = amount;\n        } else if (balance.amount > balance.usedAmount) {\n            useFromBalance = balance.amount - balance.usedAmount;\n            balance.usedAmount += amount;\n        } else {\n            balance.usedAmount += amount;\n            useFromBalance = 0;\n        }\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, balance);\n    }\n\n    function unUseToken(Props storage self, address token, uint256 amount) public {\n        require(self.tokens.contains(token), \"token not exists!\");\n        require(self.tokenBalances[token].usedAmount >= amount, \"unuse overflow!\");\n        TokenBalance memory preBalance = self.tokenBalances[token];\n        self.tokenBalances[token].usedAmount -= amount;\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, self.tokenBalances[token]);\n    }\n\n    function repayLiability(Props storage self, address token) external {\n        TokenBalance storage balance = self.tokenBalances[token];\n        if (balance.liability > 0 && balance.amount > 0) {\n            TokenBalance memory preBalance = balance;\n            uint256 repayAmount = balance.amount >= balance.liability ? balance.liability : balance.amount;\n            balance.amount -= repayAmount;\n            balance.liability -= repayAmount;\n            balance.usedAmount -= repayAmount;\n            CommonData.load().subTokenLiability(token, repayAmount);\n            emit AccountTokenUpdateEvent(self.owner, token, preBalance, balance);\n        }\n    }\n\n    function clearLiability(Props storage self, address token) external {\n        TokenBalance storage balance = self.tokenBalances[token];\n        TokenBalance memory preBalance = balance;\n        CommonData.load().subTokenLiability(token, balance.liability);\n        balance.usedAmount -= balance.liability;\n        balance.liability = 0;\n        emit AccountTokenUpdateEvent(self.owner, token, preBalance, balance);\n    }\n\n    function addPosition(Props storage self, bytes32 position) external {\n        if (!self.positions.contains(position)) {\n            self.positions.add(position);\n        }\n    }\n\n    function delPosition(Props storage self, bytes32 position) external {\n        self.positions.remove(position);\n    }\n\n    function checkExists(Props storage self) external view {\n        if (self.owner == address(0)) {\n            revert Errors.AccountNotExist();\n        }\n    }\n\n    function getAllPosition(Props storage self) external view returns (bytes32[] memory) {\n        return self.positions.values();\n    }\n\n    function hasPosition(Props storage self) external view returns (bool) {\n        return self.positions.length() > 0;\n    }\n\n    function hasPosition(Props storage self, bytes32 key) external view returns (bool) {\n        return self.positions.contains(key);\n    }\n\n    function getAllOrders(Props storage self) external view returns (uint256[] memory) {\n        return self.orders.values();\n    }\n\n    function hasOrder(Props storage self) external view returns (bool) {\n        return self.orders.length() > 0;\n    }\n\n    function hasOtherOrder(Props storage self, uint256 orderId) external view returns (bool) {\n        uint256[]  memory orderIds = self.orders.values();\n        for (uint256 i; i < orderIds.length; i++) {\n            if (orderIds[i] != orderId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function addOrder(Props storage self, uint256 orderId) external {\n        if (!self.orders.contains(orderId)) {\n            self.orders.add(orderId);\n        }\n    }\n\n    function delOrder(Props storage self, uint256 orderId) external {\n        self.orders.remove(orderId);\n    }\n\n    function getOrders(Props storage self) external view returns (uint256[] memory) {\n        return self.orders.values();\n    }\n\n    function getTokens(Props storage self) public view returns (address[] memory) {\n        return self.tokens.values();\n    }\n\n    function getSortedTokensByDiscount(Props storage self) external view returns (address[] memory) {\n        address[] memory tokens = self.tokens.values();\n        Config.Props storage config = Config.load();\n        Config.TradeTokenConfig[] memory tokenConfigs = new Config.TradeTokenConfig[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            tokenConfigs[i] = config.getTradeTokenConfig(tokens[i]);\n        }\n        for (uint i = 1; i < tokenConfigs.length; i++) {\n            Config.TradeTokenConfig memory temp = tokenConfigs[i];\n            address tempToken = tokens[i];\n            uint j = i;\n            while ((j >= 1) && (temp.discount < tokenConfigs[j - 1].discount)) {\n                tokenConfigs[j] = tokenConfigs[j - 1];\n                tokens[j] = tokens[j - 1];\n                j--;\n            }\n            tokenConfigs[j] = temp;\n            tokens[j] = tempToken;\n        }\n        return tokens;\n    }\n\n    function getTokenBalance(Props storage self, address token) public view returns (TokenBalance memory) {\n        return self.tokenBalances[token];\n    }\n\n    function getTokenAmount(Props storage self, address token) public view returns (uint256) {\n        return self.tokenBalances[token].amount;\n    }\n\n    function getAvailableTokenAmount(Props storage self, address token) public view returns (uint256) {\n        if (self.tokenBalances[token].amount > self.tokenBalances[token].usedAmount) {\n            return self.tokenBalances[token].amount - self.tokenBalances[token].usedAmount;\n        }\n        return 0;\n    }\n\n    function hasLiability(Props storage self) external view returns (bool) {\n        address[] memory tokens = self.tokens.values();\n        for (uint256 i; i < tokens.length; i++) {\n            if (self.tokenBalances[tokens[i]].liability > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/storage/ClaimRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nlibrary ClaimRewards {\n    bytes32 constant KEY = keccak256(abi.encode(\"xyz.elfi.storage.ClaimRewards\"));\n\n    struct Props {\n        mapping(uint256 => Request) requests;\n    }\n\n    struct Request {\n        address account;\n        address claimUsdToken;\n        uint256 executionFee;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = KEY;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(uint256 requestId) external view returns (Request storage) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function get(uint256 requestId) external view returns (Request memory) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function remove(uint256 requestId) external {\n        Props storage self = load();\n        delete self.requests[requestId];\n    }\n}\n"
    },
    "contracts/storage/CommonData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary CommonData {\n    bytes32 private constant COMMON_DATA = keccak256(abi.encode(\"link.profile.storage.CommonData\"));\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct Props {\n        address stakeUsdToken;\n        bytes32[] symbols;\n        EnumerableSet.AddressSet stakeTokens;\n        mapping(address => TokenData) tradeCollateralTokenDatas;\n        mapping(address => uint256) stakeCollateralAmount;\n        mapping(address => uint256) tokensTotalLiability;\n        uint256 totalLossExecutionFee;\n    }\n\n    struct TokenData {\n        uint256 totalCollateral;\n        uint256 totalLiability;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = COMMON_DATA;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function getStakeUsdToken() external view returns (address) {\n        Props storage self = load();\n        return self.stakeUsdToken;\n    }\n\n    function setStakeUsdToken(address stakeUsdToken) external {\n        Props storage self = load();\n        self.stakeUsdToken = stakeUsdToken;\n    }\n\n    function addSymbol(bytes32 code) external {\n        Props storage self = load();\n        self.symbols.push(code);\n    }\n\n    function addStakeTokens(address stakeToken) external {\n        Props storage self = load();\n        self.stakeTokens.add(stakeToken);\n    }\n\n    function isStakeTokenSupport(address stakeToken) external view returns (bool) {\n        Props storage self = load();\n        return self.stakeTokens.contains(stakeToken);\n    }\n\n    function getAllSymbols() external view returns (bytes32[] memory) {\n        Props storage self = load();\n        return self.symbols;\n    }\n\n    function getAllStakeTokens() external view returns (address[] memory) {\n        Props storage self = load();\n        return self.stakeTokens.values();\n    }\n\n    function addTradeTokenCollateral(Props storage self, address token, uint256 amount) external {\n        self.tradeCollateralTokenDatas[token].totalCollateral += amount;\n    }\n\n    function subTradeTokenCollateral(Props storage self, address token, uint256 amount) external {\n        require(\n            self.tradeCollateralTokenDatas[token].totalCollateral >= amount,\n            \"subTradeTokenCollateral less than amount\"\n        );\n        self.tradeCollateralTokenDatas[token].totalCollateral -= amount;\n    }\n\n    function addTradeTokenLiability(Props storage self, address token, uint256 amount) external {\n        self.tradeCollateralTokenDatas[token].totalLiability += amount;\n    }\n\n    function subTradeTokenLiability(Props storage self, address token, uint256 amount) external {\n        require(\n            self.tradeCollateralTokenDatas[token].totalLiability >= amount,\n            \"subTradeTokenLiability less than amount\"\n        );\n        self.tradeCollateralTokenDatas[token].totalLiability -= amount;\n    }\n\n    function getTradeTokenCollateral(Props storage self, address token) external view returns (uint256) {\n        return self.tradeCollateralTokenDatas[token].totalCollateral;\n    }\n\n    function getTradeTokenLiability(Props storage self, address token) external view returns (uint256) {\n        return self.tradeCollateralTokenDatas[token].totalLiability;\n    }\n\n    function addStakeCollateralAmount(Props storage self, address token, uint256 amount) external {\n        self.stakeCollateralAmount[token] += amount;\n    }\n\n    function subStakeCollateralAmount(Props storage self, address token, uint256 amount) external {\n        require(self.stakeCollateralAmount[token] >= amount, \"subStakeCollateralAmount less than amount\");\n        self.stakeCollateralAmount[token] -= amount;\n    }\n\n    function getStakeCollateralAmount(Props storage self, address token) external view returns (uint256) {\n        return self.stakeCollateralAmount[token];\n    }\n\n    function addTokenLiability(Props storage self, address token, uint256 addLiability) external {\n        self.tokensTotalLiability[token] += addLiability;\n    }\n\n    function subTokenLiability(Props storage self, address token, uint256 subLiability) external {\n        require(self.tokensTotalLiability[token] >= subLiability, \"subTokenLiability less than liability\");\n        self.tokensTotalLiability[token] -= subLiability;\n    }\n\n    function getTokenLiability(Props storage self, address token) external view returns(uint256){\n        return self.tokensTotalLiability[token];\n    }\n\n    function addLossExecutionFee(uint256 amount) external {\n        Props storage self = load();\n        self.totalLossExecutionFee += amount;\n    }\n\n    function subLossExecutionFee(uint256 amount) external {\n        Props storage self = load();\n        if (self.totalLossExecutionFee <= amount) {\n            self.totalLossExecutionFee = 0;\n        } else {\n            self.totalLossExecutionFee -= amount;\n        }\n    }\n}\n"
    },
    "contracts/storage/Config.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary Config {\n    bytes32 private constant _CONFIG = keccak256(abi.encode(\"link.profit.storage.Config\"));\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct Props {\n        CommonConfig commonConfig;\n        ChainConfig chainConfig;\n        StakeConfig stakeConfig;\n        TradeConfig tradeConfig;\n        UsdPoolConfig usdPoolConfig;\n        mapping(address => LpPoolConfig) lpPoolConfigs;\n        mapping(bytes32 => SymbolConfig) symbolConfigs;\n    }\n\n    struct AssetTokenConfig {\n        address token;\n        uint256 weight;\n    }\n\n    struct TradeConfig {\n        EnumerableSet.AddressSet tokens;\n        mapping(address => TradeTokenConfig) tokenConfigs;\n        uint256 minOrderMarginUSD;\n        uint256 availableCollateralRatio;\n        uint256 crossLtvLimit;\n        uint256 executeOrderMinBlockGap;\n        uint256 executeOrderMaxBlockGap;\n        uint256 executePositionMarginMinBlockGap;\n        uint256 executePositionMarginMaxBlockGap;\n        uint256 executeLeverageMinBlockGap;\n        uint256 executeLeverageMaxBlockGap;\n        uint256 maxMaintenanceMarginRate;\n        uint256 fundingFeeBaseRate;\n        uint256 tradingFeeStakingRewardsRatio;\n        uint256 tradingFeePoolRewardsRatio;\n        uint256 tradingFeeUsdPoolRewardsRatio;\n        uint256 borrowingFeeStakingRewardsRatio;\n        uint256 borrowingFeePoolRewardsRatio;\n        uint256 autoReduceProfitFactor;\n        uint256 autoReduceLiquidityFactor;\n        uint256 swapSlipperTokenFactor;\n    }\n\n    struct StakeConfig {\n        uint256 collateralProtectFactor;\n        uint256 collateralFactor;\n        uint256 minPrecisionMultiple;\n        uint256 mintFeeStakingRewardsRatio;\n        uint256 mintFeePoolRewardsRatio;\n        uint256 redeemFeeStakingRewardsRatio;\n        uint256 redeemFeePoolRewardsRatio;\n        uint256 poolRewardsIntervalLimit;\n    }\n\n    struct CommonConfig {\n        address uniswapRouter;\n    }\n\n    struct TradeTokenConfig {\n        bool isSupportCollateral;\n        uint8 precision;\n        uint256 discount;\n        uint256 collateralUserCap;\n        uint256 collateralTotalCap;\n        uint256 liabilityUserCap;\n        uint256 liabilityTotalCap;\n        uint256 interestRateFactor;\n        uint256 liquidationFactor;\n        address[] priorityCollaterals;\n    }\n\n    struct ChainConfig {\n        address wrapperToken;\n        uint256 mintGasFeeLimit;\n        uint256 redeemGasFeeLimit;\n        uint256 placeIncreaseOrderGasFeeLimit;\n        uint256 placeDecreaseOrderGasFeeLimit;\n        uint256 positionUpdateMarginGasFeeLimit;\n        uint256 positionUpdateLeverageGasFeeLimit;\n        uint256 claimRewardsGasFeeLimit;\n    }\n\n    struct StakeCollateralConfig {\n        uint256 discount;\n        uint256 collateralTotalCap;\n    }\n\n    struct LpPoolConfig {\n        address[] assetTokens;\n        EnumerableSet.AddressSet supportCollateralTokens;\n        mapping(address => StakeCollateralConfig) collateralTokensConfigs;\n        uint256 poolLiquidityLimit;\n        uint256 mintFeeRate;\n        uint256 redeemFeeRate;\n        uint256 baseInterestRate;\n        uint256 poolPnlRatioLimit;\n        uint256 collateralStakingRatioLimit;\n        uint256 unsettledBaseTokenRatioLimit;\n        uint256 unsettledStableTokenRatioLimit;\n        uint256 poolStableTokenRatioLimit;\n        uint256 poolStableTokenLossLimit;\n    }\n\n    struct UsdPoolConfig {\n        uint256 poolLiquidityLimit;\n        uint256 mintFeeRate;\n        uint256 redeemFeeRate;\n        uint256 unsettledRatioLimit;\n        mapping(address => uint256) baseInterestRates;\n        mapping(address => uint256) stableTokenRatioLimits;\n    }\n\n    struct SymbolConfig {\n        uint256 maxLeverage;\n        uint256 tickSize;\n        uint256 openFeeRate;\n        uint256 closeFeeRate;\n        uint256 maxLongOpenInterestCap;\n        uint256 maxShortOpenInterestCap;\n        uint256 longShortRatioLimit;\n        uint256 longShortOiBottomLimit;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = _CONFIG;\n        assembly {\n            self.slot := s\n        }\n    }\n    \n    function getPoolConfig(Props storage self, address stakeToken) public view returns (LpPoolConfig storage config) {\n        return self.lpPoolConfigs[stakeToken];\n    }\n\n    function getUsdPoolConfig(Props storage self) public view returns (UsdPoolConfig storage config) {\n        return self.usdPoolConfig;\n    }\n\n    function getSymbolConfig(Props storage self, bytes32 code) public view returns (SymbolConfig storage config) {\n        return self.symbolConfigs[code];\n    }\n\n    function getTradeTokenConfig(Props storage self, address token) external view returns (TradeTokenConfig storage) {\n        return self.tradeConfig.tokenConfigs[token];\n    }\n\n    function isTradeTokenSupport(Props storage self, address token) external view returns (bool) {\n        return self.tradeConfig.tokens.contains(token);\n    }\n\n    function isTradeCollateralSupport(Props storage self, address token) external view returns (bool) {\n        return self.tradeConfig.tokenConfigs[token].isSupportCollateral;\n    }\n\n    function getTradeCollateralDiscount(Props storage self, address token) external view returns (uint256) {\n        return self.tradeConfig.tokenConfigs[token].discount;\n    }\n\n    function getTradeCollateralLiquidationFactor(Props storage self, address token) external view returns (uint256) {\n        return self.tradeConfig.tokenConfigs[token].liquidationFactor;\n    }\n\n    function getTradeMaxMaintenanceMarginRate() external view returns (uint256) {\n        Props storage self = load();\n        return self.tradeConfig.maxMaintenanceMarginRate;\n    }\n\n    function getTradeConfig(Props storage self) external view returns (TradeConfig storage) {\n        return self.tradeConfig;\n    }\n\n    function getStakeConfig(Props storage self) external view returns (StakeConfig storage) {\n        return self.stakeConfig;\n    }\n\n    function addTradeToken(Props storage self, address token, TradeTokenConfig memory tokenConfig) external {\n        if (!self.tradeConfig.tokens.contains(token)) {\n            self.tradeConfig.tokens.add(token);\n        }\n        self.tradeConfig.tokenConfigs[token] = tokenConfig;\n    }\n\n    function getWrapperToken(Props storage self) external view returns(address) {\n        return self.chainConfig.wrapperToken; \n    }\n\n    function getWrapperToken() external view returns(address) {\n        Props storage self = load();\n        return self.chainConfig.wrapperToken; \n    }\n\n    function getChainConfig() external view returns (ChainConfig memory) {\n        Props storage self = load();\n        return self.chainConfig;\n    }\n\n    function getUniswapRouter() external view returns(address) {\n        Props storage self = load();\n        return self.commonConfig.uniswapRouter;\n    }\n}\n"
    },
    "contracts/storage/FeeRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary FeeRewards {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeMath for uint256;\n\n    bytes32 private constant FEE_REWARDS = keccak256(\"xyz.elfi.storage.FeeRewards\");\n    bytes32 private constant FEE_AMOUNT_PREFIX = keccak256(abi.encode(\"FEE_AMOUNT_PREFIX\"));\n\n    function generateFeeAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(FEE_AMOUNT_PREFIX, market, token));\n    }\n\n    struct Props {\n        mapping(bytes32 => MarketRewards) marketTradingRewards;\n        mapping(address => MarketRewards) poolRewards;\n        StakingRewards stakingRewards;\n        StakingRewards daoRewards;\n    }\n\n    struct MarketRewards {\n        EnumerableSet.AddressSet tokens;\n        mapping(address => uint256) feeAmount;\n        mapping(address => uint256) unsettledFeeAmount;\n        EnumerableSet.AddressSet collateralTokens;\n        mapping(address => uint256) collateralFeeAmount;\n        uint256 cumulativeRewardsPerStakeToken;\n        uint256[] lastRewardsPerStakeTokenDeltas;\n    }\n\n    struct StakingRewards {\n        EnumerableSet.AddressSet tokens;\n        mapping(bytes32 => uint256) feeAmount;\n        mapping(bytes32 => uint256) unsettledFeeAmount;\n        EnumerableSet.AddressSet collateralTokens;\n        mapping(bytes32 => uint256) collateralFeeAmount;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = FEE_REWARDS;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function loadPoolRewards(address stakeToken) public view returns (MarketRewards storage) {\n        return load().poolRewards[stakeToken];\n    }\n\n    function loadMarketTradingRewards(bytes32 symbol) public view returns (MarketRewards storage) {\n        return load().marketTradingRewards[symbol];\n    }\n\n    function loadStakingRewards() public view returns (StakingRewards storage) {\n        return load().stakingRewards;\n    }\n\n    function loadDaoRewards() public view returns (StakingRewards storage) {\n        return load().daoRewards;\n    }\n\n    function addFeeAmount(MarketRewards storage self, address token, uint256 fee) external {\n        if (!self.tokens.contains(token)) {\n            self.tokens.add(token);\n        }\n        self.feeAmount[token] = self.feeAmount[token] + fee;\n    }\n\n    function subFeeAmount(MarketRewards storage self, address token, uint256 fee) external {\n        self.feeAmount[token] = self.feeAmount[token] - fee;\n    }\n\n    function setFeeAmountZero(MarketRewards storage self, address token) external {\n        self.feeAmount[token] = 0;\n    }\n\n    function addUnsettleFeeAmount(MarketRewards storage self, address token, uint256 fee) external {\n        if (!self.tokens.contains(token)) {\n            self.tokens.add(token);\n        }\n        self.unsettledFeeAmount[token] = self.unsettledFeeAmount[token] + fee;\n    }\n\n    function subUnsettleFeeAmount(MarketRewards storage self, address token, uint256 fee) external {\n        self.unsettledFeeAmount[token] = self.unsettledFeeAmount[token] - fee;\n    }\n\n    function addCollateralFeeAmount(MarketRewards storage self, address token, uint256 fee) external {\n        if (!self.collateralTokens.contains(token)) {\n            self.collateralTokens.add(token);\n        }\n        self.collateralFeeAmount[token] = self.collateralFeeAmount[token] + fee;\n    }\n\n    function subCollateralFeeAmount(MarketRewards storage self, address token, uint256 fee) external {\n        self.collateralFeeAmount[token] = self.collateralFeeAmount[token] - fee;\n    }\n\n    function getFeeTokens(MarketRewards storage self) external view returns (address[] memory) {\n        return self.tokens.values();\n    }\n\n    function getCollateralFeeTokens(MarketRewards storage self) external view returns (address[] memory) {\n        return self.collateralTokens.values();\n    }\n\n    function getFeeAmount(MarketRewards storage self, address token) external view returns (uint256) {\n        return self.feeAmount[token];\n    }\n\n    function getUnsettleFeeAmount(MarketRewards storage self, address token) external view returns (uint256) {\n        return self.unsettledFeeAmount[token];\n    }\n\n    function getCollateralFeeAmount(MarketRewards storage self, address token) external view returns (uint256) {\n        return self.collateralFeeAmount[token];\n    }\n\n    function getCumulativeRewardsPerStakeToken(MarketRewards storage self) external view returns (uint256) {\n        return self.cumulativeRewardsPerStakeToken;\n    }\n\n    function addLastRewardsPerStakeTokenDelta(\n        MarketRewards storage self,\n        uint256 delta,\n        uint256 maxIntervals\n    ) external {\n        if (self.lastRewardsPerStakeTokenDeltas.length >= maxIntervals) {\n            delete self.lastRewardsPerStakeTokenDeltas[0];\n        }\n        self.lastRewardsPerStakeTokenDeltas.push(delta);\n    }\n\n    function getPoolRewardsPerStakeTokenDeltaLimit(\n        MarketRewards storage self\n    ) external view returns (uint256 deltaLimit) {\n        for (uint256 i; i < self.lastRewardsPerStakeTokenDeltas.length; i++) {\n            deltaLimit += self.lastRewardsPerStakeTokenDeltas[i];\n        }\n    }\n\n    function addFeeAmount(StakingRewards storage self, address market, address token, uint256 fee) external {\n        if (!self.tokens.contains(token)) {\n            self.tokens.add(token);\n        }\n        bytes32 key = generateFeeAmountKey(market, token);\n        self.feeAmount[key] = self.feeAmount[key] + fee;\n    }\n\n    function addUnsettleFeeAmount(StakingRewards storage self, address market, address token, uint256 fee) external {\n        if (!self.tokens.contains(token)) {\n            self.tokens.add(token);\n        }\n        bytes32 key = generateFeeAmountKey(market, token);\n        self.unsettledFeeAmount[key] = self.unsettledFeeAmount[key] + fee;\n    }\n\n    function addCollateralFeeAmount(StakingRewards storage self, address market, address token, uint256 fee) external {\n        if (!self.collateralTokens.contains(token)) {\n            self.collateralTokens.add(token);\n        }\n        bytes32 key = generateFeeAmountKey(market, token);\n        self.collateralFeeAmount[key] = self.collateralFeeAmount[key] + fee;\n    }\n\n    function getFeeAmount(StakingRewards storage self, address market, address token) external view returns (uint256) {\n        bytes32 key = generateFeeAmountKey(market, token);\n        return self.feeAmount[key];\n    }\n\n    function getUnsettleFeeAmount(\n        StakingRewards storage self,\n        address market,\n        address token\n    ) external view returns (uint256) {\n        bytes32 key = generateFeeAmountKey(market, token);\n        return self.unsettledFeeAmount[key];\n    }\n\n    function getCollateralFeeAmount(\n        StakingRewards storage self,\n        address market,\n        address token\n    ) external view returns (uint256) {\n        bytes32 key = generateFeeAmountKey(market, token);\n        return self.collateralFeeAmount[key];\n    }\n}\n"
    },
    "contracts/storage/InsuranceFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary InsuranceFund {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using SafeMath for uint256;\n\n    struct Props {\n        EnumerableMap.AddressToUintMap funds;\n    }\n\n    function load(address stakeToken) public pure returns (Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profit.storage.InsuranceFund\", stakeToken));\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function addFunds(address stakeToken, address token, uint256 amount) public {\n        InsuranceFund.Props storage self = load(stakeToken);\n        (bool exists, uint256 preAmount) = self.funds.tryGet(token);\n        if (exists) {\n            self.funds.set(token, preAmount + amount);\n        } else {\n            self.funds.set(token, amount);\n        }\n    }\n\n    function getFundsTokens(InsuranceFund.Props storage self) external view returns (address[] memory) {\n        return self.funds.keys();\n    }\n\n    function getTokenFee(InsuranceFund.Props storage self, address token) external view returns (uint256) {\n        (bool exists, uint256 preAmount) = self.funds.tryGet(token);\n        return exists ? preAmount : 0;\n    }\n}\n"
    },
    "contracts/storage/LiabilityClean.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary LiabilityClean {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    struct Props {\n        EnumerableSet.UintSet cleanIds;\n        mapping(uint256 => LiabilityCleanInfo) cleanInfos;\n    }\n\n    struct LiabilityCleanInfo {\n        address account;\n        uint256 liquidationTime;\n        address[] liabilityTokens;\n        uint256[] liabilities;\n        address[] collaterals;\n        uint256[] collateralsAmount;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profit.storage.LiabilityClean\"));\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function newClean(uint256 cleanId) external returns (LiabilityCleanInfo storage info) {\n        Props storage self = load();\n        self.cleanIds.add(cleanId);\n        return self.cleanInfos[cleanId];\n    }\n\n    function addClean(uint256 cleanId, LiabilityCleanInfo memory info) external {\n        Props storage self = load();\n        self.cleanIds.add(cleanId);\n        self.cleanInfos[cleanId] = info;\n    }\n\n    function removeClean(uint256 cleanId) external {\n        Props storage self = load();\n        self.cleanIds.remove(cleanId);\n        delete self.cleanInfos[cleanId];\n    }\n\n    function getAllCleanInfo() external view returns(LiabilityCleanInfo[] memory) {\n        Props storage self = load();\n        uint256[] memory ids = self.cleanIds.values();\n        LiabilityCleanInfo[] memory cleanInfos = new LiabilityCleanInfo[](ids.length);\n        for (uint256 i; i < ids.length; i++) {\n            cleanInfos[i] = self.cleanInfos[ids[i]];\n        }\n        return cleanInfos;\n    }\n}\n"
    },
    "contracts/storage/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamond } from \"../interfaces/IDiamond.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror NoSelectorsGivenToAdd();\nerror NotContractOwner(address _user, address _contractOwner);\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\nerror IncorrectFacetCutAction(uint8 _action);\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\nerror CannotReplaceImmutableFunction(bytes4 _selector);\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\nerror CannotRemoveImmutableFunction(bytes4 _selector);\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndSelectorPosition {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        // function selector => facet address and selector position in selectors array\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\n        bytes4[] selectors;\n        mapping(bytes4 => bool) supportedInterfaces;\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner) {\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\n        }\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\n            if (functionSelectors.length == 0) {\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\n            }\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamond.FacetCutAction.Add) {\n                addFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Replace) {\n                replaceFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Remove) {\n                removeFunctions(facetAddress, functionSelectors);\n            } else {\n                revert IncorrectFacetCutAction(uint8(action));\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        if (_facetAddress == address(0)) {\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\n        }\n        DiamondStorage storage ds = diamondStorage();\n        uint16 selectorCount = uint16(ds.selectors.length);\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: Add facet has no code\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            if (oldFacetAddress != address(0)) {\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\n            }\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(\n                _facetAddress,\n                selectorCount\n            );\n            ds.selectors.push(selector);\n            selectorCount++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        DiamondStorage storage ds = diamondStorage();\n        if (_facetAddress == address(0)) {\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\n        }\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: Replace facet has no code\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\n            if (oldFacetAddress == address(this)) {\n                revert CannotReplaceImmutableFunction(selector);\n            }\n            if (oldFacetAddress == _facetAddress) {\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\n            }\n            if (oldFacetAddress == address(0)) {\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\n            }\n            // replace old facet address\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        if (_facetAddress != address(0)) {\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds\n                .facetAddressAndSelectorPosition[selector];\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\n            }\n\n            // can't remove immutable functions -- functions defined directly in the diamond\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\n                revert CannotRemoveImmutableFunction(selector);\n            }\n            // replace selector with last selector\n            selectorCount--;\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\n                bytes4 lastSelector = ds.selectors[selectorCount];\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition\n                    .selectorPosition;\n            }\n            // delete last selector\n            ds.selectors.pop();\n            delete ds.facetAddressAndSelectorPosition[selector];\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/storage/LpPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/ChainUtils.sol\";\nimport \"../utils/Errors.sol\";\nimport \"./Config.sol\";\n\nlibrary LpPool {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeMath for uint256;\n    using Config for Config.Props;\n\n    struct Props {\n        address stakeToken;\n        string stakeTokenName;\n        address baseToken;\n        bytes32 symbol;\n        TokenBalance baseTokenBalance;\n        EnumerableSet.AddressSet stableTokens;\n        mapping(address => TokenBalance) stableTokenBalances;\n        mapping(address => FeeRewards) tradingFeeRewards;\n        BorrowingFee borrowingFee;\n        uint256 apr;\n    }\n\n    struct TokenBalance {\n        uint256 amount;\n        uint256 liability;\n        uint256 holdAmount;\n        int256 unsettledAmount;\n        uint256 lossAmount;\n        EnumerableMap.AddressToUintMap collateralTokenAmounts;\n    }\n\n    struct FeeRewards {\n        uint256 amount;\n        uint256 unsettledAmount;\n    }\n\n    struct BorrowingFee {\n        // uint256 baseInterestRate;\n        uint256 totalBorrowingFee;\n        uint256 totalRealizedBorrowingFee;\n        uint256 cumulativeBorrowingFeePerToken;\n        uint256 lastUpdateTime;\n    }\n\n    struct PoolTokenUpdateEventCache {\n        address stakeToken;\n        address token;\n        uint256 preAmount;\n        uint256 preLiability;\n        uint256 preHoldAmount;\n        int256 preUnsettledAmount;\n        uint256 preLossAmount;\n        uint256 amount;\n        uint256 liability;\n        uint256 holdAmount;\n        int256 unsettledAmount;\n        uint256 lossAmount;\n        uint256 updateBlock;\n    }\n\n    event PoolTokenUpdateEvent(\n        address stakeToken,\n        address token,\n        uint256 preAmount,\n        uint256 preLiability,\n        uint256 preHoldAmount,\n        int256 preUnsettledAmount,\n        uint256 preLossAmount,\n        uint256 amount,\n        uint256 liability,\n        uint256 holdAmount,\n        int256 unsettledAmount,\n        uint256 lossAmount,\n        uint256 updateBlock\n    );\n\n    event PoolCollateralTokenUpdateEvent(\n        address stakeToken,\n        address collateral,\n        uint256 preAmount,\n        uint256 amount,\n        uint256 updateBlock\n    );\n\n    function load(address stakeToken) public pure returns (Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profile.storage.LpPool\", stakeToken));\n\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function getPoolConfig(address stakeToken) public view returns (Config.LpPoolConfig storage) {\n        return Config.load().getPoolConfig(stakeToken);\n    }\n\n    function addBaseToken(Props storage self, uint256 amount) external {\n        addBaseToken(self, amount, true);\n    }\n\n    function addBaseToken(Props storage self, uint256 amount, bool needEmitEvent) public {\n        if (needEmitEvent) {\n            PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(\n                self.stakeToken,\n                self.baseToken,\n                self.baseTokenBalance\n            );\n            self.baseTokenBalance.amount += amount;\n            cache.amount = self.baseTokenBalance.amount;\n            _emitPoolUpdateEvent(cache);\n        } else {\n            self.baseTokenBalance.amount += amount;\n        }\n    }\n\n    function addCollateralBaseToken(\n        Props storage self,\n        uint256 amount,\n        address collateral,\n        uint256 collateralAmount\n    ) external {\n        TokenBalance storage balance = self.baseTokenBalance;\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(self.stakeToken, self.baseToken, balance);\n        balance.amount += amount;\n        balance.liability += amount;\n        cache.amount = balance.amount;\n        cache.liability = balance.liability;\n\n        (bool exists, uint256 tokenAmount) = balance.collateralTokenAmounts.tryGet(collateral);\n        if (exists) {\n            balance.collateralTokenAmounts.set(collateral, tokenAmount + collateralAmount);\n        } else {\n            balance.collateralTokenAmounts.set(collateral, collateralAmount);\n        }\n        _emitPoolUpdateEvent(cache);\n        emit PoolCollateralTokenUpdateEvent(\n            self.stakeToken,\n            collateral,\n            tokenAmount,\n            tokenAmount + collateralAmount,\n            ChainUtils.currentBlock()\n        );\n    }\n\n    function subBaseToken(Props storage self, uint256 amount) external {\n        subBaseToken(self, amount, true);\n    }\n\n    function subBaseToken(Props storage self, uint256 amount, bool emitEvent) public {\n        require(self.baseTokenBalance.amount >= amount, \"base token amount less than sub amount!\");\n        if (emitEvent) {\n            PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(\n                self.stakeToken,\n                self.baseToken,\n                self.baseTokenBalance\n            );\n            self.baseTokenBalance.amount -= amount;\n            cache.amount = self.baseTokenBalance.amount;\n            _emitPoolUpdateEvent(cache);\n        } else {\n            self.baseTokenBalance.amount -= amount;\n        }\n    }\n\n    function subCollateralBaseToken(\n        Props storage self,\n        uint256 amount,\n        address collateral,\n        uint256 collateralAmount\n    ) external {\n        require(\n            self.baseTokenBalance.amount >= amount && self.baseTokenBalance.liability >= amount,\n            \"sub failed with balance not enough\"\n        );\n\n        TokenBalance storage balance = self.baseTokenBalance;\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(self.stakeToken, self.baseToken, balance);\n        balance.amount -= amount;\n        balance.liability -= amount;\n        cache.amount = balance.amount;\n        cache.liability = balance.liability;\n        uint256 tokenAmount = balance.collateralTokenAmounts.get(collateral);\n        if (tokenAmount == collateralAmount) {\n            balance.collateralTokenAmounts.remove(collateral);\n        } else {\n            balance.collateralTokenAmounts.set(collateral, tokenAmount - collateralAmount);\n        }\n\n        _emitPoolUpdateEvent(cache);\n        emit PoolCollateralTokenUpdateEvent(\n            self.stakeToken,\n            collateral,\n            tokenAmount,\n            tokenAmount - collateralAmount,\n            ChainUtils.currentBlock()\n        );\n    }\n\n    function holdBaseToken(Props storage self, uint256 amount) external {\n        require(\n            isHoldAmountAllowed(self.baseTokenBalance, getPoolLiquidityLimit(self), amount),\n            \"hold failed with balance not enough\"\n        );\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(\n            self.stakeToken,\n            self.baseToken,\n            self.baseTokenBalance\n        );\n        self.baseTokenBalance.holdAmount += amount;\n        cache.holdAmount = self.baseTokenBalance.holdAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function unHoldBaseToken(Props storage self, uint256 amount) external {\n        require(self.baseTokenBalance.holdAmount >= amount, \"sub hold bigger than hold\");\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(\n            self.stakeToken,\n            self.baseToken,\n            self.baseTokenBalance\n        );\n        self.baseTokenBalance.holdAmount -= amount;\n        cache.holdAmount = self.baseTokenBalance.holdAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function addUnsettleBaseToken(Props storage self, int256 amount) external {\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(\n            self.stakeToken,\n            self.baseToken,\n            self.baseTokenBalance\n        );\n        self.baseTokenBalance.unsettledAmount += amount;\n        cache.unsettledAmount = self.baseTokenBalance.unsettledAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function settleBaseToken(Props storage self, uint256 amount) external {\n        int256 amountInt = amount.toInt256();\n        require(self.baseTokenBalance.unsettledAmount >= amountInt, \"settle base token overflow!\");\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(\n            self.stakeToken,\n            self.baseToken,\n            self.baseTokenBalance\n        );\n        self.baseTokenBalance.unsettledAmount -= amountInt;\n        self.baseTokenBalance.amount += amount;\n        cache.unsettledAmount = self.baseTokenBalance.unsettledAmount;\n        cache.amount = self.baseTokenBalance.amount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function addStableToken(Props storage self, address stableToken, uint256 amount) external {\n        if (self.stableTokens.contains(stableToken)) {\n            self.stableTokenBalances[stableToken].amount += amount;\n        } else {\n            self.stableTokens.add(stableToken);\n            self.stableTokenBalances[stableToken].amount = amount;\n        }\n    }\n\n    function subStableToken(Props storage self, address stableToken, uint256 amount) external {\n        self.stableTokenBalances[stableToken].amount -= amount;\n        if (self.stableTokenBalances[stableToken].amount == 0) {\n            self.stableTokens.remove(stableToken);\n            delete self.stableTokenBalances[stableToken];\n        }\n    }\n\n    function holdStableToken(Props storage self, address stableToken, uint256 amount) external {\n        require(\n            isHoldAmountAllowed(self.stableTokenBalances[stableToken], getPoolLiquidityLimit(self), amount),\n            \"hold failed with balance not enough\"\n        );\n        self.stableTokenBalances[stableToken].holdAmount += amount;\n    }\n\n    function unHoldStableToken(Props storage self, address stableToken, uint256 amount) external {\n        require(self.stableTokenBalances[stableToken].holdAmount < amount, \"sub hold bigger than hold\");\n        self.stableTokenBalances[stableToken].holdAmount -= amount;\n    }\n\n    function addUnsettleStableToken(Props storage self, address stableToken, int256 amount) external {\n        if (!self.stableTokens.contains(stableToken)) {\n            self.stableTokens.add(stableToken);\n        }\n        self.stableTokenBalances[stableToken].unsettledAmount += amount;\n    }\n\n    function settleStableToken(Props storage self, address stableToken, uint256 amount) external {\n        if (!self.stableTokens.contains(stableToken)) {\n            self.stableTokens.add(stableToken);\n        }\n        int256 amountInt = amount.toInt256();\n        TokenBalance storage balance = self.stableTokenBalances[stableToken];\n        require(balance.unsettledAmount >= amountInt, \"settle stable token overflow!\");\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(self.stakeToken, stableToken, balance);\n        balance.unsettledAmount -= amountInt;\n        balance.amount += amount;\n        cache.unsettledAmount = balance.unsettledAmount;\n        cache.amount = balance.amount;\n        \n        _emitPoolUpdateEvent(cache);\n    }\n\n    function addLossStableToken(Props storage self, address stableToken, uint256 amount) external {\n        if (!self.stableTokens.contains(stableToken)) {\n            self.stableTokens.add(stableToken);\n        }\n        TokenBalance storage balance = self.stableTokenBalances[stableToken];\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(self.stakeToken, stableToken, balance);\n        balance.lossAmount += amount;\n        cache.lossAmount = balance.lossAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function subLossStableToken(Props storage self, address stableToken, uint256 amount) external {\n        if (!self.stableTokens.contains(stableToken)) {\n            self.stableTokens.add(stableToken);\n        }\n        TokenBalance storage balance = self.stableTokenBalances[stableToken];\n        require(balance.lossAmount >= amount, \"sub loss stable token overflow!\");\n        PoolTokenUpdateEventCache memory cache = _convertBalanceToCache(self.stakeToken, stableToken, balance);\n        balance.lossAmount -= amount;\n        cache.lossAmount = balance.lossAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function getStableTokens(Props storage self) external view returns (address[] memory) {\n        return self.stableTokens.values();\n    }\n\n    function getStableTokenBalance(\n        Props storage self,\n        address stableToken\n    ) external view returns (TokenBalance storage) {\n        return self.stableTokenBalances[stableToken];\n    }\n\n    function getSupportCollateralTokens(Props storage self) external view returns (address[] memory) {\n        return getPoolConfig(self.stakeToken).supportCollateralTokens.values();\n    }\n\n    function getPoolLiquidityLimit(Props storage self) public view returns (uint256) {\n        return getPoolConfig(self.stakeToken).poolLiquidityLimit;\n    }\n\n    function addStakeCollateralToken(\n        Props storage self,\n        address token,\n        Config.StakeCollateralConfig memory collateralConfig\n    ) external {\n        getPoolConfig(self.stakeToken).supportCollateralTokens.add(token);\n        getPoolConfig(self.stakeToken).collateralTokensConfigs[token] = collateralConfig;\n    }\n\n    function isStakeCollateralSupport(Props storage self, address collateral) external view returns (bool) {\n        return getPoolConfig(self.stakeToken).supportCollateralTokens.contains(collateral);\n    }\n\n    function getStakeCollateralConfig(\n        Props storage self,\n        address collateral\n    ) external view returns (Config.StakeCollateralConfig memory) {\n        return getPoolConfig(self.stakeToken).collateralTokensConfigs[collateral];\n    }\n\n    function getCollateralTokenAmounts(\n        EnumerableMap.AddressToUintMap storage collateralTokenAmounts\n    ) external view returns (address[] memory tokens, uint256[] memory amounts) {\n        tokens = collateralTokenAmounts.keys();\n        amounts = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            amounts[i] = collateralTokenAmounts.get(tokens[i]);\n        }\n    }\n\n    function getCollateralTokenAmount(Props storage self, address token) external view returns (uint256) {\n        (bool exists, uint256 amount) = self.baseTokenBalance.collateralTokenAmounts.tryGet(token);\n        return exists ? amount : 0;\n    }\n\n    function isSubAmountAllowed(Props storage self, address token, uint256 amount) internal view returns (bool) {\n        TokenBalance storage balance = token == self.baseToken\n            ? self.baseTokenBalance\n            : self.stableTokenBalances[token];\n        if (balance.amount < amount) {\n            return false;\n        }\n        uint256 poolLiquidityLimit = getPoolLiquidityLimit(self);\n        if (poolLiquidityLimit == 0) {\n            return\n                balance.amount.toInt256() + balance.unsettledAmount - balance.holdAmount.toInt256() >=\n                amount.toInt256();\n        } else {\n            return\n                CalUtils.mulRate(\n                    balance.amount.toInt256() - amount.toInt256() + balance.unsettledAmount,\n                    poolLiquidityLimit.toInt256()\n                ) >= balance.holdAmount.toInt256();\n        }\n    }\n\n    function isHoldAmountAllowed(\n        TokenBalance storage balance,\n        uint256 poolLiquidityLimit,\n        uint256 amount\n    ) public view returns (bool) {\n        if (poolLiquidityLimit == 0) {\n            return\n                balance.amount.toInt256() + balance.unsettledAmount - balance.holdAmount.toInt256() >=\n                amount.toInt256();\n        } else {\n            return\n                CalUtils.mulRate(balance.amount.toInt256() + balance.unsettledAmount, poolLiquidityLimit.toInt256()) -\n                    balance.holdAmount.toInt256() >=\n                amount.toInt256();\n        }\n    }\n\n    function checkExists(Props storage self) external view {\n        if (self.baseToken == address(0)) {\n            revert Errors.PoolNotExists();\n        }\n    }\n\n    function _convertBalanceToCache(\n        address stakeToken,\n        address token,\n        TokenBalance storage balance\n    ) internal view returns (PoolTokenUpdateEventCache memory cache) {\n        cache.stakeToken = stakeToken;\n        cache.token = token;\n        cache.preAmount = balance.amount;\n        cache.preLiability = balance.liability;\n        cache.preHoldAmount = balance.holdAmount;\n        cache.preUnsettledAmount = balance.unsettledAmount;\n        cache.preLossAmount = balance.lossAmount;\n        cache.amount = balance.amount;\n        cache.liability = balance.liability;\n        cache.holdAmount = balance.holdAmount;\n        cache.unsettledAmount = balance.unsettledAmount;\n        cache.lossAmount = balance.lossAmount;\n        cache.updateBlock = ChainUtils.currentBlock();\n    }\n\n    function _emitPoolUpdateEvent(PoolTokenUpdateEventCache memory cache) internal {\n        emit PoolTokenUpdateEvent(\n            cache.stakeToken,\n            cache.token,\n            cache.preAmount,\n            cache.preLiability,\n            cache.preHoldAmount,\n            cache.preUnsettledAmount,\n            cache.preLossAmount,\n            cache.amount,\n            cache.liability,\n            cache.holdAmount,\n            cache.unsettledAmount,\n            cache.lossAmount,\n            cache.updateBlock\n        );\n    }\n}\n"
    },
    "contracts/storage/Market.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\n\nlibrary Market {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct Props {\n        bytes32 symbol;\n        address stakeToken;\n        MarketPosition longPosition;\n        EnumerableSet.AddressSet shortPositionTokens;\n        mapping(address => MarketPosition) shortPositionMap;\n        FundingFee fundingFee;\n    }\n\n    struct MarketPosition {\n        uint256 openInterest;\n        uint256 entryPrice;\n    }\n\n    struct FundingFee {\n        int256 longFundingFeePerQty;\n        int256 shortFundingFeePerQty;\n        int256 totalLongFundingFee;\n        int256 totalShortFundingFee;\n        uint256 lastUpdateTime;\n    }\n\n    function load(bytes32 symbol) public pure returns (Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profile.storage.Market\", symbol));\n\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function addShortToken(Props storage self, address token) external {\n        if (!self.shortPositionTokens.contains(token)) {\n            self.shortPositionTokens.add(token);\n        }\n    }\n\n    function getShortPositionTokens(Props storage self) external view returns (address[] memory) {\n        return self.shortPositionTokens.values();\n    }\n\n    function getShortPosition(Props storage self, address token) external view returns (MarketPosition memory) {\n        return self.shortPositionMap[token];\n    }\n\n    function getAllShortPositions(Props storage self) external view returns (MarketPosition[] memory) {\n        address[] memory tokens = self.shortPositionTokens.values();\n        MarketPosition[] memory shortPositions = new MarketPosition[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            shortPositions[i] = self.shortPositionMap[tokens[i]]; \n        }\n        return shortPositions;\n    }\n\n    function getLongOpenInterest(Props storage self) external view returns (uint256) {\n        return self.longPosition.openInterest;\n    }\n\n    function getAllShortOpenInterest(Props storage self) external view returns (uint256) {\n        address[] memory tokens = self.shortPositionTokens.values();\n        uint256 sum = 0;\n        for (uint256 i; i < tokens.length; i++) {\n            sum += self.shortPositionMap[tokens[i]].openInterest;\n        }\n        return sum;\n    }\n}\n"
    },
    "contracts/storage/Mint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nlibrary Mint {\n    bytes32 constant MINT_KEY = keccak256(abi.encode(\"link.profile.storage.Mint\"));\n\n    struct Props {\n        mapping(uint256 => Request) requests;\n    }\n\n    struct Request {\n        address account;\n        address receiver;\n        address stakeToken;\n        address requestToken;\n        uint256 requestTokenAmount;\n        uint256 walletRequestTokenAmount;\n        uint256 minStakeAmount;\n        uint256 executionFee;\n        bool isCollateral;\n        bool isExecutionFeeFromLpVault;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = MINT_KEY;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(uint256 requestId) external view returns (Request storage) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function get(uint256 requestId) external view returns (Request memory) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function remove(uint256 requestId) external {\n        Props storage self = load();\n        delete self.requests[requestId];\n    }\n}\n"
    },
    "contracts/storage/OracleFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nlibrary OracleFeed {\n\n    // enum OracleFrom {\n    //     NONE, CHAINLINK\n    // }\n\n    struct Props {\n        // OracleFrom from;\n        mapping(address => address) feedUsdAddresses;\n    }\n\n    function load() public pure returns(Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profit.storage.OracleFeed\"));\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(address[] memory tokens, address[] memory usdFeeds) external returns(Props storage feed) {\n        feed = load();\n        for (uint256 i; i < tokens.length; i++) {\n            feed.feedUsdAddresses[tokens[i]] = usdFeeds[i];\n        }\n    }\n\n    function getFeedUsdAddress(address token) external view returns (address){\n        Props storage feedProps = load();\n        return feedProps.feedUsdAddresses[token];\n    }\n\n}\n"
    },
    "contracts/storage/OraclePrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary OraclePrice {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    bytes32 private constant _ORACLE_PRICE = keccak256(abi.encode(\"link.profit.storage.OraclePrice\"));\n\n    struct Props {\n        EnumerableSet.AddressSet tokens;\n        mapping(address => Data) tokenPrices;\n        mapping(address => Data) preTokenPrices;\n        EnumerableSet.Bytes32Set pairs;\n        mapping(bytes32 => Data) pairPrices;\n    }\n\n    struct Data {\n        int256 min;\n        int256 max;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = _ORACLE_PRICE;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function getPrice(Props storage oracle, address token) external view returns (Data memory) {\n        return oracle.tokenPrices[token];\n    }\n\n    function getPrice(Props storage oracle, address token, address targetToken) external view returns (Data memory) {\n        bytes32 pair = keccak256(abi.encode(token, targetToken));\n        return oracle.pairPrices[pair];\n    }\n\n    function getPrePrice(Props storage oracle, address token) external view returns (Data memory) {\n        return oracle.preTokenPrices[token];\n    }\n\n    function setPrice(Props storage oracle, address token, Data memory price) public {\n        if (!oracle.tokens.contains(token)) {\n            oracle.tokens.add(token);\n        }\n        oracle.tokenPrices[token] = price;\n    }\n\n    function setPrice(Props storage oracle, address token, address targetToken, Data memory price) public {\n        bytes32 pair = keccak256(abi.encode(token, targetToken));\n        if (!oracle.pairs.contains(pair)) {\n            oracle.pairs.add(pair);\n        }\n        oracle.pairPrices[pair] = price;\n    }\n\n    function setPrePrice(Props storage oracle, address token, Data calldata price) external {\n        if (!oracle.tokens.contains(token)) {\n            oracle.tokens.add(token);\n        }\n        oracle.preTokenPrices[token] = price;\n    }\n\n    function clearAllPrice(Props storage oracle) external {\n        address[] memory tokenAddrs = oracle.tokens.values();\n        for (uint256 i; i < tokenAddrs.length; i++) {\n            delete oracle.tokenPrices[tokenAddrs[i]];\n            delete oracle.preTokenPrices[tokenAddrs[i]];\n            oracle.tokens.remove(tokenAddrs[i]);\n        }\n    }\n}\n"
    },
    "contracts/storage/Order.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary Order {\n    bytes32 constant ORDER = keccak256(abi.encode(\"link.profile.storage.Order\"));\n\n    enum PositionSide {\n        NONE,\n        INCREASE,\n        DECREASE\n    }\n\n    enum Side {\n        NONE,\n        LONG,\n        SHORT\n    }\n\n    enum Type {\n        NONE,\n        MARKET,\n        LIMIT,\n        STOP\n    }\n\n    enum StopType {\n        NONE,\n        STOP_LOSS,\n        TAKE_PROFIT\n    }\n\n    struct Props {\n        mapping(uint256 => OrderInfo) orders;\n    }\n\n    struct OrderInfo {\n        address account;\n        bytes32 symbol;\n        Side orderSide;\n        PositionSide posSide;\n        Type orderType;\n        StopType stopType;\n        bool isCrossMargin;\n        bool isExecutionFeeFromTradeVault;\n        address marginToken;\n        uint256 qty;\n        uint256 leverage; //position leverage\n        uint256 orderMargin;\n        uint256 triggerPrice; // for limit & stop order\n        uint256 acceptablePrice; //for market & stop order\n        uint256 placeTime;\n        uint256 executionFee;\n        uint256 lastBlock;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = ORDER;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(uint256 orderId) external view returns (OrderInfo storage) {\n        Order.Props storage self = load();\n        return self.orders[orderId];\n    }\n\n    function get(Order.Props storage self, uint256 orderId) external view returns (OrderInfo storage) {\n        return self.orders[orderId];\n    }\n\n    function get(uint256 orderId) external view returns (OrderInfo storage) {\n        Order.Props storage self = load();\n        return self.orders[orderId];\n    }\n\n    function remove(Order.Props storage self, uint256 orderId) external {\n        delete self.orders[orderId];\n    }\n\n    function remove(uint256 orderId) external {\n        Order.Props storage self = load();\n        delete self.orders[orderId];\n    }\n\n    function updateAllOrderLeverage(\n        uint256[] memory orders,\n        bytes32 symbol,\n        address marginToken,\n        uint256 leverage,\n        bool isLong,\n        bool isCrossMargin\n    ) external {\n        Order.Props storage self = load();\n        for (uint256 i; i < orders.length; i++) {\n            Order.OrderInfo storage orderInfo = self.orders[orders[i]];\n            bool isLongOrder = orderInfo.orderSide == Order.Side.LONG;\n            if (\n                orderInfo.isCrossMargin == isCrossMargin &&\n                orderInfo.symbol == symbol &&\n                orderInfo.marginToken == marginToken &&\n                ((isLongOrder == isLong && orderInfo.posSide == Order.PositionSide.INCREASE) ||\n                    (isLongOrder != isLong && orderInfo.posSide == Order.PositionSide.DECREASE))\n            ) {\n                orderInfo.leverage = leverage;\n            }\n        }\n    }\n\n    function hasOtherShortOrders(\n        uint256[] memory orders,\n        bytes32 symbol,\n        address marginToken,\n        bool isCrossMargin\n    ) external view returns (bool) {\n        Order.Props storage self = load();\n        for (uint256 i; i < orders.length; i++) {\n            Order.OrderInfo storage orderInfo = self.orders[orders[i]];\n            if (\n                orderInfo.symbol == symbol &&\n                orderInfo.marginToken != marginToken &&\n                orderInfo.isCrossMargin == isCrossMargin &&\n                orderInfo.posSide == Order.PositionSide.INCREASE &&\n                orderInfo.orderSide == Order.Side.SHORT\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/storage/PermissionFlag.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary PermissionFlag {\n\n    bytes32 public constant ALL_PERMISSION_FLAG = keccak256(\"ALL_PERMISSION_FLAG\");\n    bytes32 public constant MINT_PERMISSION_FLAG = keccak256(\"MINT_PERMISSION_FLAG\");\n    bytes32 public constant BURN_PERMISSION_FLAG = keccak256(\"BURN_PERMISSION_FLAG\");\n    bytes32 public constant DEPOSIT_PERMISSION_FLAG = keccak256(\"DEPOSIT_PERMISSION_FLAG\");\n    bytes32 public constant WITHDRAW_PERMISSION_FLAG = keccak256(\"WITHDRAW_PERMISSION_FLAG\");\n    bytes32 public constant ORDER_PERMISSION_FLAG = keccak256(\"ORDER_PERMISSION_FLAG\");\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct Props {\n        EnumerableSet.AddressSet allowSet;\n        EnumerableSet.AddressSet denySet;\n    }\n\n    error AddressDenied(address to);\n\n    function load(bytes32 featureKey) public pure returns(Props storage self){\n        bytes32 s = keccak256(abi.encode(\"link.profit.storage.Permission\", featureKey));\n        assembly {\n            self.slot := s\n        }    \n    }\n\n    function isAllowed(bytes32 featureKey, address to) external view returns (bool){\n        Props storage permission = load(featureKey);\n        return permission.allowSet.contains(to);\n    }\n\n    function isDenied(bytes32 featureKey, address to) external view returns (bool) {\n        Props storage permission = load(featureKey);\n        return permission.denySet.contains(to);\n    }\n\n    function validDenied(bytes32 featureKey, address to) external view {\n        Props storage permission = load(featureKey);\n        if(permission.denySet.contains(to)) {\n            revert AddressDenied(to);\n        }\n    }\n\n\n}"
    },
    "contracts/storage/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"../utils/Errors.sol\";\n\nlibrary Position {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCast for uint256;\n\n    struct Props {\n        bytes32 key;\n        bytes32 symbol;\n        bool isLong;\n        bool isCrossMargin;\n        address account;\n        address marginToken;\n        address indexToken;\n        uint256 qty;\n        uint256 entryPrice;\n        uint256 leverage;\n        uint256 initialMargin;\n        uint256 initialMarginInUsd;\n        uint256 initialMarginInUsdFromBalance;\n        uint256 holdPoolAmount;\n        PositionFee positionFee;\n        int256 realizedPnl;\n        uint256 lastUpdateTime;\n    }\n\n    struct PositionFee {\n        uint256 closeFeeInUsd;\n        uint256 openBorrowingFeePerToken;\n        uint256 realizedBorrowingFee;\n        uint256 realizedBorrowingFeeInUsd;\n        int256 openFundingFeePerQty;\n        int256 realizedFundingFee;\n        int256 realizedFundingFeeInUsd;\n    }\n\n    enum PositionUpdateFrom {\n        NONE,\n        ORDER_INCREASE,\n        ORDER_DECREASE,\n        ADD_MARGIN,\n        DECREASE_MARGIN,\n        INCREASE_LEVERAGE,\n        DECREASE_LEVERAGE,\n        LIQUIDATION\n    }\n\n    event PositionUpdateEvent(\n        uint256 requestId,\n        bytes32 positionKey,\n        PositionUpdateFrom from,\n        Props position,\n        uint256 executePrice\n    );\n\n    function load(\n        address account,\n        bytes32 symbol,\n        address marginToken,\n        bool isCrossMargin\n    ) public pure returns (Props storage position) {\n        return load(getPositionKey(account, symbol, marginToken, isCrossMargin));\n    }\n\n    function load(bytes32 key) public pure returns (Props storage self) {\n        assembly {\n            self.slot := key\n        }\n    }\n\n    function getPositionKey(\n        address account,\n        bytes32 symbol,\n        address marginToken,\n        bool isCrossMargin\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(\"link.profile.storage.Position\", account, symbol, marginToken, isCrossMargin));\n    }\n\n    function hasPosition(Props storage self) external view returns (bool) {\n        return self.qty > 0;\n    }\n\n    function checkExists(Props storage self) external view {\n        if (self.qty == 0) {\n            revert Errors.PositionNotExists();\n        }\n    }\n\n    function reset(Props storage self) external {\n        self.qty = 0;\n        self.entryPrice = 0;\n        self.leverage = 0;\n        self.initialMargin = 0;\n        self.initialMarginInUsd = 0;\n        self.initialMarginInUsdFromBalance = 0;\n        self.holdPoolAmount = 0;\n        self.positionFee.closeFeeInUsd = 0;\n        self.realizedPnl = 0;\n        self.positionFee.closeFeeInUsd = 0;\n        self.positionFee.openBorrowingFeePerToken = 0;\n        self.positionFee.realizedBorrowingFee = 0;\n        self.positionFee.realizedBorrowingFeeInUsd = 0;\n        self.positionFee.openFundingFeePerQty = 0;\n        self.positionFee.realizedFundingFee = 0;\n        self.positionFee.realizedFundingFeeInUsd = 0;\n    }\n\n    function emitPositionUpdateEvent(Props storage self, uint256 requestId, PositionUpdateFrom from, uint256 executePrice) external {\n        emit PositionUpdateEvent(\n            requestId,\n            getPositionKey(self.account, self.symbol, self.marginToken, self.isCrossMargin),\n            from,\n            self,\n            executePrice\n        );\n    }\n\n}\n"
    },
    "contracts/storage/Redeem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nlibrary Redeem {\n    \n    bytes32 constant REDEEM_KEY = keccak256(abi.encode(\"link.profile.storage.Redeem\"));\n\n    struct Props {\n        mapping(uint256 => Request) requests;\n    }\n\n    struct Request {\n        address account;\n        address receiver;\n        address stakeToken;\n        address redeemToken;\n        uint256 unStakeAmount;\n        uint256 minRedeemAmount;\n        uint256 executionFee;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = REDEEM_KEY;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(uint256 requestId) external view returns (Request storage) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function get(uint256 requestId) external view returns (Request memory) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function remove(uint256 requestId) external {\n        Props storage self = load();\n        delete self.requests[requestId];\n    }\n}\n"
    },
    "contracts/storage/RoleAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../utils/Errors.sol\";\n\nlibrary RoleAccessControl {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    bytes32 internal constant ACCESS_CONTROL_KEY = keccak256(abi.encode(\"link.profile.storage.AccessControl\"));\n\n    bytes32 constant ROLE_ADMIN = \"ADMIN\";\n    bytes32 constant ROLE_CONFIG = \"CONFIG\";\n    bytes32 constant ROLE_KEEPER = \"KEEPER\";\n\n    struct Props {\n        mapping(address => EnumerableSet.Bytes32Set) accountRoles;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = ACCESS_CONTROL_KEY;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function checkRole(bytes32 role) internal view {\n        if (!hasRole(msg.sender, role)) {\n            revert Errors.InvalidRoleAccess(msg.sender, role);\n        }\n    }\n\n    function hasRole(bytes32 role) internal view returns (bool) {\n        return hasRole(msg.sender, role);\n    }\n\n    function hasRole(address account, bytes32 role) internal view returns (bool) {\n        Props storage self = load();\n        return self.accountRoles[account].contains(role);\n    }\n\n    function grantRole(address account, bytes32 role) internal {\n        Props storage self = load();\n        self.accountRoles[account].add(role);\n    }\n\n    function revokeRole(address account, bytes32 role) internal {\n        Props storage self = load();\n        if (self.accountRoles[account].contains(role)) {\n            self.accountRoles[account].remove(role);\n        }\n    }\n\n    function revokeAllRole(address account) internal {\n        Props storage self = load();\n        delete self.accountRoles[account];\n    }\n}\n"
    },
    "contracts/storage/StakingAccount.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./LpPool.sol\";\nimport \"hardhat/console.sol\";\n\nlibrary StakingAccount {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using LpPool for LpPool.Props;\n\n    struct Props {\n        address owner;\n        EnumerableSet.AddressSet stakeTokens;\n        mapping(address => Balance) stakeTokenBalances;\n        mapping(address => FeeRewards) feeRewards;\n        uint256 stakeUsdAmount;\n    }\n\n    struct FeeRewards {\n        uint256 realisedRewardsTokenAmount;\n        uint256 openRewardsPerStakeToken;\n    }\n\n    struct Balance {\n        uint256 stakeAmount;\n        EnumerableSet.AddressSet collateralTokens;\n        mapping(address => CollateralData) collateralDatas;\n    }\n\n    struct CollateralData {\n        uint256 amount;\n        uint256 stakeLiability;\n    }\n    event StakingAccountCollateralUpdateEvent(\n        address account,\n        address stakeToken,\n        address collateral,\n        uint256 preAmount,\n        uint256 preLiability,\n        uint256 amount,\n        uint256 liability\n    );\n\n    function load(address owner) public pure returns (Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profile.storage.StakingAccount\", owner));\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function addStakeAmount(Props storage self, address stakeToken, uint256 amount) external {\n        if (self.stakeTokens.contains(stakeToken)) {\n            self.stakeTokenBalances[stakeToken].stakeAmount = self.stakeTokenBalances[stakeToken].stakeAmount + amount;\n        } else {\n            self.stakeTokens.add(stakeToken);\n            self.stakeTokenBalances[stakeToken].stakeAmount = amount;\n        }\n    }\n\n    function subStakeAmount(Props storage self, address stakeToken, uint256 amount) external {\n        require(self.stakeTokenBalances[stakeToken].stakeAmount >= amount, \"token amount not enough\");\n        self.stakeTokenBalances[stakeToken].stakeAmount = self.stakeTokenBalances[stakeToken].stakeAmount - amount;\n    }\n\n    function addStakeLiability(\n        Props storage self,\n        address stakeToken,\n        address collateralToken,\n        uint256 liability\n    ) external {\n        if (!self.stakeTokens.contains(stakeToken)) {\n            self.stakeTokens.add(stakeToken);\n        }\n        if (!self.stakeTokenBalances[stakeToken].collateralTokens.contains(collateralToken)) {\n            self.stakeTokenBalances[stakeToken].collateralTokens.add(collateralToken);\n        }\n        CollateralData storage data = self.stakeTokenBalances[stakeToken].collateralDatas[collateralToken];\n        uint256 preLiability = data.stakeLiability;\n        data.stakeLiability += liability;\n        emit StakingAccountCollateralUpdateEvent(\n            self.owner,\n            stakeToken,\n            collateralToken,\n            data.amount,\n            preLiability,\n            data.amount,\n            data.stakeLiability\n        );\n    }\n\n    function subStakeLiability(\n        Props storage self,\n        address stakeToken,\n        address collateralToken,\n        uint256 liability\n    ) external {\n        require(\n            self.stakeTokens.contains(stakeToken) &&\n                self.stakeTokenBalances[stakeToken].collateralTokens.contains(collateralToken),\n            \"stake liability not enough\"\n        );\n        require(\n            self.stakeTokenBalances[stakeToken].collateralDatas[collateralToken].stakeLiability >= liability,\n            \"stake liability not enough\"\n        );\n        CollateralData storage data = self.stakeTokenBalances[stakeToken].collateralDatas[collateralToken];\n        uint256 preLiability = data.stakeLiability;\n        data.stakeLiability -= liability;\n        emit StakingAccountCollateralUpdateEvent(\n            self.owner,\n            stakeToken,\n            collateralToken,\n            data.amount,\n            preLiability,\n            data.amount,\n            data.stakeLiability\n        );\n    }\n\n    function addCollateralToken(\n        Props storage self,\n        address stakeToken,\n        address collateralToken,\n        uint256 amount\n    ) external {\n        if (!self.stakeTokens.contains(stakeToken)) {\n            self.stakeTokens.add(stakeToken);\n        }\n        if (!self.stakeTokenBalances[stakeToken].collateralTokens.contains(collateralToken)) {\n            self.stakeTokenBalances[stakeToken].collateralTokens.add(collateralToken);\n        }\n        CollateralData storage data = self.stakeTokenBalances[stakeToken].collateralDatas[collateralToken];\n        uint256 preAmount = data.amount;\n        data.amount += amount;\n        emit StakingAccountCollateralUpdateEvent(\n            self.owner,\n            stakeToken,\n            collateralToken,\n            preAmount,\n            data.stakeLiability,\n            data.amount,\n            data.stakeLiability\n        );\n    }\n\n    function subCollateralToken(\n        Props storage self,\n        address stakeToken,\n        address collateralToken,\n        uint256 amount\n    ) external {\n        require(\n            self.stakeTokens.contains(stakeToken) &&\n                self.stakeTokenBalances[stakeToken].collateralTokens.contains(collateralToken),\n            \"stake amount not enough\"\n        );\n        require(\n            self.stakeTokenBalances[stakeToken].collateralDatas[collateralToken].amount >= amount,\n            \"stake amount not enough\"\n        );\n        CollateralData storage data = self.stakeTokenBalances[stakeToken].collateralDatas[collateralToken];\n        uint256 preAmount = data.amount;\n        data.amount -= amount;\n        emit StakingAccountCollateralUpdateEvent(\n            self.owner,\n            stakeToken,\n            collateralToken,\n            preAmount,\n            data.stakeLiability,\n            data.amount,\n            data.stakeLiability\n        );\n    }\n\n    function hasCollateralToken(Props storage self, address stakeToken) external view returns (bool) {\n        if (!self.stakeTokens.contains(stakeToken)) {\n            return false;\n        }\n        address[] memory tokens = self.stakeTokenBalances[stakeToken].collateralTokens.values();\n        uint256 totalAmount = 0;\n        for (uint256 i; i < tokens.length; i++) {\n            totalAmount += self.stakeTokenBalances[stakeToken].collateralDatas[tokens[i]].amount;\n        }\n        return totalAmount > 0;\n    }\n\n    function getCollateralTokens(Props storage self, address stakeToken) external view returns (address[] memory) {\n        return self.stakeTokenBalances[stakeToken].collateralTokens.values();\n    }\n\n    function getCollateralToken(\n        Props storage self,\n        address stakeToken,\n        address collateralToken\n    ) external view returns (CollateralData memory) {\n        return self.stakeTokenBalances[stakeToken].collateralDatas[collateralToken];\n    }\n\n    function getSortedCollateralToken(Props storage self, address stakeToken) external view returns (address[] memory) {\n        LpPool.Props storage pool = LpPool.load(stakeToken);\n        address[] memory tokens = self.stakeTokenBalances[stakeToken].collateralTokens.values();\n        Config.StakeCollateralConfig[] memory collateralConfigs = new Config.StakeCollateralConfig[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            collateralConfigs[i] = pool.getStakeCollateralConfig(tokens[i]);\n        }\n        if (collateralConfigs.length > 1) {\n            for (uint i = 1; i < collateralConfigs.length; i++) {\n                Config.StakeCollateralConfig memory temp = collateralConfigs[i];\n                address tempToken = tokens[i];\n                uint j = i;\n                while ((j >= 1) && (temp.discount < collateralConfigs[j - 1].discount)) {\n                    collateralConfigs[j] = collateralConfigs[j - 1];\n                    tokens[j] = tokens[j - 1];\n                    j--;\n                }\n                collateralConfigs[j] = temp;\n                tokens[j] = tempToken;\n            }\n        }\n        return tokens;\n    }\n\n    function addStakeUsdAmount(Props storage self, uint256 amount) external {\n        self.stakeUsdAmount = self.stakeUsdAmount + amount;\n    }\n\n    function subStakeUsdAmount(Props storage self, uint256 amount) external {\n        require(self.stakeUsdAmount >= amount, \"usd token amount not enough\");\n        self.stakeUsdAmount = self.stakeUsdAmount - amount;\n    }\n\n    function getStakeTokens(Props storage self) external view returns(address[] memory) {\n        return self.stakeTokens.values();\n    }\n\n    function getFeeRewards(Props storage self, address stakeToken) external view returns(FeeRewards storage){\n        return self.feeRewards[stakeToken];\n    }\n}\n"
    },
    "contracts/storage/Symbol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary Symbol {\n    enum Status {\n        OPEN,\n        PAUSE,\n        REDUCE_ONLY,\n        SETTLED\n    }\n\n    struct Props {\n        bytes32 code;\n        Status status;\n        address stakeToken;\n        address indexToken;\n        address baseToken;\n        string baseTokenName;\n    }\n\n    function create(bytes32 code) external returns (Props storage self) {\n        self = load(code);\n        self.code = code;\n    }\n\n    function load(bytes32 code) public pure returns (Props storage self) {\n        bytes32 s = keccak256(abi.encode(\"link.profile.storage.Symbol\", code));\n\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function isSupportIncreaseOrder(Props storage self) external view returns (bool) {\n        return self.status == Status.OPEN;\n    }\n}\n"
    },
    "contracts/storage/UpdateLeverage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary UpdateLeverage {\n    bytes32 constant KEY = keccak256(abi.encode(\"link.profile.storage.UpdateLeverage\"));\n\n    struct Props {\n        mapping(uint256 => Request) requests;\n    }\n\n    struct Request {\n        address account;\n        bytes32 symbol;\n        bool isLong;\n        bool isExecutionFeeFromTradeVault;\n        bool isCrossMargin;\n        uint256 leverage;\n        address marginToken;\n        uint256 addMarginAmount;\n        uint256 executionFee;\n        uint256 lastBlock;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = KEY;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(uint256 requestId) external view returns (Request storage) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function get(uint256 requestId) external view returns (Request memory) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function remove(uint256 requestId) external {\n        Props storage self = load();\n        delete self.requests[requestId];\n    }\n}\n"
    },
    "contracts/storage/UpdatePositionMargin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nlibrary UpdatePositionMargin {\n    bytes32 constant KEY = keccak256(abi.encode(\"link.profile.storage.UpdatePositionMargin\"));\n\n    struct Props {\n        mapping(uint256 => Request) requests;\n    }\n\n    struct Request {\n        address account;\n        bytes32 positionKey;\n        address marginToken;\n        uint256 updateMarginAmount;\n        uint256 executionFee;\n        bool isAdd;\n        bool isExecutionFeeFromTradeVault;\n        uint256 lastBlock;\n\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = KEY;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(uint256 requestId) external view returns (Request storage) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function get(uint256 requestId) external view returns (Request memory) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function remove(uint256 requestId) external {\n        Props storage self = load();\n        delete self.requests[requestId];\n    }\n}\n"
    },
    "contracts/storage/UsdPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../utils/CalUtils.sol\";\nimport \"../utils/ChainUtils.sol\";\nimport \"./Config.sol\";\n\nlibrary UsdPool {\n    bytes32 private constant _KEY = keccak256(abi.encode(\"link.profile.storage.UsdPool\"));\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using Config for Config.Props;\n\n    struct Props {\n        EnumerableSet.AddressSet stableTokens;\n        mapping(address => TokenBalance) stableTokenBalances;\n        mapping(address => BorrowingFee) borrowingFees;\n        uint256 apr;\n    }\n\n    struct TokenBalance {\n        uint256 amount;\n        uint256 holdAmount;\n        uint256 unsettledAmount;\n    }\n\n    struct BorrowingFee {\n        uint256 totalBorrowingFee;\n        uint256 totalRealizedBorrowingFee;\n        uint256 cumulativeBorrowingFeePerToken;\n        uint256 lastUpdateTime;\n    }\n\n    struct UsdPoolTokenUpdateCache {\n        address token;\n        uint256 preAmount;\n        uint256 preHoldAmount;\n        uint256 preUnsettledAmount;\n        uint256 amount;\n        uint256 holdAmount;\n        uint256 unsettledAmount;\n        uint256 updateBlock;\n    }\n\n    event UsdPoolTokenUpdateEvent(\n        address token,\n        uint256 preAmount,\n        uint256 preHoldAmount,\n        uint256 preUnsettledAmount,\n        uint256 amount,\n        uint256 holdAmount,\n        uint256 unsettledAmount,\n        uint256 updateBlock\n    );\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = _KEY;\n\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function getUsdPoolConfig() internal view returns (Config.UsdPoolConfig storage) {\n        return Config.load().getUsdPoolConfig();\n    }\n\n    function addStableToken(Props storage self, address stableToken, uint amount) external {\n        require(self.stableTokens.contains(stableToken), \"stable token not supported!\");\n        UsdPoolTokenUpdateCache memory cache = _convertBalanceToCache(\n            stableToken,\n            self.stableTokenBalances[stableToken]\n        );\n        self.stableTokenBalances[stableToken].amount += amount;\n        cache.amount = self.stableTokenBalances[stableToken].amount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function subStableToken(Props storage self, address stableToken, uint amount) external {\n        require(isSubAmountAllowed(self, stableToken, amount), \"sub failed with balance not enough\");\n        UsdPoolTokenUpdateCache memory cache = _convertBalanceToCache(\n            stableToken,\n            self.stableTokenBalances[stableToken]\n        );\n        self.stableTokenBalances[stableToken].amount -= amount;\n        cache.amount = self.stableTokenBalances[stableToken].amount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function holdStableToken(Props storage self, address stableToken, uint amount) external {\n        require(\n            isHoldAmountAllowed(self.stableTokenBalances[stableToken], getPoolLiquidityLimit(), amount),\n            \"hold failed with balance not enough\"\n        );\n        UsdPoolTokenUpdateCache memory cache = _convertBalanceToCache(\n            stableToken,\n            self.stableTokenBalances[stableToken]\n        );\n        self.stableTokenBalances[stableToken].holdAmount += amount;\n        cache.holdAmount = self.stableTokenBalances[stableToken].holdAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function unHoldStableToken(Props storage self, address stableToken, uint256 amount) external {\n        require(self.stableTokenBalances[stableToken].holdAmount >= amount, \"sub hold bigger than hold\");\n        UsdPoolTokenUpdateCache memory cache = _convertBalanceToCache(\n            stableToken,\n            self.stableTokenBalances[stableToken]\n        );\n        self.stableTokenBalances[stableToken].holdAmount -= amount;\n        cache.holdAmount = self.stableTokenBalances[stableToken].holdAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function addUnsettleStableToken(Props storage self, address stableToken, uint256 amount) external {\n        UsdPoolTokenUpdateCache memory cache = _convertBalanceToCache(\n            stableToken,\n            self.stableTokenBalances[stableToken]\n        );\n        self.stableTokenBalances[stableToken].unsettledAmount += amount;\n        cache.unsettledAmount = self.stableTokenBalances[stableToken].unsettledAmount;\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function settleStableToken(Props storage self, address stableToken, uint256 amount, bool updateAmount) external {\n        if (!self.stableTokens.contains(stableToken)) {\n            self.stableTokens.add(stableToken);\n        }\n        TokenBalance storage balance = self.stableTokenBalances[stableToken];\n        require(balance.unsettledAmount >= amount, \"xUsd settle stable token overflow!\");\n        UsdPoolTokenUpdateCache memory cache = _convertBalanceToCache(stableToken, balance);\n        balance.unsettledAmount -= amount;\n        cache.unsettledAmount = balance.unsettledAmount;\n        if (updateAmount) {\n            balance.amount += amount;\n            cache.amount = balance.amount;\n        }\n        _emitPoolUpdateEvent(cache);\n    }\n\n    function addSupportStableTokens(Props storage self, address[] memory stableTokens) external {\n        for (uint256 i; i < stableTokens.length; i++) {\n            self.stableTokens.add(stableTokens[i]);\n        }\n    }\n\n    function removeSupportStableToken(Props storage self, address stableToken) external {\n        self.stableTokens.remove(stableToken);\n    }\n\n    function getPoolLiquidityLimit() public view returns (uint256) {\n        return getUsdPoolConfig().poolLiquidityLimit;\n    }\n\n    function getBorrowingFees(Props storage self, address stableToken) external view returns (BorrowingFee storage) {\n        return self.borrowingFees[stableToken];\n    }\n\n    function getStableTokens(Props storage self) external view returns (address[] memory) {\n        return self.stableTokens.values();\n    }\n\n    function getSupportedStableTokens() external view returns (address[] memory) {\n        Props storage self = load();\n        return self.stableTokens.values();\n    }\n\n    function isSupportStableToken(address stableToken) external view returns (bool) {\n        Props storage self = load();\n        return self.stableTokens.contains(stableToken);\n    }\n\n    function getStableTokenBalance(\n        Props storage self,\n        address stableToken\n    ) external view returns (TokenBalance memory) {\n        return self.stableTokenBalances[stableToken];\n    }\n\n    function getStableTokenBalanceArray(Props storage self) external view returns (TokenBalance[] memory) {\n        address[] memory tokens = self.stableTokens.values();\n        TokenBalance[] memory balances = new TokenBalance[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            balances[i] = self.stableTokenBalances[tokens[i]];\n        }\n        return balances;\n    }\n\n    function getAllBorrowingFees(Props storage self) external view returns (BorrowingFee[] memory) {\n        address[] memory tokens = self.stableTokens.values();\n        BorrowingFee[] memory fees = new BorrowingFee[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            fees[i] = self.borrowingFees[tokens[i]];\n        }\n        return fees;\n    }\n\n    function getMaxWithdrawArray(Props storage self) external view returns (uint256[] memory) {\n        address[] memory tokens = self.stableTokens.values();\n        uint256[] memory maxWithdraws = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; i++) {\n            maxWithdraws[i] = getMaxWithdraw(self, tokens[i]);\n        }\n        return maxWithdraws;\n    }\n\n    function getMaxWithdraw(Props storage self, address stableToken) public view returns (uint256) {\n        TokenBalance storage balance = self.stableTokenBalances[stableToken];\n        uint256 poolLiquidityLimit = getPoolLiquidityLimit();\n        if (poolLiquidityLimit == 0) {\n            return balance.amount - balance.holdAmount;\n        } else {\n            return balance.amount - CalUtils.divRate(balance.holdAmount, poolLiquidityLimit);\n        }\n    }\n\n    function getMaxAmountStableToken(Props storage self) external view returns (address token) {\n        address[] memory tokens = self.stableTokens.values();\n        uint256 maxAmount;\n        for (uint256 i; i < tokens.length; i++) {\n            if (self.stableTokenBalances[tokens[i]].amount >= maxAmount) {\n                maxAmount = self.stableTokenBalances[tokens[i]].amount;\n                token = tokens[i];\n            }\n        }\n    }\n\n    function isSubAmountAllowed(Props storage self, address stableToken, uint256 amount) public view returns (bool) {\n        TokenBalance storage balance = self.stableTokenBalances[stableToken];\n        if (balance.amount < amount) {\n            return false;\n        }\n        uint256 poolLiquidityLimit = getPoolLiquidityLimit();\n        if (poolLiquidityLimit == 0) {\n            return balance.amount - balance.holdAmount >= amount;\n        } else {\n            return CalUtils.mulRate(balance.amount - amount, poolLiquidityLimit) >= balance.holdAmount;\n        }\n    }\n\n    function isHoldAmountAllowed(\n        TokenBalance memory balance,\n        uint256 poolLiquidityLimit,\n        uint256 amount\n    ) internal pure returns (bool) {\n        if (poolLiquidityLimit == 0) {\n            return balance.amount + balance.unsettledAmount - balance.holdAmount >= amount;\n        } else {\n            return\n                CalUtils.mulRate(balance.amount + balance.unsettledAmount, poolLiquidityLimit) - balance.holdAmount >=\n                amount;\n        }\n    }\n\n    function _convertBalanceToCache(\n        address token,\n        TokenBalance storage balance\n    ) internal view returns (UsdPoolTokenUpdateCache memory cache) {\n        cache.token = token;\n        cache.preAmount = balance.amount;\n        cache.preHoldAmount = balance.holdAmount;\n        cache.preUnsettledAmount = balance.unsettledAmount;\n        cache.amount = balance.amount;\n        cache.holdAmount = balance.holdAmount;\n        cache.unsettledAmount = balance.unsettledAmount;\n        cache.updateBlock = ChainUtils.currentBlock();\n    }\n\n    function _emitPoolUpdateEvent(UsdPoolTokenUpdateCache memory cache) internal {\n        emit UsdPoolTokenUpdateEvent(\n            cache.token,\n            cache.preAmount,\n            cache.preHoldAmount,\n            cache.preUnsettledAmount,\n            cache.amount,\n            cache.holdAmount,\n            cache.unsettledAmount,\n            cache.updateBlock\n        );\n    }\n}\n"
    },
    "contracts/storage/UuidCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nlibrary UuidCreator {\n    bytes32 private constant _UUID_CREATOR = keccak256(abi.encode(\"link.profit.storage.UuidCreator\"));\n\n    uint256 private constant MIN_ID = 1111;\n\n    struct Props {\n        mapping(bytes32 => uint256) lastIds;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = _UUID_CREATOR;\n\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function nextId(bytes32 key) external returns (uint256) {\n        Props storage self = load();\n        uint256 lastId = self.lastIds[key];\n        if (lastId < MIN_ID) {\n            lastId = MIN_ID + 1;\n        } else {\n            lastId++;\n        }\n        self.lastIds[key] = lastId;\n        return lastId;\n    }\n\n    function getId(bytes32 key) external view returns (uint256) {\n        Props storage self = load();\n        return self.lastIds[key];\n    }\n}\n"
    },
    "contracts/storage/Withdraw.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\nlibrary Withdraw {\n    bytes32 constant WITHDRAW_KEY = keccak256(abi.encode(\"link.profile.storage.Withdraw\"));\n\n    struct Props {\n        mapping(uint256 => Request) requests;\n    }\n\n    struct Request {\n        address account;\n        address token;\n        uint256 amount;\n    }\n\n    function load() public pure returns (Props storage self) {\n        bytes32 s = WITHDRAW_KEY;\n        assembly {\n            self.slot := s\n        }\n    }\n\n    function create(uint256 requestId) external view returns (Request storage) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function get(uint256 requestId) external view returns (Request memory) {\n        Props storage self = load();\n        return self.requests[requestId];\n    }\n\n    function remove(uint256 requestId) external {\n        Props storage self = load();\n        delete self.requests[requestId];\n    }\n}\n"
    },
    "contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary AddressUtils {\n    uint256 public constant TEST = 1000;\n\n    error AddressZero();\n\n    function validEmpty(address addr) external pure {\n        if (addr == address(0)) {\n            revert AddressZero();\n        }\n    }\n\n    function isEmpty(address addr) external pure returns (bool) {\n        return addr == address(0);\n    }\n\n}\n"
    },
    "contracts/utils/CalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\nlibrary CalUtils {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SignedMath for int256;\n    using SignedSafeMath for int256;\n\n    uint256 public constant SMALL_RATE_PRECISION = 10 ** 18;\n\n    uint256 public constant RATE_PRECISION = 100000;\n\n    uint256 public constant PRICE_PRECISION = 10 ** 8;\n\n    uint256 public constant PRICE_TO_WEI = 10 ** 10;\n\n    uint256 public constant USD_PRECISION = 10 ** 18;\n\n    function mulRate(uint256 value, uint256 rate) external pure returns (uint256) {\n        return Math.mulDiv(value, rate, RATE_PRECISION);\n    }\n\n    function mulRate(int256 value, int256 rate) external pure returns (int256) {\n        return value.mul(rate).div(RATE_PRECISION.toInt256());\n    }\n\n    function divRate(uint256 value, uint256 rate) external pure returns (uint256) {\n        return Math.mulDiv(value, RATE_PRECISION, rate);\n    }\n\n    function divToPrecision(uint256 value1, uint256 value2, uint256 precision) external pure returns (uint256) {\n        return Math.mulDiv(value1, precision, value2);\n    }\n\n    function mulSmallRate(uint256 value, uint256 rate) external pure returns (uint256) {\n        return Math.mulDiv(value, rate, SMALL_RATE_PRECISION);\n    }\n\n    function mulIntSmallRate(int256 value, int256 rate) external pure returns (int256) {\n        return value.mul(rate).div(SMALL_RATE_PRECISION.toInt256());\n    }\n\n    function divSmallRate(uint256 value, uint256 rate) external pure returns (uint256) {\n        return Math.mulDiv(value, SMALL_RATE_PRECISION, rate);\n    }\n\n    function tokenToUsd(uint256 tokenAmount, uint8 tokenDecimals, uint256 tokenPrice) external pure returns (uint256) {\n        return tokenAmount.mul(tokenPrice).mul(PRICE_TO_WEI).div(10 ** tokenDecimals);\n    }\n\n    function tokenToUsdInt(int256 tokenAmount, uint8 tokenDecimals, int256 tokenPrice) external pure returns (int256) {\n        return tokenAmount.mul(tokenPrice).mul(PRICE_TO_WEI.toInt256()).div((10 ** tokenDecimals).toInt256());\n    }\n\n    function usdToToken(\n        uint256 tokenUsdAmount,\n        uint8 tokenDecimals,\n        uint256 tokenPrice\n    ) external pure returns (uint256) {\n        return Math.mulDiv(tokenUsdAmount, 10 ** tokenDecimals, tokenPrice.mul(PRICE_TO_WEI));\n    }\n\n    function usdToTokenInt(\n        int256 tokenUsdAmount,\n        uint8 tokenDecimals,\n        int256 tokenPrice\n    ) external pure returns (int256) {\n        return tokenUsdAmount.mul((10 ** tokenDecimals).toInt256()).div(tokenPrice.mul(PRICE_TO_WEI.toInt256()));\n    }\n\n    function tokenToToken(\n        uint256 originTokenAmount,\n        uint8 originTokenDecimals,\n        uint8 targetTokenDecimals,\n        uint256 tokenToTokenPrice\n    ) external pure returns (uint256) {\n        if (targetTokenDecimals >= originTokenDecimals) {\n            return\n                originTokenAmount.mul(tokenToTokenPrice).mul(10 ** (targetTokenDecimals - originTokenDecimals)).div(\n                    PRICE_PRECISION\n                );\n        } else {\n            return\n                originTokenAmount.mul(tokenToTokenPrice).div(PRICE_PRECISION).div(\n                    10 ** (originTokenDecimals - targetTokenDecimals)\n                );\n        }\n    }\n\n    function tokenToToken(\n        uint256 originTokenAmount,\n        uint8 originTokenDecimals,\n        uint8 targetTokenDecimals,\n        uint256 originTokenPrice,\n        uint256 targetTokenPrice\n    ) external pure returns (uint256) {\n        if (targetTokenDecimals >= originTokenDecimals) {\n            return\n                originTokenAmount.mul(originTokenPrice).mul(10 ** (targetTokenDecimals - originTokenDecimals)).div(\n                    targetTokenPrice\n                );\n        } else {\n            return\n                originTokenAmount.mul(originTokenPrice).div(targetTokenPrice).div(\n                    10 ** (originTokenDecimals - targetTokenDecimals)\n                );\n        }\n    }\n\n    function decimalsToDecimals(\n        uint256 value,\n        uint8 originDecimals,\n        uint8 targetDecimals\n    ) external pure returns (uint256) {\n        return Math.mulDiv(value, 10 ** targetDecimals, 10 ** originDecimals);\n    }\n\n    function computeAvgEntryPrice(\n        uint256 qty,\n        uint256 entryPrice,\n        uint256 increaseQty,\n        uint256 tokenPrice,\n        uint256 tickSize,\n        bool isUp\n    ) external pure returns (uint256) {\n        uint256 originEntryPrice = (qty.mul(entryPrice).add(increaseQty.mul(tokenPrice))).div(qty + increaseQty);\n        return formatToTickSize(originEntryPrice, tickSize, isUp);\n    }\n\n    function formatToTickSize(uint256 value, uint256 tickSize, bool roundUp) public pure returns (uint256) {\n        uint256 mod = value % tickSize;\n        if (mod == 0) {\n            return value;\n        } else {\n            return (value.div(tickSize).add((roundUp ? 1 : 0))).mul(tickSize);\n        }\n    }\n\n    function diff(uint256 value1, uint256 value2) external pure returns (uint256) {\n        return value1 > value2 ? value1 - value2 : value2 - value1;\n    }\n}\n"
    },
    "contracts/utils/ChainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary ChainUtils {\n    function currentTimestamp() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function currentBlock() external view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "contracts/utils/CommonUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Errors.sol\";\n\nlibrary CommonUtils {\n\n    function validBlockNumber(uint256 blockNo, uint256 minGap, uint256 maxGap) external view {\n        uint256 lastBlockNo = block.number;\n        if (lastBlockNo <  blockNo + minGap) {\n            revert Errors.BlockNumberInvalid();\n        }\n        if (maxGap > 0 && lastBlockNo > blockNo + maxGap) {\n            revert Errors.BlockNumberInvalid();\n        }\n    }\n\n    function validMinBlockNumber(uint256 blockNo, uint256 minGap) external view {\n        uint256 lastBlockNo = block.number;\n        if (lastBlockNo <  blockNo + minGap) {\n            revert Errors.BlockNumberInvalid();\n        }\n    }\n\n}"
    },
    "contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary Errors {\n    // common\n    error AddressSelfNotSupported(address self);\n    error AmountNotMatch(uint256 amount1, uint256 amount2);\n    error AmountZeroNotAllowed();\n    error PriceIsZero();\n    error UnknownError(bytes msg);\n    error InvalidRoleAccess(address account, bytes32 role);\n    error InvalidRoleName(bytes32 role);\n    error ExecutionFeeNotEnough();\n    error BlockNumberInvalid();\n\n    // transfer\n    error BalanceNotEnough(address account, address token);\n    error WithdrawWithNoEnoughAmount();\n    error WithdrawRequestNotExists();\n    error WithdrawNotAllowed();\n    error TokenTransferError(address token, address receiver, uint256 amount);\n    error TransferErrorWithVaultBalanceNotEnough(address vault, address token, address receiver, uint256 amount);\n    error IgnoreSwapWithAccountLiabilityZero();\n\n    // market\n    error CreateSymbolExists(bytes32 code);\n    error CreateStakePoolExists(address stakeToken);\n    error SymbolNotExists();\n    error SymbolStatusInvalid(bytes32 symbol);\n    error StakeTokenInvalid(address stakeToken);\n    error PoolNotExists();\n    error PoolValueLessThanZero();\n    error PoolAmountNotEnough(address stakeToken, address token);\n    error PoolUnsettledAmountInvalid();\n\n    // tokens\n    error TokenIsNotSupport();\n    error TokenIsNotSupportCollateral();\n    error OnlyCollateralSupported();\n    error OnlyIsolateSupported();\n    error OnlyCrossSupported();\n    error CollateralUserCapOverflow(address token, uint256 cap);\n    error CollateralTotalCapOverflow(address token, uint256 cap);\n\n    // account\n    error AccountNotExist();\n\n    // mint\n    error MintRequestNotExists();\n    error MintTokenInvalid(address stakeToken, address mintToken);\n    error MintFailedWithBalanceNotEnough(address account, address baseToken);\n    error MintStakeTokenTooSmall(uint256 minStakeAmount, uint256 realStakeAmount);\n    error MintWithAmountZero();\n    error PoolValueIsZero();\n    error MintWithParamError();\n    error MintCollateralNotSupport();\n    error MintCollateralOverflow();\n    error MintCollateralFailedWithPriceCloseToDiscount();\n    \n\n    // redeem\n    error RedeemRequestNotExists();\n    error RedeemTokenInvalid(address stakeToken, address mintToken);\n    error RedeemCollateralNotSupport();\n    error RedeemWithAmountEmpty(address account, address stakeToken);\n    error RedeemWithAmountNotEnough(address account, address stakeToken);\n    error RedeemStakeTokenTooSmall(uint256 redeemAmount);\n    error RedeemReduceStakeTokenTooSmall();\n    error RedeemWithVaultBalanceNotEnough(address vaultAddr, uint256 amount);\n\n    // orders\n    error OrderNotExists(uint256 orderId);\n    error LeverageInvalid(bytes32 symbol, uint256 leverage);\n    error OrderMarginTooSmall();\n    error ReducePositionTooSmall(bytes32 symbol, address account);\n    error DecreasePositionNotExists(bytes32 symbol, address account, address marginToken);\n    error DecreaseQtyTooBig(bytes32 symbol, address account);\n    error DecreaseOrderSideInvalid();\n    error TokenInvalid(bytes32 symbol, address token);\n    error PlaceOrderWithParamsError();\n    error ExecutionFeeLessThanConfigGasFeeLimit();\n    error ExecutionPriceInvalid();\n    error ChangeCrossModeError(address account);\n    error CancelOrderWithLiquidation(bytes32 symbol, address account);\n    error OnlyDecreaseOrderSupported();\n\n    // positions\n    error PositionTooBig(bytes32 symbol, address account);\n    error OnlyOneShortPositionSupport(bytes32 symbol);\n    error MaxOILimited(bytes32 symbol, bool isLong);\n    error OIRatioLimited();\n    error PositionNotExists();\n    error UpdatePositionMarginRequestNotExists();\n    error AddMarginTooBig();\n    error ReduceMarginTooBig();\n    error PositionShouldBeLiquidation();\n    error UpdateLeverageRequestNotExists();\n    error UpdateLeverageWithNoChange();\n    error UpdateLeverageError(\n        address account,\n        bytes32 symbol,\n        bool isLong,\n        uint256 existsLeverage,\n        uint256 newLeverage\n    );\n    error LiquidationIgnored(address account);\n\n    // fee\n    error ClaimRewardsRequestNotExists();\n    error ClaimTokenNotSupported();\n}\n"
    },
    "contracts/utils/RoleKeys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary RoleKeys {\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    bytes32 public constant CONFIG_ROLE = keccak256(\"CONFIG_ROLE\");\n\n    bytes32 public constant ORDER_ROLE = keccak256(\"ORDER_ROLE\");\n\n    bytes32 public constant HANDLER_ROLE = keccak256(\"HANDLER_ROLE\");\n\n    \n}"
    },
    "contracts/utils/TokenUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nlibrary TokenUtils {\n    function decimals(address token) external view returns (uint8) {\n        return IERC20Metadata(token).decimals();\n    }\n\n    function totalSupply(address token) external view returns (uint256) {\n        return IERC20(token).totalSupply();\n    }\n}\n"
    },
    "contracts/utils/TransferUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../utils/Errors.sol\";\n\nlibrary TransferUtils {\n    uint256 private constant _TRANSFER_GAS_LIMIT = 100000;\n\n    function transfer(address token, address receiver, uint256 amount) external {\n        if (amount == 0) {\n            return;\n        }\n\n        (bool success, ) = nonRevertingTransferWithGasLimit(IERC20(token), receiver, amount, _TRANSFER_GAS_LIMIT);\n\n        if (success) {\n            return;\n        }\n\n        revert Errors.TokenTransferError(token, receiver, amount);\n    }\n\n    function nonRevertingTransferWithGasLimit(\n        IERC20 token,\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) internal returns (bool, bytes memory) {\n        bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, amount);\n        (bool success, bytes memory returndata) = address(token).call{ gas: gasLimit }(data);\n\n        if (success) {\n            // some tokens do not revert on a failed transfer, they will return a boolean instead\n            // validate that the returned boolean is true, otherwise indicate that the token transfer failed\n            if (returndata.length > 0 && !abi.decode(returndata, (bool))) {\n                return (false, returndata);\n            }\n\n            // transfers on some tokens do not return a boolean value, they will just revert if a transfer fails\n            // for these tokens, if success is true then the transfer should have completed\n            return (true, returndata);\n        }\n\n        return (false, returndata);\n    }\n}\n"
    },
    "contracts/utils/TypeUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nlibrary TypeUtils {\n\n    error Bytes32Empty();\n    error StringEmpty();\n    error IntZero();\n\n    function bytes32Equals(bytes32 a, bytes32 b) external pure returns (bool) {\n        if (a.length != b.length) \n            return false;\n        for (uint256 i; i < a.length; i++) {\n            if (a[i] != b[i])\n                return false;\n        } \n        return true;      \n    }\n    \n    function isBytes32Empty(bytes32 data) external pure returns (bool){\n        return data.length == 0;\n    }\n\n    function validNotZero(uint data) external pure {\n        if (data == 0) {\n            revert IntZero();\n        }\n    }\n\n    function validBytes32Empty(bytes32 data) external pure {\n        if (data.length == 0) {\n            revert Bytes32Empty();\n        }\n    }\n\n    function validStringEmpty(string memory data) external pure {\n        if (bytes(data).length == 0) {\n            revert StringEmpty();\n        }\n    }\n\n\n}"
    },
    "contracts/vault/LpVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Vault.sol\";\n\ncontract LpVault is Vault {\n    \n}"
    },
    "contracts/vault/PortfolioVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Vault.sol\";\n\ncontract PortfolioVault is Vault {\n        \n}"
    },
    "contracts/vault/StakeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./Vault.sol\";\nimport \"../utils/RoleKeys.sol\";\n\ncontract StakeToken is ERC20, Vault {\n    uint8 tokenTecimals = 18;\n\n    constructor(string memory symbol_, uint8 _decimals) ERC20(\"Stake token\", symbol_) {\n        tokenTecimals = _decimals;\n    }\n\n    // function mint(address account, uint256 amount) external onlyRole(RoleKeys.HANDLER_ROLE) {\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n\n    // function burn(address account, uint256 amount) external onlyRole(RoleKeys.HANDLER_ROLE) {\n    function burn(address account, uint256 amount) external {\n        _burn(account, amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return tokenTecimals;\n    }\n}\n"
    },
    "contracts/vault/TradeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Vault.sol\";\n\ncontract TradeVault is Vault {\n              \n}"
    },
    "contracts/vault/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../utils/TransferUtils.sol\";\nimport \"../utils/RoleKeys.sol\";\nimport \"../utils/Errors.sol\";\n\ncontract Vault is AccessControl {\n    using SafeERC20 for IERC20;\n    \n\n    mapping(address => uint256) public tokenBalances;\n\n    function transferOut(address token, address receiver, uint256 amount) external {\n        if (receiver == address(this)) {\n            revert Errors.AddressSelfNotSupported(receiver);\n        }\n        TransferUtils.transfer(token, receiver, amount);\n        tokenBalances[token] = IERC20(token).balanceOf(address(this));\n    }\n\n    function getTransferInAmount(address token) external returns (uint256) {\n        uint256 prevBalance = tokenBalances[token];\n        uint256 nextBalance = IERC20(token).balanceOf(address(this));\n        tokenBalances[token] = nextBalance;\n        return nextBalance - prevBalance;\n    }\n    \n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "viaIR": false,
    "optimizer": {
      "enabled": true,
      "runs": 4294967295
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
